! function (e, t) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) {
        if (!e.document) throw new Error("jQuery requires a window with a document");
        return t(e)
    } : t(e)
}("undefined" != typeof window ? window : this, function (R, e) {
    "use strict";
    var t = [],
        w = R.document,
        n = Object.getPrototypeOf,
        s = t.slice,
        m = t.concat,
        l = t.push,
        r = t.indexOf,
        i = {},
        o = i.toString,
        g = i.hasOwnProperty,
        a = g.toString,
        c = a.call(Object),
        E = {},
        v = function (e) {
            return "function" == typeof e && "number" != typeof e.nodeType
        },
        y = function (e) {
            return null != e && e === e.window
        },
        h = {
            type: !0,
            src: !0,
            noModule: !0
        };

    function T(e, t, i) {
        var n, r = (t = t || w).createElement("script");
        if (r.text = e, i)
            for (n in h) i[n] && (r[n] = i[n]);
        t.head.appendChild(r).parentNode.removeChild(r)
    }

    function b(e) {
        return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? i[o.call(e)] || "object" : typeof e
    }
    var u = "3.3.1",
        _ = function (e, t) {
            return new _.fn.init(e, t)
        },
        f = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    function d(e) {
        var t = !!e && "length" in e && e.length,
            i = b(e);
        return !v(e) && !y(e) && ("array" === i || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
    }
    _.fn = _.prototype = {
        jquery: u,
        constructor: _,
        length: 0,
        toArray: function () {
            return s.call(this)
        },
        get: function (e) {
            return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e]
        },
        pushStack: function (e) {
            var t = _.merge(this.constructor(), e);
            return t.prevObject = this, t
        },
        each: function (e) {
            return _.each(this, e)
        },
        map: function (i) {
            return this.pushStack(_.map(this, function (e, t) {
                return i.call(e, t, e)
            }))
        },
        slice: function () {
            return this.pushStack(s.apply(this, arguments))
        },
        first: function () {
            return this.eq(0)
        },
        last: function () {
            return this.eq(-1)
        },
        eq: function (e) {
            var t = this.length,
                i = +e + (e < 0 ? t : 0);
            return this.pushStack(0 <= i && i < t ? [this[i]] : [])
        },
        end: function () {
            return this.prevObject || this.constructor()
        },
        push: l,
        sort: t.sort,
        splice: t.splice
    }, _.extend = _.fn.extend = function () {
        var e, t, i, n, r, o, a = arguments[0] || {},
            s = 1,
            l = arguments.length,
            c = !1;
        for ("boolean" == typeof a && (c = a, a = arguments[s] || {}, s++), "object" == typeof a || v(a) || (a = {}), s === l && (a = this, s--); s < l; s++)
            if (null != (e = arguments[s]))
                for (t in e) i = a[t], a !== (n = e[t]) && (c && n && (_.isPlainObject(n) || (r = Array.isArray(n))) ? (o = r ? (r = !1, i && Array.isArray(i) ? i : []) : i && _.isPlainObject(i) ? i : {}, a[t] = _.extend(c, o, n)) : void 0 !== n && (a[t] = n));
        return a
    }, _.extend({
        expando: "jQuery" + (u + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function (e) {
            throw new Error(e)
        },
        noop: function () {},
        isPlainObject: function (e) {
            var t, i;
            return !(!e || "[object Object]" !== o.call(e)) && (!(t = n(e)) || "function" == typeof (i = g.call(t, "constructor") && t.constructor) && a.call(i) === c)
        },
        isEmptyObject: function (e) {
            var t;
            for (t in e) return !1;
            return !0
        },
        globalEval: function (e) {
            T(e)
        },
        each: function (e, t) {
            var i, n = 0;
            if (d(e))
                for (i = e.length; n < i && !1 !== t.call(e[n], n, e[n]); n++);
            else
                for (n in e)
                    if (!1 === t.call(e[n], n, e[n])) break;
            return e
        },
        trim: function (e) {
            return null == e ? "" : (e + "").replace(f, "")
        },
        makeArray: function (e, t) {
            var i = t || [];
            return null != e && (d(Object(e)) ? _.merge(i, "string" == typeof e ? [e] : e) : l.call(i, e)), i
        },
        inArray: function (e, t, i) {
            return null == t ? -1 : r.call(t, e, i)
        },
        merge: function (e, t) {
            for (var i = +t.length, n = 0, r = e.length; n < i; n++) e[r++] = t[n];
            return e.length = r, e
        },
        grep: function (e, t, i) {
            for (var n = [], r = 0, o = e.length, a = !i; r < o; r++) !t(e[r], r) !== a && n.push(e[r]);
            return n
        },
        map: function (e, t, i) {
            var n, r, o = 0,
                a = [];
            if (d(e))
                for (n = e.length; o < n; o++) null != (r = t(e[o], o, i)) && a.push(r);
            else
                for (o in e) null != (r = t(e[o], o, i)) && a.push(r);
            return m.apply([], a)
        },
        guid: 1,
        support: E
    }), "function" == typeof Symbol && (_.fn[Symbol.iterator] = t[Symbol.iterator]), _.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
        i["[object " + t + "]"] = t.toLowerCase()
    });
    var p = function (i) {
        var e, d, T, o, r, p, u, m, b, l, c, x, R, a, w, g, s, h, E, _ = "sizzle" + 1 * new Date,
            v = i.document,
            H = 0,
            n = 0,
            f = ae(),
            y = ae(),
            S = ae(),
            M = function (e, t) {
                return e === t && (c = !0), 0
            },
            C = {}.hasOwnProperty,
            t = [],
            A = t.pop,
            P = t.push,
            L = t.push,
            D = t.slice,
            z = function (e, t) {
                for (var i = 0, n = e.length; i < n; i++)
                    if (e[i] === t) return i;
                return -1
            },
            k = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            O = "[\\x20\\t\\r\\n\\f]",
            F = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
            j = "\\[" + O + "*(" + F + ")(?:" + O + "*([*^$|!~]?=)" + O + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + F + "))|)" + O + "*\\]",
            U = ":(" + F + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + j + ")*)|.*)\\)|)",
            V = new RegExp(O + "+", "g"),
            N = new RegExp("^" + O + "+|((?:^|[^\\\\])(?:\\\\.)*)" + O + "+$", "g"),
            B = new RegExp("^" + O + "*," + O + "*"),
            I = new RegExp("^" + O + "*([>+~]|" + O + ")" + O + "*"),
            $ = new RegExp("=" + O + "*([^\\]'\"]*?)" + O + "*\\]", "g"),
            G = new RegExp(U),
            W = new RegExp("^" + F + "$"),
            q = {
                ID: new RegExp("^#(" + F + ")"),
                CLASS: new RegExp("^\\.(" + F + ")"),
                TAG: new RegExp("^(" + F + "|[*])"),
                ATTR: new RegExp("^" + j),
                PSEUDO: new RegExp("^" + U),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + O + "*(even|odd|(([+-]|)(\\d*)n|)" + O + "*(?:([+-]|)" + O + "*(\\d+)|))" + O + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + k + ")$", "i"),
                needsContext: new RegExp("^" + O + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + O + "*((?:-\\d)?\\d*)" + O + "*\\)|)(?=[^-]|$)", "i")
            },
            X = /^(?:input|select|textarea|button)$/i,
            Y = /^h\d$/i,
            K = /^[^{]+\{\s*\[native \w/,
            Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            Z = /[+~]/,
            J = new RegExp("\\\\([\\da-f]{1,6}" + O + "?|(" + O + ")|.)", "ig"),
            ee = function (e, t, i) {
                var n = "0x" + t - 65536;
                return n != n || i ? t : n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)
            },
            te = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
            ie = function (e, t) {
                return t ? "\0" === e ? "ï¿½" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
            },
            ne = function () {
                x()
            },
            re = ve(function (e) {
                return !0 === e.disabled && ("form" in e || "label" in e)
            }, {
                dir: "parentNode",
                next: "legend"
            });
        try {
            L.apply(t = D.call(v.childNodes), v.childNodes), t[v.childNodes.length].nodeType
        } catch (e) {
            L = {
                apply: t.length ? function (e, t) {
                    P.apply(e, D.call(t))
                } : function (e, t) {
                    for (var i = e.length, n = 0; e[i++] = t[n++];);
                    e.length = i - 1
                }
            }
        }

        function oe(e, t, i, n) {
            var r, o, a, s, l, c, h, u = t && t.ownerDocument,
                f = t ? t.nodeType : 9;
            if (i = i || [], "string" != typeof e || !e || 1 !== f && 9 !== f && 11 !== f) return i;
            if (!n && ((t ? t.ownerDocument || t : v) !== R && x(t), t = t || R, w)) {
                if (11 !== f && (l = Q.exec(e)))
                    if (r = l[1]) {
                        if (9 === f) {
                            if (!(a = t.getElementById(r))) return i;
                            if (a.id === r) return i.push(a), i
                        } else if (u && (a = u.getElementById(r)) && E(t, a) && a.id === r) return i.push(a), i
                    } else {
                        if (l[2]) return L.apply(i, t.getElementsByTagName(e)), i;
                        if ((r = l[3]) && d.getElementsByClassName && t.getElementsByClassName) return L.apply(i, t.getElementsByClassName(r)), i
                    } if (d.qsa && !S[e + " "] && (!g || !g.test(e))) {
                    if (1 !== f) u = t, h = e;
                    else if ("object" !== t.nodeName.toLowerCase()) {
                        for ((s = t.getAttribute("id")) ? s = s.replace(te, ie) : t.setAttribute("id", s = _), o = (c = p(e)).length; o--;) c[o] = "#" + s + " " + Ee(c[o]);
                        h = c.join(","), u = Z.test(e) && me(t.parentNode) || t
                    }
                    if (h) try {
                        return L.apply(i, u.querySelectorAll(h)), i
                    } catch (e) {} finally {
                        s === _ && t.removeAttribute("id")
                    }
                }
            }
            return m(e.replace(N, "$1"), t, i, n)
        }

        function ae() {
            var n = [];
            return function e(t, i) {
                return n.push(t + " ") > T.cacheLength && delete e[n.shift()], e[t + " "] = i
            }
        }

        function se(e) {
            return e[_] = !0, e
        }

        function le(e) {
            var t = R.createElement("fieldset");
            try {
                return !!e(t)
            } catch (e) {
                return !1
            } finally {
                t.parentNode && t.parentNode.removeChild(t), t = null
            }
        }

        function ce(e, t) {
            for (var i = e.split("|"), n = i.length; n--;) T.attrHandle[i[n]] = t
        }

        function he(e, t) {
            var i = t && e,
                n = i && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
            if (n) return n;
            if (i)
                for (; i = i.nextSibling;)
                    if (i === t) return -1;
            return e ? 1 : -1
        }

        function ue(t) {
            return function (e) {
                return "input" === e.nodeName.toLowerCase() && e.type === t
            }
        }

        function fe(i) {
            return function (e) {
                var t = e.nodeName.toLowerCase();
                return ("input" === t || "button" === t) && e.type === i
            }
        }

        function de(t) {
            return function (e) {
                return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && re(e) === t : e.disabled === t : "label" in e && e.disabled === t
            }
        }

        function pe(a) {
            return se(function (o) {
                return o = +o, se(function (e, t) {
                    for (var i, n = a([], e.length, o), r = n.length; r--;) e[i = n[r]] && (e[i] = !(t[i] = e[i]))
                })
            })
        }

        function me(e) {
            return e && void 0 !== e.getElementsByTagName && e
        }
        for (e in d = oe.support = {}, r = oe.isXML = function (e) {
                var t = e && (e.ownerDocument || e).documentElement;
                return !!t && "HTML" !== t.nodeName
            }, x = oe.setDocument = function (e) {
                var t, i, n = e ? e.ownerDocument || e : v;
                return n !== R && 9 === n.nodeType && n.documentElement && (a = (R = n).documentElement, w = !r(R), v !== R && (i = R.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", ne, !1) : i.attachEvent && i.attachEvent("onunload", ne)), d.attributes = le(function (e) {
                    return e.className = "i", !e.getAttribute("className")
                }), d.getElementsByTagName = le(function (e) {
                    return e.appendChild(R.createComment("")), !e.getElementsByTagName("*").length
                }), d.getElementsByClassName = K.test(R.getElementsByClassName), d.getById = le(function (e) {
                    return a.appendChild(e).id = _, !R.getElementsByName || !R.getElementsByName(_).length
                }), d.getById ? (T.filter.ID = function (e) {
                    var t = e.replace(J, ee);
                    return function (e) {
                        return e.getAttribute("id") === t
                    }
                }, T.find.ID = function (e, t) {
                    if (void 0 !== t.getElementById && w) {
                        var i = t.getElementById(e);
                        return i ? [i] : []
                    }
                }) : (T.filter.ID = function (e) {
                    var i = e.replace(J, ee);
                    return function (e) {
                        var t = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
                        return t && t.value === i
                    }
                }, T.find.ID = function (e, t) {
                    if (void 0 !== t.getElementById && w) {
                        var i, n, r, o = t.getElementById(e);
                        if (o) {
                            if ((i = o.getAttributeNode("id")) && i.value === e) return [o];
                            for (r = t.getElementsByName(e), n = 0; o = r[n++];)
                                if ((i = o.getAttributeNode("id")) && i.value === e) return [o]
                        }
                        return []
                    }
                }), T.find.TAG = d.getElementsByTagName ? function (e, t) {
                    return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0
                } : function (e, t) {
                    var i, n = [],
                        r = 0,
                        o = t.getElementsByTagName(e);
                    if ("*" !== e) return o;
                    for (; i = o[r++];) 1 === i.nodeType && n.push(i);
                    return n
                }, T.find.CLASS = d.getElementsByClassName && function (e, t) {
                    if (void 0 !== t.getElementsByClassName && w) return t.getElementsByClassName(e)
                }, s = [], g = [], (d.qsa = K.test(R.querySelectorAll)) && (le(function (e) {
                    a.appendChild(e).innerHTML = "<a id='" + _ + "'></a><select id='" + _ + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=" + O + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || g.push("\\[" + O + "*(?:value|" + k + ")"), e.querySelectorAll("[id~=" + _ + "-]").length || g.push("~="), e.querySelectorAll(":checked").length || g.push(":checked"), e.querySelectorAll("a#" + _ + "+*").length || g.push(".#.+[+~]")
                }), le(function (e) {
                    e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    var t = R.createElement("input");
                    t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && g.push("name" + O + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), g.push(",.*:")
                })), (d.matchesSelector = K.test(h = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && le(function (e) {
                    d.disconnectedMatch = h.call(e, "*"), h.call(e, "[s!='']:x"), s.push("!=", U)
                }), g = g.length && new RegExp(g.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), E = t || K.test(a.contains) ? function (e, t) {
                    var i = 9 === e.nodeType ? e.documentElement : e,
                        n = t && t.parentNode;
                    return e === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(n) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(n)))
                } : function (e, t) {
                    if (t)
                        for (; t = t.parentNode;)
                            if (t === e) return !0;
                    return !1
                }, M = t ? function (e, t) {
                    if (e === t) return c = !0, 0;
                    var i = !e.compareDocumentPosition - !t.compareDocumentPosition;
                    return i || (1 & (i = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === i ? e === R || e.ownerDocument === v && E(v, e) ? -1 : t === R || t.ownerDocument === v && E(v, t) ? 1 : l ? z(l, e) - z(l, t) : 0 : 4 & i ? -1 : 1)
                } : function (e, t) {
                    if (e === t) return c = !0, 0;
                    var i, n = 0,
                        r = e.parentNode,
                        o = t.parentNode,
                        a = [e],
                        s = [t];
                    if (!r || !o) return e === R ? -1 : t === R ? 1 : r ? -1 : o ? 1 : l ? z(l, e) - z(l, t) : 0;
                    if (r === o) return he(e, t);
                    for (i = e; i = i.parentNode;) a.unshift(i);
                    for (i = t; i = i.parentNode;) s.unshift(i);
                    for (; a[n] === s[n];) n++;
                    return n ? he(a[n], s[n]) : a[n] === v ? -1 : s[n] === v ? 1 : 0
                }), R
            }, oe.matches = function (e, t) {
                return oe(e, null, null, t)
            }, oe.matchesSelector = function (e, t) {
                if ((e.ownerDocument || e) !== R && x(e), t = t.replace($, "='$1']"), d.matchesSelector && w && !S[t + " "] && (!s || !s.test(t)) && (!g || !g.test(t))) try {
                    var i = h.call(e, t);
                    if (i || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return i
                } catch (e) {}
                return 0 < oe(t, R, null, [e]).length
            }, oe.contains = function (e, t) {
                return (e.ownerDocument || e) !== R && x(e), E(e, t)
            }, oe.attr = function (e, t) {
                (e.ownerDocument || e) !== R && x(e);
                var i = T.attrHandle[t.toLowerCase()],
                    n = i && C.call(T.attrHandle, t.toLowerCase()) ? i(e, t, !w) : void 0;
                return void 0 !== n ? n : d.attributes || !w ? e.getAttribute(t) : (n = e.getAttributeNode(t)) && n.specified ? n.value : null
            }, oe.escape = function (e) {
                return (e + "").replace(te, ie)
            }, oe.error = function (e) {
                throw new Error("Syntax error, unrecognized expression: " + e)
            }, oe.uniqueSort = function (e) {
                var t, i = [],
                    n = 0,
                    r = 0;
                if (c = !d.detectDuplicates, l = !d.sortStable && e.slice(0), e.sort(M), c) {
                    for (; t = e[r++];) t === e[r] && (n = i.push(r));
                    for (; n--;) e.splice(i[n], 1)
                }
                return l = null, e
            }, o = oe.getText = function (e) {
                var t, i = "",
                    n = 0,
                    r = e.nodeType;
                if (r) {
                    if (1 === r || 9 === r || 11 === r) {
                        if ("string" == typeof e.textContent) return e.textContent;
                        for (e = e.firstChild; e; e = e.nextSibling) i += o(e)
                    } else if (3 === r || 4 === r) return e.nodeValue
                } else
                    for (; t = e[n++];) i += o(t);
                return i
            }, (T = oe.selectors = {
                cacheLength: 50,
                createPseudo: se,
                match: q,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {
                        dir: "parentNode",
                        first: !0
                    },
                    " ": {
                        dir: "parentNode"
                    },
                    "+": {
                        dir: "previousSibling",
                        first: !0
                    },
                    "~": {
                        dir: "previousSibling"
                    }
                },
                preFilter: {
                    ATTR: function (e) {
                        return e[1] = e[1].replace(J, ee), e[3] = (e[3] || e[4] || e[5] || "").replace(J, ee), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                    },
                    CHILD: function (e) {
                        return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || oe.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && oe.error(e[0]), e
                    },
                    PSEUDO: function (e) {
                        var t, i = !e[6] && e[2];
                        return q.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : i && G.test(i) && (t = p(i, !0)) && (t = i.indexOf(")", i.length - t) - i.length) && (e[0] = e[0].slice(0, t), e[2] = i.slice(0, t)), e.slice(0, 3))
                    }
                },
                filter: {
                    TAG: function (e) {
                        var t = e.replace(J, ee).toLowerCase();
                        return "*" === e ? function () {
                            return !0
                        } : function (e) {
                            return e.nodeName && e.nodeName.toLowerCase() === t
                        }
                    },
                    CLASS: function (e) {
                        var t = f[e + " "];
                        return t || (t = new RegExp("(^|" + O + ")" + e + "(" + O + "|$)")) && f(e, function (e) {
                            return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
                        })
                    },
                    ATTR: function (i, n, r) {
                        return function (e) {
                            var t = oe.attr(e, i);
                            return null == t ? "!=" === n : !n || (t += "", "=" === n ? t === r : "!=" === n ? t !== r : "^=" === n ? r && 0 === t.indexOf(r) : "*=" === n ? r && -1 < t.indexOf(r) : "$=" === n ? r && t.slice(-r.length) === r : "~=" === n ? -1 < (" " + t.replace(V, " ") + " ").indexOf(r) : "|=" === n && (t === r || t.slice(0, r.length + 1) === r + "-"))
                        }
                    },
                    CHILD: function (p, e, t, m, g) {
                        var E = "nth" !== p.slice(0, 3),
                            v = "last" !== p.slice(-4),
                            y = "of-type" === e;
                        return 1 === m && 0 === g ? function (e) {
                            return !!e.parentNode
                        } : function (e, t, i) {
                            var n, r, o, a, s, l, c = E !== v ? "nextSibling" : "previousSibling",
                                h = e.parentNode,
                                u = y && e.nodeName.toLowerCase(),
                                f = !i && !y,
                                d = !1;
                            if (h) {
                                if (E) {
                                    for (; c;) {
                                        for (a = e; a = a[c];)
                                            if (y ? a.nodeName.toLowerCase() === u : 1 === a.nodeType) return !1;
                                        l = c = "only" === p && !l && "nextSibling"
                                    }
                                    return !0
                                }
                                if (l = [v ? h.firstChild : h.lastChild], v && f) {
                                    for (d = (s = (n = (r = (o = (a = h)[_] || (a[_] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[p] || [])[0] === H && n[1]) && n[2], a = s && h.childNodes[s]; a = ++s && a && a[c] || (d = s = 0) || l.pop();)
                                        if (1 === a.nodeType && ++d && a === e) {
                                            r[p] = [H, s, d];
                                            break
                                        }
                                } else if (f && (d = s = (n = (r = (o = (a = e)[_] || (a[_] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[p] || [])[0] === H && n[1]), !1 === d)
                                    for (;
                                        (a = ++s && a && a[c] || (d = s = 0) || l.pop()) && ((y ? a.nodeName.toLowerCase() !== u : 1 !== a.nodeType) || !++d || (f && ((r = (o = a[_] || (a[_] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[p] = [H, d]), a !== e)););
                                return (d -= g) === m || d % m == 0 && 0 <= d / m
                            }
                        }
                    },
                    PSEUDO: function (e, o) {
                        var t, a = T.pseudos[e] || T.setFilters[e.toLowerCase()] || oe.error("unsupported pseudo: " + e);
                        return a[_] ? a(o) : 1 < a.length ? (t = [e, e, "", o], T.setFilters.hasOwnProperty(e.toLowerCase()) ? se(function (e, t) {
                            for (var i, n = a(e, o), r = n.length; r--;) e[i = z(e, n[r])] = !(t[i] = n[r])
                        }) : function (e) {
                            return a(e, 0, t)
                        }) : a
                    }
                },
                pseudos: {
                    not: se(function (e) {
                        var n = [],
                            r = [],
                            s = u(e.replace(N, "$1"));
                        return s[_] ? se(function (e, t, i, n) {
                            for (var r, o = s(e, null, n, []), a = e.length; a--;)(r = o[a]) && (e[a] = !(t[a] = r))
                        }) : function (e, t, i) {
                            return n[0] = e, s(n, null, i, r), n[0] = null, !r.pop()
                        }
                    }),
                    has: se(function (t) {
                        return function (e) {
                            return 0 < oe(t, e).length
                        }
                    }),
                    contains: se(function (t) {
                        return t = t.replace(J, ee),
                            function (e) {
                                return -1 < (e.textContent || e.innerText || o(e)).indexOf(t)
                            }
                    }),
                    lang: se(function (i) {
                        return W.test(i || "") || oe.error("unsupported lang: " + i), i = i.replace(J, ee).toLowerCase(),
                            function (e) {
                                var t;
                                do {
                                    if (t = w ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === i || 0 === t.indexOf(i + "-")
                                } while ((e = e.parentNode) && 1 === e.nodeType);
                                return !1
                            }
                    }),
                    target: function (e) {
                        var t = i.location && i.location.hash;
                        return t && t.slice(1) === e.id
                    },
                    root: function (e) {
                        return e === a
                    },
                    focus: function (e) {
                        return e === R.activeElement && (!R.hasFocus || R.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                    },
                    enabled: de(!1),
                    disabled: de(!0),
                    checked: function (e) {
                        var t = e.nodeName.toLowerCase();
                        return "input" === t && !!e.checked || "option" === t && !!e.selected
                    },
                    selected: function (e) {
                        return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
                    },
                    empty: function (e) {
                        for (e = e.firstChild; e; e = e.nextSibling)
                            if (e.nodeType < 6) return !1;
                        return !0
                    },
                    parent: function (e) {
                        return !T.pseudos.empty(e)
                    },
                    header: function (e) {
                        return Y.test(e.nodeName)
                    },
                    input: function (e) {
                        return X.test(e.nodeName)
                    },
                    button: function (e) {
                        var t = e.nodeName.toLowerCase();
                        return "input" === t && "button" === e.type || "button" === t
                    },
                    text: function (e) {
                        var t;
                        return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                    },
                    first: pe(function () {
                        return [0]
                    }),
                    last: pe(function (e, t) {
                        return [t - 1]
                    }),
                    eq: pe(function (e, t, i) {
                        return [i < 0 ? i + t : i]
                    }),
                    even: pe(function (e, t) {
                        for (var i = 0; i < t; i += 2) e.push(i);
                        return e
                    }),
                    odd: pe(function (e, t) {
                        for (var i = 1; i < t; i += 2) e.push(i);
                        return e
                    }),
                    lt: pe(function (e, t, i) {
                        for (var n = i < 0 ? i + t : i; 0 <= --n;) e.push(n);
                        return e
                    }),
                    gt: pe(function (e, t, i) {
                        for (var n = i < 0 ? i + t : i; ++n < t;) e.push(n);
                        return e
                    })
                }
            }).pseudos.nth = T.pseudos.eq, {
                radio: !0,
                checkbox: !0,
                file: !0,
                password: !0,
                image: !0
            }) T.pseudos[e] = ue(e);
        for (e in {
                submit: !0,
                reset: !0
            }) T.pseudos[e] = fe(e);

        function ge() {}

        function Ee(e) {
            for (var t = 0, i = e.length, n = ""; t < i; t++) n += e[t].value;
            return n
        }

        function ve(s, e, t) {
            var l = e.dir,
                c = e.next,
                h = c || l,
                u = t && "parentNode" === h,
                f = n++;
            return e.first ? function (e, t, i) {
                for (; e = e[l];)
                    if (1 === e.nodeType || u) return s(e, t, i);
                return !1
            } : function (e, t, i) {
                var n, r, o, a = [H, f];
                if (i) {
                    for (; e = e[l];)
                        if ((1 === e.nodeType || u) && s(e, t, i)) return !0
                } else
                    for (; e = e[l];)
                        if (1 === e.nodeType || u)
                            if (r = (o = e[_] || (e[_] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), c && c === e.nodeName.toLowerCase()) e = e[l] || e;
                            else {
                                if ((n = r[h]) && n[0] === H && n[1] === f) return a[2] = n[2];
                                if ((r[h] = a)[2] = s(e, t, i)) return !0
                            } return !1
            }
        }

        function ye(r) {
            return 1 < r.length ? function (e, t, i) {
                for (var n = r.length; n--;)
                    if (!r[n](e, t, i)) return !1;
                return !0
            } : r[0]
        }

        function Te(e, t, i, n, r) {
            for (var o, a = [], s = 0, l = e.length, c = null != t; s < l; s++)(o = e[s]) && (i && !i(o, n, r) || (a.push(o), c && t.push(s)));
            return a
        }

        function be(d, p, m, g, E, e) {
            return g && !g[_] && (g = be(g)), E && !E[_] && (E = be(E, e)), se(function (e, t, i, n) {
                var r, o, a, s = [],
                    l = [],
                    c = t.length,
                    h = e || function (e, t, i) {
                        for (var n = 0, r = t.length; n < r; n++) oe(e, t[n], i);
                        return i
                    }(p || "*", i.nodeType ? [i] : i, []),
                    u = !d || !e && p ? h : Te(h, s, d, i, n),
                    f = m ? E || (e ? d : c || g) ? [] : t : u;
                if (m && m(u, f, i, n), g)
                    for (r = Te(f, l), g(r, [], i, n), o = r.length; o--;)(a = r[o]) && (f[l[o]] = !(u[l[o]] = a));
                if (e) {
                    if (E || d) {
                        if (E) {
                            for (r = [], o = f.length; o--;)(a = f[o]) && r.push(u[o] = a);
                            E(null, f = [], r, n)
                        }
                        for (o = f.length; o--;)(a = f[o]) && -1 < (r = E ? z(e, a) : s[o]) && (e[r] = !(t[r] = a))
                    }
                } else f = Te(f === t ? f.splice(c, f.length) : f), E ? E(null, t, f, n) : L.apply(t, f)
            })
        }

        function xe(e) {
            for (var r, t, i, n = e.length, o = T.relative[e[0].type], a = o || T.relative[" "], s = o ? 1 : 0, l = ve(function (e) {
                    return e === r
                }, a, !0), c = ve(function (e) {
                    return -1 < z(r, e)
                }, a, !0), h = [function (e, t, i) {
                    var n = !o && (i || t !== b) || ((r = t).nodeType ? l(e, t, i) : c(e, t, i));
                    return r = null, n
                }]; s < n; s++)
                if (t = T.relative[e[s].type]) h = [ve(ye(h), t)];
                else {
                    if ((t = T.filter[e[s].type].apply(null, e[s].matches))[_]) {
                        for (i = ++s; i < n && !T.relative[e[i].type]; i++);
                        return be(1 < s && ye(h), 1 < s && Ee(e.slice(0, s - 1).concat({
                            value: " " === e[s - 2].type ? "*" : ""
                        })).replace(N, "$1"), t, s < i && xe(e.slice(s, i)), i < n && xe(e = e.slice(i)), i < n && Ee(e))
                    }
                    h.push(t)
                } return ye(h)
        }
        return ge.prototype = T.filters = T.pseudos, T.setFilters = new ge, p = oe.tokenize = function (e, t) {
            var i, n, r, o, a, s, l, c = y[e + " "];
            if (c) return t ? 0 : c.slice(0);
            for (a = e, s = [], l = T.preFilter; a;) {
                for (o in i && !(n = B.exec(a)) || (n && (a = a.slice(n[0].length) || a), s.push(r = [])), i = !1, (n = I.exec(a)) && (i = n.shift(), r.push({
                        value: i,
                        type: n[0].replace(N, " ")
                    }), a = a.slice(i.length)), T.filter) !(n = q[o].exec(a)) || l[o] && !(n = l[o](n)) || (i = n.shift(), r.push({
                    value: i,
                    type: o,
                    matches: n
                }), a = a.slice(i.length));
                if (!i) break
            }
            return t ? a.length : a ? oe.error(e) : y(e, s).slice(0)
        }, u = oe.compile = function (e, t) {
            var i, g, E, v, y, n, r = [],
                o = [],
                a = S[e + " "];
            if (!a) {
                for (t || (t = p(e)), i = t.length; i--;)(a = xe(t[i]))[_] ? r.push(a) : o.push(a);
                (a = S(e, (g = o, v = 0 < (E = r).length, y = 0 < g.length, n = function (e, t, i, n, r) {
                    var o, a, s, l = 0,
                        c = "0",
                        h = e && [],
                        u = [],
                        f = b,
                        d = e || y && T.find.TAG("*", r),
                        p = H += null == f ? 1 : Math.random() || .1,
                        m = d.length;
                    for (r && (b = t === R || t || r); c !== m && null != (o = d[c]); c++) {
                        if (y && o) {
                            for (a = 0, t || o.ownerDocument === R || (x(o), i = !w); s = g[a++];)
                                if (s(o, t || R, i)) {
                                    n.push(o);
                                    break
                                } r && (H = p)
                        }
                        v && ((o = !s && o) && l--, e && h.push(o))
                    }
                    if (l += c, v && c !== l) {
                        for (a = 0; s = E[a++];) s(h, u, t, i);
                        if (e) {
                            if (0 < l)
                                for (; c--;) h[c] || u[c] || (u[c] = A.call(n));
                            u = Te(u)
                        }
                        L.apply(n, u), r && !e && 0 < u.length && 1 < l + E.length && oe.uniqueSort(n)
                    }
                    return r && (H = p, b = f), h
                }, v ? se(n) : n))).selector = e
            }
            return a
        }, m = oe.select = function (e, t, i, n) {
            var r, o, a, s, l, c = "function" == typeof e && e,
                h = !n && p(e = c.selector || e);
            if (i = i || [], 1 === h.length) {
                if (2 < (o = h[0] = h[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && w && T.relative[o[1].type]) {
                    if (!(t = (T.find.ID(a.matches[0].replace(J, ee), t) || [])[0])) return i;
                    c && (t = t.parentNode), e = e.slice(o.shift().value.length)
                }
                for (r = q.needsContext.test(e) ? 0 : o.length; r-- && (a = o[r], !T.relative[s = a.type]);)
                    if ((l = T.find[s]) && (n = l(a.matches[0].replace(J, ee), Z.test(o[0].type) && me(t.parentNode) || t))) {
                        if (o.splice(r, 1), !(e = n.length && Ee(o))) return L.apply(i, n), i;
                        break
                    }
            }
            return (c || u(e, h))(n, t, !w, i, !t || Z.test(e) && me(t.parentNode) || t), i
        }, d.sortStable = _.split("").sort(M).join("") === _, d.detectDuplicates = !!c, x(), d.sortDetached = le(function (e) {
            return 1 & e.compareDocumentPosition(R.createElement("fieldset"))
        }), le(function (e) {
            return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
        }) || ce("type|href|height|width", function (e, t, i) {
            if (!i) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
        }), d.attributes && le(function (e) {
            return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
        }) || ce("value", function (e, t, i) {
            if (!i && "input" === e.nodeName.toLowerCase()) return e.defaultValue
        }), le(function (e) {
            return null == e.getAttribute("disabled")
        }) || ce(k, function (e, t, i) {
            var n;
            if (!i) return !0 === e[t] ? t.toLowerCase() : (n = e.getAttributeNode(t)) && n.specified ? n.value : null
        }), oe
    }(R);
    _.find = p, _.expr = p.selectors, _.expr[":"] = _.expr.pseudos, _.uniqueSort = _.unique = p.uniqueSort, _.text = p.getText, _.isXMLDoc = p.isXML, _.contains = p.contains, _.escapeSelector = p.escape;
    var x = function (e, t, i) {
            for (var n = [], r = void 0 !== i;
                (e = e[t]) && 9 !== e.nodeType;)
                if (1 === e.nodeType) {
                    if (r && _(e).is(i)) break;
                    n.push(e)
                } return n
        },
        H = function (e, t) {
            for (var i = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && i.push(e);
            return i
        },
        S = _.expr.match.needsContext;

    function M(e, t) {
        return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
    }
    var C = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

    function A(e, i, n) {
        return v(i) ? _.grep(e, function (e, t) {
            return !!i.call(e, t, e) !== n
        }) : i.nodeType ? _.grep(e, function (e) {
            return e === i !== n
        }) : "string" != typeof i ? _.grep(e, function (e) {
            return -1 < r.call(i, e) !== n
        }) : _.filter(i, e, n)
    }
    _.filter = function (e, t, i) {
        var n = t[0];
        return i && (e = ":not(" + e + ")"), 1 === t.length && 1 === n.nodeType ? _.find.matchesSelector(n, e) ? [n] : [] : _.find.matches(e, _.grep(t, function (e) {
            return 1 === e.nodeType
        }))
    }, _.fn.extend({
        find: function (e) {
            var t, i, n = this.length,
                r = this;
            if ("string" != typeof e) return this.pushStack(_(e).filter(function () {
                for (t = 0; t < n; t++)
                    if (_.contains(r[t], this)) return !0
            }));
            for (i = this.pushStack([]), t = 0; t < n; t++) _.find(e, r[t], i);
            return 1 < n ? _.uniqueSort(i) : i
        },
        filter: function (e) {
            return this.pushStack(A(this, e || [], !1))
        },
        not: function (e) {
            return this.pushStack(A(this, e || [], !0))
        },
        is: function (e) {
            return !!A(this, "string" == typeof e && S.test(e) ? _(e) : e || [], !1).length
        }
    });
    var P, L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (_.fn.init = function (e, t, i) {
        var n, r;
        if (!e) return this;
        if (i = i || P, "string" != typeof e) return e.nodeType ? (this[0] = e, this.length = 1, this) : v(e) ? void 0 !== i.ready ? i.ready(e) : e(_) : _.makeArray(e, this);
        if (!(n = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : L.exec(e)) || !n[1] && t) return !t || t.jquery ? (t || i).find(e) : this.constructor(t).find(e);
        if (n[1]) {
            if (t = t instanceof _ ? t[0] : t, _.merge(this, _.parseHTML(n[1], t && t.nodeType ? t.ownerDocument || t : w, !0)), C.test(n[1]) && _.isPlainObject(t))
                for (n in t) v(this[n]) ? this[n](t[n]) : this.attr(n, t[n]);
            return this
        }
        return (r = w.getElementById(n[2])) && (this[0] = r, this.length = 1), this
    }).prototype = _.fn, P = _(w);
    var D = /^(?:parents|prev(?:Until|All))/,
        z = {
            children: !0,
            contents: !0,
            next: !0,
            prev: !0
        };

    function k(e, t) {
        for (;
            (e = e[t]) && 1 !== e.nodeType;);
        return e
    }
    _.fn.extend({
        has: function (e) {
            var t = _(e, this),
                i = t.length;
            return this.filter(function () {
                for (var e = 0; e < i; e++)
                    if (_.contains(this, t[e])) return !0
            })
        },
        closest: function (e, t) {
            var i, n = 0,
                r = this.length,
                o = [],
                a = "string" != typeof e && _(e);
            if (!S.test(e))
                for (; n < r; n++)
                    for (i = this[n]; i && i !== t; i = i.parentNode)
                        if (i.nodeType < 11 && (a ? -1 < a.index(i) : 1 === i.nodeType && _.find.matchesSelector(i, e))) {
                            o.push(i);
                            break
                        } return this.pushStack(1 < o.length ? _.uniqueSort(o) : o)
        },
        index: function (e) {
            return e ? "string" == typeof e ? r.call(_(e), this[0]) : r.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function (e, t) {
            return this.pushStack(_.uniqueSort(_.merge(this.get(), _(e, t))))
        },
        addBack: function (e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
        }
    }), _.each({
        parent: function (e) {
            var t = e.parentNode;
            return t && 11 !== t.nodeType ? t : null
        },
        parents: function (e) {
            return x(e, "parentNode")
        },
        parentsUntil: function (e, t, i) {
            return x(e, "parentNode", i)
        },
        next: function (e) {
            return k(e, "nextSibling")
        },
        prev: function (e) {
            return k(e, "previousSibling")
        },
        nextAll: function (e) {
            return x(e, "nextSibling")
        },
        prevAll: function (e) {
            return x(e, "previousSibling")
        },
        nextUntil: function (e, t, i) {
            return x(e, "nextSibling", i)
        },
        prevUntil: function (e, t, i) {
            return x(e, "previousSibling", i)
        },
        siblings: function (e) {
            return H((e.parentNode || {}).firstChild, e)
        },
        children: function (e) {
            return H(e.firstChild)
        },
        contents: function (e) {
            return M(e, "iframe") ? e.contentDocument : (M(e, "template") && (e = e.content || e), _.merge([], e.childNodes))
        }
    }, function (n, r) {
        _.fn[n] = function (e, t) {
            var i = _.map(this, r, e);
            return "Until" !== n.slice(-5) && (t = e), t && "string" == typeof t && (i = _.filter(t, i)), 1 < this.length && (z[n] || _.uniqueSort(i), D.test(n) && i.reverse()), this.pushStack(i)
        }
    });
    var O = /[^\x20\t\r\n\f]+/g;

    function F(e) {
        return e
    }

    function j(e) {
        throw e
    }

    function U(e, t, i, n) {
        var r;
        try {
            e && v(r = e.promise) ? r.call(e).done(t).fail(i) : e && v(r = e.then) ? r.call(e, t, i) : t.apply(void 0, [e].slice(n))
        } catch (e) {
            i.apply(void 0, [e])
        }
    }
    _.Callbacks = function (n) {
        var e, i;
        n = "string" == typeof n ? (e = n, i = {}, _.each(e.match(O) || [], function (e, t) {
            i[t] = !0
        }), i) : _.extend({}, n);
        var r, t, o, a, s = [],
            l = [],
            c = -1,
            h = function () {
                for (a = a || n.once, o = r = !0; l.length; c = -1)
                    for (t = l.shift(); ++c < s.length;) !1 === s[c].apply(t[0], t[1]) && n.stopOnFalse && (c = s.length, t = !1);
                n.memory || (t = !1), r = !1, a && (s = t ? [] : "")
            },
            u = {
                add: function () {
                    return s && (t && !r && (c = s.length - 1, l.push(t)), function i(e) {
                        _.each(e, function (e, t) {
                            v(t) ? n.unique && u.has(t) || s.push(t) : t && t.length && "string" !== b(t) && i(t)
                        })
                    }(arguments), t && !r && h()), this
                },
                remove: function () {
                    return _.each(arguments, function (e, t) {
                        for (var i; - 1 < (i = _.inArray(t, s, i));) s.splice(i, 1), i <= c && c--
                    }), this
                },
                has: function (e) {
                    return e ? -1 < _.inArray(e, s) : 0 < s.length
                },
                empty: function () {
                    return s && (s = []), this
                },
                disable: function () {
                    return a = l = [], s = t = "", this
                },
                disabled: function () {
                    return !s
                },
                lock: function () {
                    return a = l = [], t || r || (s = t = ""), this
                },
                locked: function () {
                    return !!a
                },
                fireWith: function (e, t) {
                    return a || (t = [e, (t = t || []).slice ? t.slice() : t], l.push(t), r || h()), this
                },
                fire: function () {
                    return u.fireWith(this, arguments), this
                },
                fired: function () {
                    return !!o
                }
            };
        return u
    }, _.extend({
        Deferred: function (e) {
            var o = [
                    ["notify", "progress", _.Callbacks("memory"), _.Callbacks("memory"), 2],
                    ["resolve", "done", _.Callbacks("once memory"), _.Callbacks("once memory"), 0, "resolved"],
                    ["reject", "fail", _.Callbacks("once memory"), _.Callbacks("once memory"), 1, "rejected"]
                ],
                r = "pending",
                a = {
                    state: function () {
                        return r
                    },
                    always: function () {
                        return s.done(arguments).fail(arguments), this
                    },
                    catch: function (e) {
                        return a.then(null, e)
                    },
                    pipe: function () {
                        var r = arguments;
                        return _.Deferred(function (n) {
                            _.each(o, function (e, t) {
                                var i = v(r[t[4]]) && r[t[4]];
                                s[t[1]](function () {
                                    var e = i && i.apply(this, arguments);
                                    e && v(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[t[0] + "With"](this, i ? [e] : arguments)
                                })
                            }), r = null
                        }).promise()
                    },
                    then: function (t, i, n) {
                        var l = 0;

                        function c(r, o, a, s) {
                            return function () {
                                var i = this,
                                    n = arguments,
                                    e = function () {
                                        var e, t;
                                        if (!(r < l)) {
                                            if ((e = a.apply(i, n)) === o.promise()) throw new TypeError("Thenable self-resolution");
                                            t = e && ("object" == typeof e || "function" == typeof e) && e.then, v(t) ? s ? t.call(e, c(l, o, F, s), c(l, o, j, s)) : (l++, t.call(e, c(l, o, F, s), c(l, o, j, s), c(l, o, F, o.notifyWith))) : (a !== F && (i = void 0, n = [e]), (s || o.resolveWith)(i, n))
                                        }
                                    },
                                    t = s ? e : function () {
                                        try {
                                            e()
                                        } catch (e) {
                                            _.Deferred.exceptionHook && _.Deferred.exceptionHook(e, t.stackTrace), l <= r + 1 && (a !== j && (i = void 0, n = [e]), o.rejectWith(i, n))
                                        }
                                    };
                                r ? t() : (_.Deferred.getStackHook && (t.stackTrace = _.Deferred.getStackHook()), R.setTimeout(t))
                            }
                        }
                        return _.Deferred(function (e) {
                            o[0][3].add(c(0, e, v(n) ? n : F, e.notifyWith)), o[1][3].add(c(0, e, v(t) ? t : F)), o[2][3].add(c(0, e, v(i) ? i : j))
                        }).promise()
                    },
                    promise: function (e) {
                        return null != e ? _.extend(e, a) : a
                    }
                },
                s = {};
            return _.each(o, function (e, t) {
                var i = t[2],
                    n = t[5];
                a[t[1]] = i.add, n && i.add(function () {
                    r = n
                }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), i.add(t[3].fire), s[t[0]] = function () {
                    return s[t[0] + "With"](this === s ? void 0 : this, arguments), this
                }, s[t[0] + "With"] = i.fireWith
            }), a.promise(s), e && e.call(s, s), s
        },
        when: function (e) {
            var i = arguments.length,
                t = i,
                n = Array(t),
                r = s.call(arguments),
                o = _.Deferred(),
                a = function (t) {
                    return function (e) {
                        n[t] = this, r[t] = 1 < arguments.length ? s.call(arguments) : e, --i || o.resolveWith(n, r)
                    }
                };
            if (i <= 1 && (U(e, o.done(a(t)).resolve, o.reject, !i), "pending" === o.state() || v(r[t] && r[t].then))) return o.then();
            for (; t--;) U(r[t], a(t), o.reject);
            return o.promise()
        }
    });
    var V = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    _.Deferred.exceptionHook = function (e, t) {
        R.console && R.console.warn && e && V.test(e.name) && R.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
    }, _.readyException = function (e) {
        R.setTimeout(function () {
            throw e
        })
    };
    var N = _.Deferred();

    function B() {
        w.removeEventListener("DOMContentLoaded", B), R.removeEventListener("load", B), _.ready()
    }
    _.fn.ready = function (e) {
        return N.then(e).catch(function (e) {
            _.readyException(e)
        }), this
    }, _.extend({
        isReady: !1,
        readyWait: 1,
        ready: function (e) {
            (!0 === e ? --_.readyWait : _.isReady) || (_.isReady = !0) !== e && 0 < --_.readyWait || N.resolveWith(w, [_])
        }
    }), _.ready.then = N.then, "complete" === w.readyState || "loading" !== w.readyState && !w.documentElement.doScroll ? R.setTimeout(_.ready) : (w.addEventListener("DOMContentLoaded", B), R.addEventListener("load", B));
    var I = function (e, t, i, n, r, o, a) {
            var s = 0,
                l = e.length,
                c = null == i;
            if ("object" === b(i))
                for (s in r = !0, i) I(e, t, s, i[s], !0, o, a);
            else if (void 0 !== n && (r = !0, v(n) || (a = !0), c && (t = a ? (t.call(e, n), null) : (c = t, function (e, t, i) {
                    return c.call(_(e), i)
                })), t))
                for (; s < l; s++) t(e[s], i, a ? n : n.call(e[s], s, t(e[s], i)));
            return r ? e : c ? t.call(e) : l ? t(e[0], i) : o
        },
        $ = /^-ms-/,
        G = /-([a-z])/g;

    function W(e, t) {
        return t.toUpperCase()
    }

    function q(e) {
        return e.replace($, "ms-").replace(G, W)
    }
    var X = function (e) {
        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
    };

    function Y() {
        this.expando = _.expando + Y.uid++
    }
    Y.uid = 1, Y.prototype = {
        cache: function (e) {
            var t = e[this.expando];
            return t || (t = {}, X(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                value: t,
                configurable: !0
            }))), t
        },
        set: function (e, t, i) {
            var n, r = this.cache(e);
            if ("string" == typeof t) r[q(t)] = i;
            else
                for (n in t) r[q(n)] = t[n];
            return r
        },
        get: function (e, t) {
            return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][q(t)]
        },
        access: function (e, t, i) {
            return void 0 === t || t && "string" == typeof t && void 0 === i ? this.get(e, t) : (this.set(e, t, i), void 0 !== i ? i : t)
        },
        remove: function (e, t) {
            var i, n = e[this.expando];
            if (void 0 !== n) {
                if (void 0 !== t) {
                    i = (t = Array.isArray(t) ? t.map(q) : (t = q(t)) in n ? [t] : t.match(O) || []).length;
                    for (; i--;) delete n[t[i]]
                }(void 0 === t || _.isEmptyObject(n)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
            }
        },
        hasData: function (e) {
            var t = e[this.expando];
            return void 0 !== t && !_.isEmptyObject(t)
        }
    };
    var K = new Y,
        Q = new Y,
        Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        J = /[A-Z]/g;

    function ee(e, t, i) {
        var n, r;
        if (void 0 === i && 1 === e.nodeType)
            if (n = "data-" + t.replace(J, "-$&").toLowerCase(), "string" == typeof (i = e.getAttribute(n))) {
                try {
                    i = "true" === (r = i) || "false" !== r && ("null" === r ? null : r === +r + "" ? +r : Z.test(r) ? JSON.parse(r) : r)
                } catch (e) {}
                Q.set(e, t, i)
            } else i = void 0;
        return i
    }
    _.extend({
        hasData: function (e) {
            return Q.hasData(e) || K.hasData(e)
        },
        data: function (e, t, i) {
            return Q.access(e, t, i)
        },
        removeData: function (e, t) {
            Q.remove(e, t)
        },
        _data: function (e, t, i) {
            return K.access(e, t, i)
        },
        _removeData: function (e, t) {
            K.remove(e, t)
        }
    }), _.fn.extend({
        data: function (i, e) {
            var t, n, r, o = this[0],
                a = o && o.attributes;
            if (void 0 !== i) return "object" == typeof i ? this.each(function () {
                Q.set(this, i)
            }) : I(this, function (e) {
                var t;
                if (o && void 0 === e) return void 0 !== (t = Q.get(o, i)) ? t : void 0 !== (t = ee(o, i)) ? t : void 0;
                this.each(function () {
                    Q.set(this, i, e)
                })
            }, null, e, 1 < arguments.length, null, !0);
            if (this.length && (r = Q.get(o), 1 === o.nodeType && !K.get(o, "hasDataAttrs"))) {
                for (t = a.length; t--;) a[t] && 0 === (n = a[t].name).indexOf("data-") && (n = q(n.slice(5)), ee(o, n, r[n]));
                K.set(o, "hasDataAttrs", !0)
            }
            return r
        },
        removeData: function (e) {
            return this.each(function () {
                Q.remove(this, e)
            })
        }
    }), _.extend({
        queue: function (e, t, i) {
            var n;
            if (e) return t = (t || "fx") + "queue", n = K.get(e, t), i && (!n || Array.isArray(i) ? n = K.access(e, t, _.makeArray(i)) : n.push(i)), n || []
        },
        dequeue: function (e, t) {
            t = t || "fx";
            var i = _.queue(e, t),
                n = i.length,
                r = i.shift(),
                o = _._queueHooks(e, t);
            "inprogress" === r && (r = i.shift(), n--), r && ("fx" === t && i.unshift("inprogress"), delete o.stop, r.call(e, function () {
                _.dequeue(e, t)
            }, o)), !n && o && o.empty.fire()
        },
        _queueHooks: function (e, t) {
            var i = t + "queueHooks";
            return K.get(e, i) || K.access(e, i, {
                empty: _.Callbacks("once memory").add(function () {
                    K.remove(e, [t + "queue", i])
                })
            })
        }
    }), _.fn.extend({
        queue: function (t, i) {
            var e = 2;
            return "string" != typeof t && (i = t, t = "fx", e--), arguments.length < e ? _.queue(this[0], t) : void 0 === i ? this : this.each(function () {
                var e = _.queue(this, t, i);
                _._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && _.dequeue(this, t)
            })
        },
        dequeue: function (e) {
            return this.each(function () {
                _.dequeue(this, e)
            })
        },
        clearQueue: function (e) {
            return this.queue(e || "fx", [])
        },
        promise: function (e, t) {
            var i, n = 1,
                r = _.Deferred(),
                o = this,
                a = this.length,
                s = function () {
                    --n || r.resolveWith(o, [o])
                };
            for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;)(i = K.get(o[a], e + "queueHooks")) && i.empty && (n++, i.empty.add(s));
            return s(), r.promise(t)
        }
    });
    var te = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        ie = new RegExp("^(?:([+-])=|)(" + te + ")([a-z%]*)$", "i"),
        ne = ["Top", "Right", "Bottom", "Left"],
        re = function (e, t) {
            return "none" === (e = t || e).style.display || "" === e.style.display && _.contains(e.ownerDocument, e) && "none" === _.css(e, "display")
        },
        oe = function (e, t, i, n) {
            var r, o, a = {};
            for (o in t) a[o] = e.style[o], e.style[o] = t[o];
            for (o in r = i.apply(e, n || []), t) e.style[o] = a[o];
            return r
        };

    function ae(e, t, i, n) {
        var r, o, a = 20,
            s = n ? function () {
                return n.cur()
            } : function () {
                return _.css(e, t, "")
            },
            l = s(),
            c = i && i[3] || (_.cssNumber[t] ? "" : "px"),
            h = (_.cssNumber[t] || "px" !== c && +l) && ie.exec(_.css(e, t));
        if (h && h[3] !== c) {
            for (l /= 2, c = c || h[3], h = +l || 1; a--;) _.style(e, t, h + c), (1 - o) * (1 - (o = s() / l || .5)) <= 0 && (a = 0), h /= o;
            h *= 2, _.style(e, t, h + c), i = i || []
        }
        return i && (h = +h || +l || 0, r = i[1] ? h + (i[1] + 1) * i[2] : +i[2], n && (n.unit = c, n.start = h, n.end = r)), r
    }
    var se = {};

    function le(e, t) {
        for (var i, n, r, o, a, s, l, c = [], h = 0, u = e.length; h < u; h++)(n = e[h]).style && (i = n.style.display, t ? ("none" === i && (c[h] = K.get(n, "display") || null, c[h] || (n.style.display = "")), "" === n.style.display && re(n) && (c[h] = (l = a = o = void 0, a = (r = n).ownerDocument, s = r.nodeName, (l = se[s]) || (o = a.body.appendChild(a.createElement(s)), l = _.css(o, "display"), o.parentNode.removeChild(o), "none" === l && (l = "block"), se[s] = l)))) : "none" !== i && (c[h] = "none", K.set(n, "display", i)));
        for (h = 0; h < u; h++) null != c[h] && (e[h].style.display = c[h]);
        return e
    }
    _.fn.extend({
        show: function () {
            return le(this, !0)
        },
        hide: function () {
            return le(this)
        },
        toggle: function (e) {
            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
                re(this) ? _(this).show() : _(this).hide()
            })
        }
    });
    var ce = /^(?:checkbox|radio)$/i,
        he = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
        ue = /^$|^module$|\/(?:java|ecma)script/i,
        fe = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };

    function de(e, t) {
        var i;
        return i = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && M(e, t) ? _.merge([e], i) : i
    }

    function pe(e, t) {
        for (var i = 0, n = e.length; i < n; i++) K.set(e[i], "globalEval", !t || K.get(t[i], "globalEval"))
    }
    fe.optgroup = fe.option, fe.tbody = fe.tfoot = fe.colgroup = fe.caption = fe.thead, fe.th = fe.td;
    var me, ge, Ee = /<|&#?\w+;/;

    function ve(e, t, i, n, r) {
        for (var o, a, s, l, c, h, u = t.createDocumentFragment(), f = [], d = 0, p = e.length; d < p; d++)
            if ((o = e[d]) || 0 === o)
                if ("object" === b(o)) _.merge(f, o.nodeType ? [o] : o);
                else if (Ee.test(o)) {
            for (a = a || u.appendChild(t.createElement("div")), s = (he.exec(o) || ["", ""])[1].toLowerCase(), l = fe[s] || fe._default, a.innerHTML = l[1] + _.htmlPrefilter(o) + l[2], h = l[0]; h--;) a = a.lastChild;
            _.merge(f, a.childNodes), (a = u.firstChild).textContent = ""
        } else f.push(t.createTextNode(o));
        for (u.textContent = "", d = 0; o = f[d++];)
            if (n && -1 < _.inArray(o, n)) r && r.push(o);
            else if (c = _.contains(o.ownerDocument, o), a = de(u.appendChild(o), "script"), c && pe(a), i)
            for (h = 0; o = a[h++];) ue.test(o.type || "") && i.push(o);
        return u
    }
    me = w.createDocumentFragment().appendChild(w.createElement("div")), (ge = w.createElement("input")).setAttribute("type", "radio"), ge.setAttribute("checked", "checked"), ge.setAttribute("name", "t"), me.appendChild(ge), E.checkClone = me.cloneNode(!0).cloneNode(!0).lastChild.checked, me.innerHTML = "<textarea>x</textarea>", E.noCloneChecked = !!me.cloneNode(!0).lastChild.defaultValue;
    var ye = w.documentElement,
        Te = /^key/,
        be = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        xe = /^([^.]*)(?:\.(.+)|)/;

    function Re() {
        return !0
    }

    function we() {
        return !1
    }

    function _e() {
        try {
            return w.activeElement
        } catch (e) {}
    }

    function He(e, t, i, n, r, o) {
        var a, s;
        if ("object" == typeof t) {
            for (s in "string" != typeof i && (n = n || i, i = void 0), t) He(e, s, i, n, t[s], o);
            return e
        }
        if (null == n && null == r ? (r = i, n = i = void 0) : null == r && ("string" == typeof i ? (r = n, n = void 0) : (r = n, n = i, i = void 0)), !1 === r) r = we;
        else if (!r) return e;
        return 1 === o && (a = r, (r = function (e) {
            return _().off(e), a.apply(this, arguments)
        }).guid = a.guid || (a.guid = _.guid++)), e.each(function () {
            _.event.add(this, t, r, n, i)
        })
    }
    _.event = {
        global: {},
        add: function (t, e, i, n, r) {
            var o, a, s, l, c, h, u, f, d, p, m, g = K.get(t);
            if (g)
                for (i.handler && (i = (o = i).handler, r = o.selector), r && _.find.matchesSelector(ye, r), i.guid || (i.guid = _.guid++), (l = g.events) || (l = g.events = {}), (a = g.handle) || (a = g.handle = function (e) {
                        return void 0 !== _ && _.event.triggered !== e.type ? _.event.dispatch.apply(t, arguments) : void 0
                    }), c = (e = (e || "").match(O) || [""]).length; c--;) d = m = (s = xe.exec(e[c]) || [])[1], p = (s[2] || "").split(".").sort(), d && (u = _.event.special[d] || {}, d = (r ? u.delegateType : u.bindType) || d, u = _.event.special[d] || {}, h = _.extend({
                    type: d,
                    origType: m,
                    data: n,
                    handler: i,
                    guid: i.guid,
                    selector: r,
                    needsContext: r && _.expr.match.needsContext.test(r),
                    namespace: p.join(".")
                }, o), (f = l[d]) || ((f = l[d] = []).delegateCount = 0, u.setup && !1 !== u.setup.call(t, n, p, a) || t.addEventListener && t.addEventListener(d, a)), u.add && (u.add.call(t, h), h.handler.guid || (h.handler.guid = i.guid)), r ? f.splice(f.delegateCount++, 0, h) : f.push(h), _.event.global[d] = !0)
        },
        remove: function (e, t, i, n, r) {
            var o, a, s, l, c, h, u, f, d, p, m, g = K.hasData(e) && K.get(e);
            if (g && (l = g.events)) {
                for (c = (t = (t || "").match(O) || [""]).length; c--;)
                    if (d = m = (s = xe.exec(t[c]) || [])[1], p = (s[2] || "").split(".").sort(), d) {
                        for (u = _.event.special[d] || {}, f = l[d = (n ? u.delegateType : u.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = f.length; o--;) h = f[o], !r && m !== h.origType || i && i.guid !== h.guid || s && !s.test(h.namespace) || n && n !== h.selector && ("**" !== n || !h.selector) || (f.splice(o, 1), h.selector && f.delegateCount--, u.remove && u.remove.call(e, h));
                        a && !f.length && (u.teardown && !1 !== u.teardown.call(e, p, g.handle) || _.removeEvent(e, d, g.handle), delete l[d])
                    } else
                        for (d in l) _.event.remove(e, d + t[c], i, n, !0);
                _.isEmptyObject(l) && K.remove(e, "handle events")
            }
        },
        dispatch: function (e) {
            var t, i, n, r, o, a, s = _.event.fix(e),
                l = new Array(arguments.length),
                c = (K.get(this, "events") || {})[s.type] || [],
                h = _.event.special[s.type] || {};
            for (l[0] = s, t = 1; t < arguments.length; t++) l[t] = arguments[t];
            if (s.delegateTarget = this, !h.preDispatch || !1 !== h.preDispatch.call(this, s)) {
                for (a = _.event.handlers.call(this, s, c), t = 0;
                    (r = a[t++]) && !s.isPropagationStopped();)
                    for (s.currentTarget = r.elem, i = 0;
                        (o = r.handlers[i++]) && !s.isImmediatePropagationStopped();) s.rnamespace && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, void 0 !== (n = ((_.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, l)) && !1 === (s.result = n) && (s.preventDefault(), s.stopPropagation()));
                return h.postDispatch && h.postDispatch.call(this, s), s.result
            }
        },
        handlers: function (e, t) {
            var i, n, r, o, a, s = [],
                l = t.delegateCount,
                c = e.target;
            if (l && c.nodeType && !("click" === e.type && 1 <= e.button))
                for (; c !== this; c = c.parentNode || this)
                    if (1 === c.nodeType && ("click" !== e.type || !0 !== c.disabled)) {
                        for (o = [], a = {}, i = 0; i < l; i++) void 0 === a[r = (n = t[i]).selector + " "] && (a[r] = n.needsContext ? -1 < _(r, this).index(c) : _.find(r, this, null, [c]).length), a[r] && o.push(n);
                        o.length && s.push({
                            elem: c,
                            handlers: o
                        })
                    } return c = this, l < t.length && s.push({
                elem: c,
                handlers: t.slice(l)
            }), s
        },
        addProp: function (t, e) {
            Object.defineProperty(_.Event.prototype, t, {
                enumerable: !0,
                configurable: !0,
                get: v(e) ? function () {
                    if (this.originalEvent) return e(this.originalEvent)
                } : function () {
                    if (this.originalEvent) return this.originalEvent[t]
                },
                set: function (e) {
                    Object.defineProperty(this, t, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: e
                    })
                }
            })
        },
        fix: function (e) {
            return e[_.expando] ? e : new _.Event(e)
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function () {
                    if (this !== _e() && this.focus) return this.focus(), !1
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function () {
                    if (this === _e() && this.blur) return this.blur(), !1
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function () {
                    if ("checkbox" === this.type && this.click && M(this, "input")) return this.click(), !1
                },
                _default: function (e) {
                    return M(e.target, "a")
                }
            },
            beforeunload: {
                postDispatch: function (e) {
                    void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                }
            }
        }
    }, _.removeEvent = function (e, t, i) {
        e.removeEventListener && e.removeEventListener(t, i)
    }, _.Event = function (e, t) {
        if (!(this instanceof _.Event)) return new _.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Re : we, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && _.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[_.expando] = !0
    }, _.Event.prototype = {
        constructor: _.Event,
        isDefaultPrevented: we,
        isPropagationStopped: we,
        isImmediatePropagationStopped: we,
        isSimulated: !1,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = Re, e && !this.isSimulated && e.preventDefault()
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = Re, e && !this.isSimulated && e.stopPropagation()
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = Re, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
        }
    }, _.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function (e) {
            var t = e.button;
            return null == e.which && Te.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && be.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which
        }
    }, _.event.addProp), _.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (e, r) {
        _.event.special[e] = {
            delegateType: r,
            bindType: r,
            handle: function (e) {
                var t, i = e.relatedTarget,
                    n = e.handleObj;
                return i && (i === this || _.contains(this, i)) || (e.type = n.origType, t = n.handler.apply(this, arguments), e.type = r), t
            }
        }
    }), _.fn.extend({
        on: function (e, t, i, n) {
            return He(this, e, t, i, n)
        },
        one: function (e, t, i, n) {
            return He(this, e, t, i, n, 1)
        },
        off: function (e, t, i) {
            var n, r;
            if (e && e.preventDefault && e.handleObj) return n = e.handleObj, _(e.delegateTarget).off(n.namespace ? n.origType + "." + n.namespace : n.origType, n.selector, n.handler), this;
            if ("object" != typeof e) return !1 !== t && "function" != typeof t || (i = t, t = void 0), !1 === i && (i = we), this.each(function () {
                _.event.remove(this, e, i, t)
            });
            for (r in e) this.off(r, t, e[r]);
            return this
        }
    });
    var Se = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
        Me = /<script|<style|<link/i,
        Ce = /checked\s*(?:[^=]|=\s*.checked.)/i,
        Ae = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    function Pe(e, t) {
        return M(e, "table") && M(11 !== t.nodeType ? t : t.firstChild, "tr") && _(e).children("tbody")[0] || e
    }

    function Le(e) {
        return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
    }

    function De(e) {
        return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
    }

    function ze(e, t) {
        var i, n, r, o, a, s, l, c;
        if (1 === t.nodeType) {
            if (K.hasData(e) && (o = K.access(e), a = K.set(t, o), c = o.events))
                for (r in delete a.handle, a.events = {}, c)
                    for (i = 0, n = c[r].length; i < n; i++) _.event.add(t, r, c[r][i]);
            Q.hasData(e) && (s = Q.access(e), l = _.extend({}, s), Q.set(t, l))
        }
    }

    function ke(i, n, r, o) {
        n = m.apply([], n);
        var e, t, a, s, l, c, h = 0,
            u = i.length,
            f = u - 1,
            d = n[0],
            p = v(d);
        if (p || 1 < u && "string" == typeof d && !E.checkClone && Ce.test(d)) return i.each(function (e) {
            var t = i.eq(e);
            p && (n[0] = d.call(this, e, t.html())), ke(t, n, r, o)
        });
        if (u && (t = (e = ve(n, i[0].ownerDocument, !1, i, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
            for (s = (a = _.map(de(e, "script"), Le)).length; h < u; h++) l = e, h !== f && (l = _.clone(l, !0, !0), s && _.merge(a, de(l, "script"))), r.call(i[h], l, h);
            if (s)
                for (c = a[a.length - 1].ownerDocument, _.map(a, De), h = 0; h < s; h++) l = a[h], ue.test(l.type || "") && !K.access(l, "globalEval") && _.contains(c, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? _._evalUrl && _._evalUrl(l.src) : T(l.textContent.replace(Ae, ""), c, l))
        }
        return i
    }

    function Oe(e, t, i) {
        for (var n, r = t ? _.filter(t, e) : e, o = 0; null != (n = r[o]); o++) i || 1 !== n.nodeType || _.cleanData(de(n)), n.parentNode && (i && _.contains(n.ownerDocument, n) && pe(de(n, "script")), n.parentNode.removeChild(n));
        return e
    }
    _.extend({
        htmlPrefilter: function (e) {
            return e.replace(Se, "<$1></$2>")
        },
        clone: function (e, t, i) {
            var n, r, o, a, s, l, c, h = e.cloneNode(!0),
                u = _.contains(e.ownerDocument, e);
            if (!(E.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || _.isXMLDoc(e)))
                for (a = de(h), n = 0, r = (o = de(e)).length; n < r; n++) s = o[n], l = a[n], void 0, "input" === (c = l.nodeName.toLowerCase()) && ce.test(s.type) ? l.checked = s.checked : "input" !== c && "textarea" !== c || (l.defaultValue = s.defaultValue);
            if (t)
                if (i)
                    for (o = o || de(e), a = a || de(h), n = 0, r = o.length; n < r; n++) ze(o[n], a[n]);
                else ze(e, h);
            return 0 < (a = de(h, "script")).length && pe(a, !u && de(e, "script")), h
        },
        cleanData: function (e) {
            for (var t, i, n, r = _.event.special, o = 0; void 0 !== (i = e[o]); o++)
                if (X(i)) {
                    if (t = i[K.expando]) {
                        if (t.events)
                            for (n in t.events) r[n] ? _.event.remove(i, n) : _.removeEvent(i, n, t.handle);
                        i[K.expando] = void 0
                    }
                    i[Q.expando] && (i[Q.expando] = void 0)
                }
        }
    }), _.fn.extend({
        detach: function (e) {
            return Oe(this, e, !0)
        },
        remove: function (e) {
            return Oe(this, e)
        },
        text: function (e) {
            return I(this, function (e) {
                return void 0 === e ? _.text(this) : this.empty().each(function () {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                })
            }, null, e, arguments.length)
        },
        append: function () {
            return ke(this, arguments, function (e) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Pe(this, e).appendChild(e)
            })
        },
        prepend: function () {
            return ke(this, arguments, function (e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = Pe(this, e);
                    t.insertBefore(e, t.firstChild)
                }
            })
        },
        before: function () {
            return ke(this, arguments, function (e) {
                this.parentNode && this.parentNode.insertBefore(e, this)
            })
        },
        after: function () {
            return ke(this, arguments, function (e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
            })
        },
        empty: function () {
            for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (_.cleanData(de(e, !1)), e.textContent = "");
            return this
        },
        clone: function (e, t) {
            return e = null != e && e, t = null == t ? e : t, this.map(function () {
                return _.clone(this, e, t)
            })
        },
        html: function (e) {
            return I(this, function (e) {
                var t = this[0] || {},
                    i = 0,
                    n = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e && !Me.test(e) && !fe[(he.exec(e) || ["", ""])[1].toLowerCase()]) {
                    e = _.htmlPrefilter(e);
                    try {
                        for (; i < n; i++) 1 === (t = this[i] || {}).nodeType && (_.cleanData(de(t, !1)), t.innerHTML = e);
                        t = 0
                    } catch (e) {}
                }
                t && this.empty().append(e)
            }, null, e, arguments.length)
        },
        replaceWith: function () {
            var i = [];
            return ke(this, arguments, function (e) {
                var t = this.parentNode;
                _.inArray(this, i) < 0 && (_.cleanData(de(this)), t && t.replaceChild(e, this))
            }, i)
        }
    }), _.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (e, a) {
        _.fn[e] = function (e) {
            for (var t, i = [], n = _(e), r = n.length - 1, o = 0; o <= r; o++) t = o === r ? this : this.clone(!0), _(n[o])[a](t), l.apply(i, t.get());
            return this.pushStack(i)
        }
    });
    var Fe = new RegExp("^(" + te + ")(?!px)[a-z%]+$", "i"),
        je = function (e) {
            var t = e.ownerDocument.defaultView;
            return t && t.opener || (t = R), t.getComputedStyle(e)
        },
        Ue = new RegExp(ne.join("|"), "i");

    function Ve(e, t, i) {
        var n, r, o, a, s = e.style;
        return (i = i || je(e)) && ("" !== (a = i.getPropertyValue(t) || i[t]) || _.contains(e.ownerDocument, e) || (a = _.style(e, t)), !E.pixelBoxStyles() && Fe.test(a) && Ue.test(t) && (n = s.width, r = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = i.width, s.width = n, s.minWidth = r, s.maxWidth = o)), void 0 !== a ? a + "" : a
    }

    function Ne(e, t) {
        return {
            get: function () {
                if (!e()) return (this.get = t).apply(this, arguments);
                delete this.get
            }
        }
    }! function () {
        function e() {
            if (l) {
                s.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ye.appendChild(s).appendChild(l);
                var e = R.getComputedStyle(l);
                i = "1%" !== e.top, a = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), n = 36 === t(e.width), l.style.position = "absolute", r = 36 === l.offsetWidth || "absolute", ye.removeChild(s), l = null
            }
        }

        function t(e) {
            return Math.round(parseFloat(e))
        }
        var i, n, r, o, a, s = w.createElement("div"),
            l = w.createElement("div");
        l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", E.clearCloneStyle = "content-box" === l.style.backgroundClip, _.extend(E, {
            boxSizingReliable: function () {
                return e(), n
            },
            pixelBoxStyles: function () {
                return e(), o
            },
            pixelPosition: function () {
                return e(), i
            },
            reliableMarginLeft: function () {
                return e(), a
            },
            scrollboxSize: function () {
                return e(), r
            }
        }))
    }();
    var Be = /^(none|table(?!-c[ea]).+)/,
        Ie = /^--/,
        $e = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        Ge = {
            letterSpacing: "0",
            fontWeight: "400"
        },
        We = ["Webkit", "Moz", "ms"],
        qe = w.createElement("div").style;

    function Xe(e) {
        var t = _.cssProps[e];
        return t || (t = _.cssProps[e] = function (e) {
            if (e in qe) return e;
            for (var t = e[0].toUpperCase() + e.slice(1), i = We.length; i--;)
                if ((e = We[i] + t) in qe) return e
        }(e) || e), t
    }

    function Ye(e, t, i) {
        var n = ie.exec(t);
        return n ? Math.max(0, n[2] - (i || 0)) + (n[3] || "px") : t
    }

    function Ke(e, t, i, n, r, o) {
        var a = "width" === t ? 1 : 0,
            s = 0,
            l = 0;
        if (i === (n ? "border" : "content")) return 0;
        for (; a < 4; a += 2) "margin" === i && (l += _.css(e, i + ne[a], !0, r)), n ? ("content" === i && (l -= _.css(e, "padding" + ne[a], !0, r)), "margin" !== i && (l -= _.css(e, "border" + ne[a] + "Width", !0, r))) : (l += _.css(e, "padding" + ne[a], !0, r), "padding" !== i ? l += _.css(e, "border" + ne[a] + "Width", !0, r) : s += _.css(e, "border" + ne[a] + "Width", !0, r));
        return !n && 0 <= o && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - l - s - .5))), l
    }

    function Qe(e, t, i) {
        var n = je(e),
            r = Ve(e, t, n),
            o = "border-box" === _.css(e, "boxSizing", !1, n),
            a = o;
        if (Fe.test(r)) {
            if (!i) return r;
            r = "auto"
        }
        return a = a && (E.boxSizingReliable() || r === e.style[t]), ("auto" === r || !parseFloat(r) && "inline" === _.css(e, "display", !1, n)) && (r = e["offset" + t[0].toUpperCase() + t.slice(1)], a = !0), (r = parseFloat(r) || 0) + Ke(e, t, i || (o ? "border" : "content"), a, n, r) + "px"
    }

    function Ze(e, t, i, n, r) {
        return new Ze.prototype.init(e, t, i, n, r)
    }
    _.extend({
        cssHooks: {
            opacity: {
                get: function (e, t) {
                    if (t) {
                        var i = Ve(e, "opacity");
                        return "" === i ? "1" : i
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {},
        style: function (e, t, i, n) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var r, o, a, s = q(t),
                    l = Ie.test(t),
                    c = e.style;
                if (l || (t = Xe(s)), a = _.cssHooks[t] || _.cssHooks[s], void 0 === i) return a && "get" in a && void 0 !== (r = a.get(e, !1, n)) ? r : c[t];
                "string" === (o = typeof i) && (r = ie.exec(i)) && r[1] && (i = ae(e, t, r), o = "number"), null != i && i == i && ("number" === o && (i += r && r[3] || (_.cssNumber[s] ? "" : "px")), E.clearCloneStyle || "" !== i || 0 !== t.indexOf("background") || (c[t] = "inherit"), a && "set" in a && void 0 === (i = a.set(e, i, n)) || (l ? c.setProperty(t, i) : c[t] = i))
            }
        },
        css: function (e, t, i, n) {
            var r, o, a, s = q(t);
            return Ie.test(t) || (t = Xe(s)), (a = _.cssHooks[t] || _.cssHooks[s]) && "get" in a && (r = a.get(e, !0, i)), void 0 === r && (r = Ve(e, t, n)), "normal" === r && t in Ge && (r = Ge[t]), "" === i || i ? (o = parseFloat(r), !0 === i || isFinite(o) ? o || 0 : r) : r
        }
    }), _.each(["height", "width"], function (e, s) {
        _.cssHooks[s] = {
            get: function (e, t, i) {
                if (t) return !Be.test(_.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Qe(e, s, i) : oe(e, $e, function () {
                    return Qe(e, s, i)
                })
            },
            set: function (e, t, i) {
                var n, r = je(e),
                    o = "border-box" === _.css(e, "boxSizing", !1, r),
                    a = i && Ke(e, s, i, o, r);
                return o && E.scrollboxSize() === r.position && (a -= Math.ceil(e["offset" + s[0].toUpperCase() + s.slice(1)] - parseFloat(r[s]) - Ke(e, s, "border", !1, r) - .5)), a && (n = ie.exec(t)) && "px" !== (n[3] || "px") && (e.style[s] = t, t = _.css(e, s)), Ye(0, t, a)
            }
        }
    }), _.cssHooks.marginLeft = Ne(E.reliableMarginLeft, function (e, t) {
        if (t) return (parseFloat(Ve(e, "marginLeft")) || e.getBoundingClientRect().left - oe(e, {
            marginLeft: 0
        }, function () {
            return e.getBoundingClientRect().left
        })) + "px"
    }), _.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function (r, o) {
        _.cssHooks[r + o] = {
            expand: function (e) {
                for (var t = 0, i = {}, n = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) i[r + ne[t] + o] = n[t] || n[t - 2] || n[0];
                return i
            }
        }, "margin" !== r && (_.cssHooks[r + o].set = Ye)
    }), _.fn.extend({
        css: function (e, t) {
            return I(this, function (e, t, i) {
                var n, r, o = {},
                    a = 0;
                if (Array.isArray(t)) {
                    for (n = je(e), r = t.length; a < r; a++) o[t[a]] = _.css(e, t[a], !1, n);
                    return o
                }
                return void 0 !== i ? _.style(e, t, i) : _.css(e, t)
            }, e, t, 1 < arguments.length)
        }
    }), ((_.Tween = Ze).prototype = {
        constructor: Ze,
        init: function (e, t, i, n, r, o) {
            this.elem = e, this.prop = i, this.easing = r || _.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = n, this.unit = o || (_.cssNumber[i] ? "" : "px")
        },
        cur: function () {
            var e = Ze.propHooks[this.prop];
            return e && e.get ? e.get(this) : Ze.propHooks._default.get(this)
        },
        run: function (e) {
            var t, i = Ze.propHooks[this.prop];
            return this.options.duration ? this.pos = t = _.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : Ze.propHooks._default.set(this), this
        }
    }).init.prototype = Ze.prototype, (Ze.propHooks = {
        _default: {
            get: function (e) {
                var t;
                return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = _.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0
            },
            set: function (e) {
                _.fx.step[e.prop] ? _.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[_.cssProps[e.prop]] && !_.cssHooks[e.prop] ? e.elem[e.prop] = e.now : _.style(e.elem, e.prop, e.now + e.unit)
            }
        }
    }).scrollTop = Ze.propHooks.scrollLeft = {
        set: function (e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
        }
    }, _.easing = {
        linear: function (e) {
            return e
        },
        swing: function (e) {
            return .5 - Math.cos(e * Math.PI) / 2
        },
        _default: "swing"
    }, _.fx = Ze.prototype.init, _.fx.step = {};
    var Je, et, tt, it, nt = /^(?:toggle|show|hide)$/,
        rt = /queueHooks$/;

    function ot() {
        et && (!1 === w.hidden && R.requestAnimationFrame ? R.requestAnimationFrame(ot) : R.setTimeout(ot, _.fx.interval), _.fx.tick())
    }

    function at() {
        return R.setTimeout(function () {
            Je = void 0
        }), Je = Date.now()
    }

    function st(e, t) {
        var i, n = 0,
            r = {
                height: e
            };
        for (t = t ? 1 : 0; n < 4; n += 2 - t) r["margin" + (i = ne[n])] = r["padding" + i] = e;
        return t && (r.opacity = r.width = e), r
    }

    function lt(e, t, i) {
        for (var n, r = (ct.tweeners[t] || []).concat(ct.tweeners["*"]), o = 0, a = r.length; o < a; o++)
            if (n = r[o].call(i, t, e)) return n
    }

    function ct(o, e, t) {
        var i, a, n = 0,
            r = ct.prefilters.length,
            s = _.Deferred().always(function () {
                delete l.elem
            }),
            l = function () {
                if (a) return !1;
                for (var e = Je || at(), t = Math.max(0, c.startTime + c.duration - e), i = 1 - (t / c.duration || 0), n = 0, r = c.tweens.length; n < r; n++) c.tweens[n].run(i);
                return s.notifyWith(o, [c, i, t]), i < 1 && r ? t : (r || s.notifyWith(o, [c, 1, 0]), s.resolveWith(o, [c]), !1)
            },
            c = s.promise({
                elem: o,
                props: _.extend({}, e),
                opts: _.extend(!0, {
                    specialEasing: {},
                    easing: _.easing._default
                }, t),
                originalProperties: e,
                originalOptions: t,
                startTime: Je || at(),
                duration: t.duration,
                tweens: [],
                createTween: function (e, t) {
                    var i = _.Tween(o, c.opts, e, t, c.opts.specialEasing[e] || c.opts.easing);
                    return c.tweens.push(i), i
                },
                stop: function (e) {
                    var t = 0,
                        i = e ? c.tweens.length : 0;
                    if (a) return this;
                    for (a = !0; t < i; t++) c.tweens[t].run(1);
                    return e ? (s.notifyWith(o, [c, 1, 0]), s.resolveWith(o, [c, e])) : s.rejectWith(o, [c, e]), this
                }
            }),
            h = c.props;
        for (! function (e, t) {
                var i, n, r, o, a;
                for (i in e)
                    if (r = t[n = q(i)], o = e[i], Array.isArray(o) && (r = o[1], o = e[i] = o[0]), i !== n && (e[n] = o, delete e[i]), (a = _.cssHooks[n]) && "expand" in a)
                        for (i in o = a.expand(o), delete e[n], o) i in e || (e[i] = o[i], t[i] = r);
                    else t[n] = r
            }(h, c.opts.specialEasing); n < r; n++)
            if (i = ct.prefilters[n].call(c, o, h, c.opts)) return v(i.stop) && (_._queueHooks(c.elem, c.opts.queue).stop = i.stop.bind(i)), i;
        return _.map(h, lt, c), v(c.opts.start) && c.opts.start.call(o, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), _.fx.timer(_.extend(l, {
            elem: o,
            anim: c,
            queue: c.opts.queue
        })), c
    }
    _.Animation = _.extend(ct, {
        tweeners: {
            "*": [function (e, t) {
                var i = this.createTween(e, t);
                return ae(i.elem, e, ie.exec(t), i), i
            }]
        },
        tweener: function (e, t) {
            for (var i, n = 0, r = (e = v(e) ? (t = e, ["*"]) : e.match(O)).length; n < r; n++) i = e[n], ct.tweeners[i] = ct.tweeners[i] || [], ct.tweeners[i].unshift(t)
        },
        prefilters: [function (e, t, i) {
            var n, r, o, a, s, l, c, h, u = "width" in t || "height" in t,
                f = this,
                d = {},
                p = e.style,
                m = e.nodeType && re(e),
                g = K.get(e, "fxshow");
            for (n in i.queue || (null == (a = _._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
                    a.unqueued || s()
                }), a.unqueued++, f.always(function () {
                    f.always(function () {
                        a.unqueued--, _.queue(e, "fx").length || a.empty.fire()
                    })
                })), t)
                if (r = t[n], nt.test(r)) {
                    if (delete t[n], o = o || "toggle" === r, r === (m ? "hide" : "show")) {
                        if ("show" !== r || !g || void 0 === g[n]) continue;
                        m = !0
                    }
                    d[n] = g && g[n] || _.style(e, n)
                } if ((l = !_.isEmptyObject(t)) || !_.isEmptyObject(d))
                for (n in u && 1 === e.nodeType && (i.overflow = [p.overflow, p.overflowX, p.overflowY], null == (c = g && g.display) && (c = K.get(e, "display")), "none" === (h = _.css(e, "display")) && (c ? h = c : (le([e], !0), c = e.style.display || c, h = _.css(e, "display"), le([e]))), ("inline" === h || "inline-block" === h && null != c) && "none" === _.css(e, "float") && (l || (f.done(function () {
                        p.display = c
                    }), null == c && (h = p.display, c = "none" === h ? "" : h)), p.display = "inline-block")), i.overflow && (p.overflow = "hidden", f.always(function () {
                        p.overflow = i.overflow[0], p.overflowX = i.overflow[1], p.overflowY = i.overflow[2]
                    })), l = !1, d) l || (g ? "hidden" in g && (m = g.hidden) : g = K.access(e, "fxshow", {
                    display: c
                }), o && (g.hidden = !m), m && le([e], !0), f.done(function () {
                    for (n in m || le([e]), K.remove(e, "fxshow"), d) _.style(e, n, d[n])
                })), l = lt(m ? g[n] : 0, n, f), n in g || (g[n] = l.start, m && (l.end = l.start, l.start = 0))
        }],
        prefilter: function (e, t) {
            t ? ct.prefilters.unshift(e) : ct.prefilters.push(e)
        }
    }), _.speed = function (e, t, i) {
        var n = e && "object" == typeof e ? _.extend({}, e) : {
            complete: i || !i && t || v(e) && e,
            duration: e,
            easing: i && t || t && !v(t) && t
        };
        return _.fx.off ? n.duration = 0 : "number" != typeof n.duration && (n.duration in _.fx.speeds ? n.duration = _.fx.speeds[n.duration] : n.duration = _.fx.speeds._default), null != n.queue && !0 !== n.queue || (n.queue = "fx"), n.old = n.complete, n.complete = function () {
            v(n.old) && n.old.call(this), n.queue && _.dequeue(this, n.queue)
        }, n
    }, _.fn.extend({
        fadeTo: function (e, t, i, n) {
            return this.filter(re).css("opacity", 0).show().end().animate({
                opacity: t
            }, e, i, n)
        },
        animate: function (t, e, i, n) {
            var r = _.isEmptyObject(t),
                o = _.speed(e, i, n),
                a = function () {
                    var e = ct(this, _.extend({}, t), o);
                    (r || K.get(this, "finish")) && e.stop(!0)
                };
            return a.finish = a, r || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
        },
        stop: function (r, e, o) {
            var a = function (e) {
                var t = e.stop;
                delete e.stop, t(o)
            };
            return "string" != typeof r && (o = e, e = r, r = void 0), e && !1 !== r && this.queue(r || "fx", []), this.each(function () {
                var e = !0,
                    t = null != r && r + "queueHooks",
                    i = _.timers,
                    n = K.get(this);
                if (t) n[t] && n[t].stop && a(n[t]);
                else
                    for (t in n) n[t] && n[t].stop && rt.test(t) && a(n[t]);
                for (t = i.length; t--;) i[t].elem !== this || null != r && i[t].queue !== r || (i[t].anim.stop(o), e = !1, i.splice(t, 1));
                !e && o || _.dequeue(this, r)
            })
        },
        finish: function (a) {
            return !1 !== a && (a = a || "fx"), this.each(function () {
                var e, t = K.get(this),
                    i = t[a + "queue"],
                    n = t[a + "queueHooks"],
                    r = _.timers,
                    o = i ? i.length : 0;
                for (t.finish = !0, _.queue(this, a, []), n && n.stop && n.stop.call(this, !0), e = r.length; e--;) r[e].elem === this && r[e].queue === a && (r[e].anim.stop(!0), r.splice(e, 1));
                for (e = 0; e < o; e++) i[e] && i[e].finish && i[e].finish.call(this);
                delete t.finish
            })
        }
    }), _.each(["toggle", "show", "hide"], function (e, n) {
        var r = _.fn[n];
        _.fn[n] = function (e, t, i) {
            return null == e || "boolean" == typeof e ? r.apply(this, arguments) : this.animate(st(n, !0), e, t, i)
        }
    }), _.each({
        slideDown: st("show"),
        slideUp: st("hide"),
        slideToggle: st("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function (e, n) {
        _.fn[e] = function (e, t, i) {
            return this.animate(n, e, t, i)
        }
    }), _.timers = [], _.fx.tick = function () {
        var e, t = 0,
            i = _.timers;
        for (Je = Date.now(); t < i.length; t++)(e = i[t])() || i[t] !== e || i.splice(t--, 1);
        i.length || _.fx.stop(), Je = void 0
    }, _.fx.timer = function (e) {
        _.timers.push(e), _.fx.start()
    }, _.fx.interval = 13, _.fx.start = function () {
        et || (et = !0, ot())
    }, _.fx.stop = function () {
        et = null
    }, _.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, _.fn.delay = function (n, e) {
        return n = _.fx && _.fx.speeds[n] || n, e = e || "fx", this.queue(e, function (e, t) {
            var i = R.setTimeout(e, n);
            t.stop = function () {
                R.clearTimeout(i)
            }
        })
    }, tt = w.createElement("input"), it = w.createElement("select").appendChild(w.createElement("option")), tt.type = "checkbox", E.checkOn = "" !== tt.value, E.optSelected = it.selected, (tt = w.createElement("input")).value = "t", tt.type = "radio", E.radioValue = "t" === tt.value;
    var ht, ut = _.expr.attrHandle;
    _.fn.extend({
        attr: function (e, t) {
            return I(this, _.attr, e, t, 1 < arguments.length)
        },
        removeAttr: function (e) {
            return this.each(function () {
                _.removeAttr(this, e)
            })
        }
    }), _.extend({
        attr: function (e, t, i) {
            var n, r, o = e.nodeType;
            if (3 !== o && 8 !== o && 2 !== o) return void 0 === e.getAttribute ? _.prop(e, t, i) : (1 === o && _.isXMLDoc(e) || (r = _.attrHooks[t.toLowerCase()] || (_.expr.match.bool.test(t) ? ht : void 0)), void 0 !== i ? null === i ? void _.removeAttr(e, t) : r && "set" in r && void 0 !== (n = r.set(e, i, t)) ? n : (e.setAttribute(t, i + ""), i) : r && "get" in r && null !== (n = r.get(e, t)) ? n : null == (n = _.find.attr(e, t)) ? void 0 : n)
        },
        attrHooks: {
            type: {
                set: function (e, t) {
                    if (!E.radioValue && "radio" === t && M(e, "input")) {
                        var i = e.value;
                        return e.setAttribute("type", t), i && (e.value = i), t
                    }
                }
            }
        },
        removeAttr: function (e, t) {
            var i, n = 0,
                r = t && t.match(O);
            if (r && 1 === e.nodeType)
                for (; i = r[n++];) e.removeAttribute(i)
        }
    }), ht = {
        set: function (e, t, i) {
            return !1 === t ? _.removeAttr(e, i) : e.setAttribute(i, i), i
        }
    }, _.each(_.expr.match.bool.source.match(/\w+/g), function (e, t) {
        var a = ut[t] || _.find.attr;
        ut[t] = function (e, t, i) {
            var n, r, o = t.toLowerCase();
            return i || (r = ut[o], ut[o] = n, n = null != a(e, t, i) ? o : null, ut[o] = r), n
        }
    });
    var ft = /^(?:input|select|textarea|button)$/i,
        dt = /^(?:a|area)$/i;

    function pt(e) {
        return (e.match(O) || []).join(" ")
    }

    function mt(e) {
        return e.getAttribute && e.getAttribute("class") || ""
    }

    function gt(e) {
        return Array.isArray(e) ? e : "string" == typeof e && e.match(O) || []
    }
    _.fn.extend({
        prop: function (e, t) {
            return I(this, _.prop, e, t, 1 < arguments.length)
        },
        removeProp: function (e) {
            return this.each(function () {
                delete this[_.propFix[e] || e]
            })
        }
    }), _.extend({
        prop: function (e, t, i) {
            var n, r, o = e.nodeType;
            if (3 !== o && 8 !== o && 2 !== o) return 1 === o && _.isXMLDoc(e) || (t = _.propFix[t] || t, r = _.propHooks[t]), void 0 !== i ? r && "set" in r && void 0 !== (n = r.set(e, i, t)) ? n : e[t] = i : r && "get" in r && null !== (n = r.get(e, t)) ? n : e[t]
        },
        propHooks: {
            tabIndex: {
                get: function (e) {
                    var t = _.find.attr(e, "tabindex");
                    return t ? parseInt(t, 10) : ft.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    }), E.optSelected || (_.propHooks.selected = {
        get: function (e) {
            var t = e.parentNode;
            return t && t.parentNode && t.parentNode.selectedIndex, null
        },
        set: function (e) {
            var t = e.parentNode;
            t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
        }
    }), _.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        _.propFix[this.toLowerCase()] = this
    }), _.fn.extend({
        addClass: function (t) {
            var e, i, n, r, o, a, s, l = 0;
            if (v(t)) return this.each(function (e) {
                _(this).addClass(t.call(this, e, mt(this)))
            });
            if ((e = gt(t)).length)
                for (; i = this[l++];)
                    if (r = mt(i), n = 1 === i.nodeType && " " + pt(r) + " ") {
                        for (a = 0; o = e[a++];) n.indexOf(" " + o + " ") < 0 && (n += o + " ");
                        r !== (s = pt(n)) && i.setAttribute("class", s)
                    } return this
        },
        removeClass: function (t) {
            var e, i, n, r, o, a, s, l = 0;
            if (v(t)) return this.each(function (e) {
                _(this).removeClass(t.call(this, e, mt(this)))
            });
            if (!arguments.length) return this.attr("class", "");
            if ((e = gt(t)).length)
                for (; i = this[l++];)
                    if (r = mt(i), n = 1 === i.nodeType && " " + pt(r) + " ") {
                        for (a = 0; o = e[a++];)
                            for (; - 1 < n.indexOf(" " + o + " ");) n = n.replace(" " + o + " ", " ");
                        r !== (s = pt(n)) && i.setAttribute("class", s)
                    } return this
        },
        toggleClass: function (r, t) {
            var o = typeof r,
                a = "string" === o || Array.isArray(r);
            return "boolean" == typeof t && a ? t ? this.addClass(r) : this.removeClass(r) : v(r) ? this.each(function (e) {
                _(this).toggleClass(r.call(this, e, mt(this), t), t)
            }) : this.each(function () {
                var e, t, i, n;
                if (a)
                    for (t = 0, i = _(this), n = gt(r); e = n[t++];) i.hasClass(e) ? i.removeClass(e) : i.addClass(e);
                else void 0 !== r && "boolean" !== o || ((e = mt(this)) && K.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === r ? "" : K.get(this, "__className__") || ""))
            })
        },
        hasClass: function (e) {
            var t, i, n = 0;
            for (t = " " + e + " "; i = this[n++];)
                if (1 === i.nodeType && -1 < (" " + pt(mt(i)) + " ").indexOf(t)) return !0;
            return !1
        }
    });
    var Et = /\r/g;
    _.fn.extend({
        val: function (i) {
            var n, e, r, t = this[0];
            return arguments.length ? (r = v(i), this.each(function (e) {
                var t;
                1 === this.nodeType && (null == (t = r ? i.call(this, e, _(this).val()) : i) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = _.map(t, function (e) {
                    return null == e ? "" : e + ""
                })), (n = _.valHooks[this.type] || _.valHooks[this.nodeName.toLowerCase()]) && "set" in n && void 0 !== n.set(this, t, "value") || (this.value = t))
            })) : t ? (n = _.valHooks[t.type] || _.valHooks[t.nodeName.toLowerCase()]) && "get" in n && void 0 !== (e = n.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(Et, "") : null == e ? "" : e : void 0
        }
    }), _.extend({
        valHooks: {
            option: {
                get: function (e) {
                    var t = _.find.attr(e, "value");
                    return null != t ? t : pt(_.text(e))
                }
            },
            select: {
                get: function (e) {
                    var t, i, n, r = e.options,
                        o = e.selectedIndex,
                        a = "select-one" === e.type,
                        s = a ? null : [],
                        l = a ? o + 1 : r.length;
                    for (n = o < 0 ? l : a ? o : 0; n < l; n++)
                        if (((i = r[n]).selected || n === o) && !i.disabled && (!i.parentNode.disabled || !M(i.parentNode, "optgroup"))) {
                            if (t = _(i).val(), a) return t;
                            s.push(t)
                        } return s
                },
                set: function (e, t) {
                    for (var i, n, r = e.options, o = _.makeArray(t), a = r.length; a--;)((n = r[a]).selected = -1 < _.inArray(_.valHooks.option.get(n), o)) && (i = !0);
                    return i || (e.selectedIndex = -1), o
                }
            }
        }
    }), _.each(["radio", "checkbox"], function () {
        _.valHooks[this] = {
            set: function (e, t) {
                if (Array.isArray(t)) return e.checked = -1 < _.inArray(_(e).val(), t)
            }
        }, E.checkOn || (_.valHooks[this].get = function (e) {
            return null === e.getAttribute("value") ? "on" : e.value
        })
    }), E.focusin = "onfocusin" in R;
    var vt = /^(?:focusinfocus|focusoutblur)$/,
        yt = function (e) {
            e.stopPropagation()
        };
    _.extend(_.event, {
        trigger: function (e, t, i, n) {
            var r, o, a, s, l, c, h, u, f = [i || w],
                d = g.call(e, "type") ? e.type : e,
                p = g.call(e, "namespace") ? e.namespace.split(".") : [];
            if (o = u = a = i = i || w, 3 !== i.nodeType && 8 !== i.nodeType && !vt.test(d + _.event.triggered) && (-1 < d.indexOf(".") && (d = (p = d.split(".")).shift(), p.sort()), l = d.indexOf(":") < 0 && "on" + d, (e = e[_.expando] ? e : new _.Event(d, "object" == typeof e && e)).isTrigger = n ? 2 : 3, e.namespace = p.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = i), t = null == t ? [e] : _.makeArray(t, [e]), h = _.event.special[d] || {}, n || !h.trigger || !1 !== h.trigger.apply(i, t))) {
                if (!n && !h.noBubble && !y(i)) {
                    for (s = h.delegateType || d, vt.test(s + d) || (o = o.parentNode); o; o = o.parentNode) f.push(o), a = o;
                    a === (i.ownerDocument || w) && f.push(a.defaultView || a.parentWindow || R)
                }
                for (r = 0;
                    (o = f[r++]) && !e.isPropagationStopped();) u = o, e.type = 1 < r ? s : h.bindType || d, (c = (K.get(o, "events") || {})[e.type] && K.get(o, "handle")) && c.apply(o, t), (c = l && o[l]) && c.apply && X(o) && (e.result = c.apply(o, t), !1 === e.result && e.preventDefault());
                return e.type = d, n || e.isDefaultPrevented() || h._default && !1 !== h._default.apply(f.pop(), t) || !X(i) || l && v(i[d]) && !y(i) && ((a = i[l]) && (i[l] = null), _.event.triggered = d, e.isPropagationStopped() && u.addEventListener(d, yt), i[d](), e.isPropagationStopped() && u.removeEventListener(d, yt), _.event.triggered = void 0, a && (i[l] = a)), e.result
            }
        },
        simulate: function (e, t, i) {
            var n = _.extend(new _.Event, i, {
                type: e,
                isSimulated: !0
            });
            _.event.trigger(n, null, t)
        }
    }), _.fn.extend({
        trigger: function (e, t) {
            return this.each(function () {
                _.event.trigger(e, t, this)
            })
        },
        triggerHandler: function (e, t) {
            var i = this[0];
            if (i) return _.event.trigger(e, t, i, !0)
        }
    }), E.focusin || _.each({
        focus: "focusin",
        blur: "focusout"
    }, function (i, n) {
        var r = function (e) {
            _.event.simulate(n, e.target, _.event.fix(e))
        };
        _.event.special[n] = {
            setup: function () {
                var e = this.ownerDocument || this,
                    t = K.access(e, n);
                t || e.addEventListener(i, r, !0), K.access(e, n, (t || 0) + 1)
            },
            teardown: function () {
                var e = this.ownerDocument || this,
                    t = K.access(e, n) - 1;
                t ? K.access(e, n, t) : (e.removeEventListener(i, r, !0), K.remove(e, n))
            }
        }
    });
    var Tt = R.location,
        bt = Date.now(),
        xt = /\?/;
    _.parseXML = function (e) {
        var t;
        if (!e || "string" != typeof e) return null;
        try {
            t = (new R.DOMParser).parseFromString(e, "text/xml")
        } catch (e) {
            t = void 0
        }
        return t && !t.getElementsByTagName("parsererror").length || _.error("Invalid XML: " + e), t
    };
    var Rt = /\[\]$/,
        wt = /\r?\n/g,
        _t = /^(?:submit|button|image|reset|file)$/i,
        Ht = /^(?:input|select|textarea|keygen)/i;

    function St(i, e, n, r) {
        var t;
        if (Array.isArray(e)) _.each(e, function (e, t) {
            n || Rt.test(i) ? r(i, t) : St(i + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, n, r)
        });
        else if (n || "object" !== b(e)) r(i, e);
        else
            for (t in e) St(i + "[" + t + "]", e[t], n, r)
    }
    _.param = function (e, t) {
        var i, n = [],
            r = function (e, t) {
                var i = v(t) ? t() : t;
                n[n.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == i ? "" : i)
            };
        if (Array.isArray(e) || e.jquery && !_.isPlainObject(e)) _.each(e, function () {
            r(this.name, this.value)
        });
        else
            for (i in e) St(i, e[i], t, r);
        return n.join("&")
    }, _.fn.extend({
        serialize: function () {
            return _.param(this.serializeArray())
        },
        serializeArray: function () {
            return this.map(function () {
                var e = _.prop(this, "elements");
                return e ? _.makeArray(e) : this
            }).filter(function () {
                var e = this.type;
                return this.name && !_(this).is(":disabled") && Ht.test(this.nodeName) && !_t.test(e) && (this.checked || !ce.test(e))
            }).map(function (e, t) {
                var i = _(this).val();
                return null == i ? null : Array.isArray(i) ? _.map(i, function (e) {
                    return {
                        name: t.name,
                        value: e.replace(wt, "\r\n")
                    }
                }) : {
                    name: t.name,
                    value: i.replace(wt, "\r\n")
                }
            }).get()
        }
    });
    var Mt = /%20/g,
        Ct = /#.*$/,
        At = /([?&])_=[^&]*/,
        Pt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        Lt = /^(?:GET|HEAD)$/,
        Dt = /^\/\//,
        zt = {},
        kt = {},
        Ot = "*/".concat("*"),
        Ft = w.createElement("a");

    function jt(o) {
        return function (e, t) {
            "string" != typeof e && (t = e, e = "*");
            var i, n = 0,
                r = e.toLowerCase().match(O) || [];
            if (v(t))
                for (; i = r[n++];) "+" === i[0] ? (i = i.slice(1) || "*", (o[i] = o[i] || []).unshift(t)) : (o[i] = o[i] || []).push(t)
        }
    }

    function Ut(t, r, o, a) {
        var s = {},
            l = t === kt;

        function c(e) {
            var n;
            return s[e] = !0, _.each(t[e] || [], function (e, t) {
                var i = t(r, o, a);
                return "string" != typeof i || l || s[i] ? l ? !(n = i) : void 0 : (r.dataTypes.unshift(i), c(i), !1)
            }), n
        }
        return c(r.dataTypes[0]) || !s["*"] && c("*")
    }

    function Vt(e, t) {
        var i, n, r = _.ajaxSettings.flatOptions || {};
        for (i in t) void 0 !== t[i] && ((r[i] ? e : n || (n = {}))[i] = t[i]);
        return n && _.extend(!0, e, n), e
    }
    Ft.href = Tt.href, _.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Tt.href,
            type: "GET",
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Ot,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": _.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function (e, t) {
            return t ? Vt(Vt(e, _.ajaxSettings), t) : Vt(_.ajaxSettings, e)
        },
        ajaxPrefilter: jt(zt),
        ajaxTransport: jt(kt),
        ajax: function (e, t) {
            "object" == typeof e && (t = e, e = void 0), t = t || {};
            var h, u, f, i, d, n, p, m, r, o, g = _.ajaxSetup({}, t),
                E = g.context || g,
                v = g.context && (E.nodeType || E.jquery) ? _(E) : _.event,
                y = _.Deferred(),
                T = _.Callbacks("once memory"),
                b = g.statusCode || {},
                a = {},
                s = {},
                l = "canceled",
                x = {
                    readyState: 0,
                    getResponseHeader: function (e) {
                        var t;
                        if (p) {
                            if (!i)
                                for (i = {}; t = Pt.exec(f);) i[t[1].toLowerCase()] = t[2];
                            t = i[e.toLowerCase()]
                        }
                        return null == t ? null : t
                    },
                    getAllResponseHeaders: function () {
                        return p ? f : null
                    },
                    setRequestHeader: function (e, t) {
                        return null == p && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this
                    },
                    overrideMimeType: function (e) {
                        return null == p && (g.mimeType = e), this
                    },
                    statusCode: function (e) {
                        var t;
                        if (e)
                            if (p) x.always(e[x.status]);
                            else
                                for (t in e) b[t] = [b[t], e[t]];
                        return this
                    },
                    abort: function (e) {
                        var t = e || l;
                        return h && h.abort(t), c(0, t), this
                    }
                };
            if (y.promise(x), g.url = ((e || g.url || Tt.href) + "").replace(Dt, Tt.protocol + "//"), g.type = t.method || t.type || g.method || g.type, g.dataTypes = (g.dataType || "*").toLowerCase().match(O) || [""], null == g.crossDomain) {
                n = w.createElement("a");
                try {
                    n.href = g.url, n.href = n.href, g.crossDomain = Ft.protocol + "//" + Ft.host != n.protocol + "//" + n.host
                } catch (e) {
                    g.crossDomain = !0
                }
            }
            if (g.data && g.processData && "string" != typeof g.data && (g.data = _.param(g.data, g.traditional)), Ut(zt, g, t, x), p) return x;
            for (r in (m = _.event && g.global) && 0 == _.active++ && _.event.trigger("ajaxStart"), g.type = g.type.toUpperCase(), g.hasContent = !Lt.test(g.type), u = g.url.replace(Ct, ""), g.hasContent ? g.data && g.processData && 0 === (g.contentType || "").indexOf("application/x-www-form-urlencoded") && (g.data = g.data.replace(Mt, "+")) : (o = g.url.slice(u.length), g.data && (g.processData || "string" == typeof g.data) && (u += (xt.test(u) ? "&" : "?") + g.data, delete g.data), !1 === g.cache && (u = u.replace(At, "$1"), o = (xt.test(u) ? "&" : "?") + "_=" + bt++ + o), g.url = u + o), g.ifModified && (_.lastModified[u] && x.setRequestHeader("If-Modified-Since", _.lastModified[u]), _.etag[u] && x.setRequestHeader("If-None-Match", _.etag[u])), (g.data && g.hasContent && !1 !== g.contentType || t.contentType) && x.setRequestHeader("Content-Type", g.contentType), x.setRequestHeader("Accept", g.dataTypes[0] && g.accepts[g.dataTypes[0]] ? g.accepts[g.dataTypes[0]] + ("*" !== g.dataTypes[0] ? ", " + Ot + "; q=0.01" : "") : g.accepts["*"]), g.headers) x.setRequestHeader(r, g.headers[r]);
            if (g.beforeSend && (!1 === g.beforeSend.call(E, x, g) || p)) return x.abort();
            if (l = "abort", T.add(g.complete), x.done(g.success), x.fail(g.error), h = Ut(kt, g, t, x)) {
                if (x.readyState = 1, m && v.trigger("ajaxSend", [x, g]), p) return x;
                g.async && 0 < g.timeout && (d = R.setTimeout(function () {
                    x.abort("timeout")
                }, g.timeout));
                try {
                    p = !1, h.send(a, c)
                } catch (e) {
                    if (p) throw e;
                    c(-1, e)
                }
            } else c(-1, "No Transport");

            function c(e, t, i, n) {
                var r, o, a, s, l, c = t;
                p || (p = !0, d && R.clearTimeout(d), h = void 0, f = n || "", x.readyState = 0 < e ? 4 : 0, r = 200 <= e && e < 300 || 304 === e, i && (s = function (e, t, i) {
                    for (var n, r, o, a, s = e.contents, l = e.dataTypes;
                        "*" === l[0];) l.shift(), void 0 === n && (n = e.mimeType || t.getResponseHeader("Content-Type"));
                    if (n)
                        for (r in s)
                            if (s[r] && s[r].test(n)) {
                                l.unshift(r);
                                break
                            } if (l[0] in i) o = l[0];
                    else {
                        for (r in i) {
                            if (!l[0] || e.converters[r + " " + l[0]]) {
                                o = r;
                                break
                            }
                            a || (a = r)
                        }
                        o = o || a
                    }
                    if (o) return o !== l[0] && l.unshift(o), i[o]
                }(g, x, i)), s = function (e, t, i, n) {
                    var r, o, a, s, l, c = {},
                        h = e.dataTypes.slice();
                    if (h[1])
                        for (a in e.converters) c[a.toLowerCase()] = e.converters[a];
                    for (o = h.shift(); o;)
                        if (e.responseFields[o] && (i[e.responseFields[o]] = t), !l && n && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = h.shift())
                            if ("*" === o) o = l;
                            else if ("*" !== l && l !== o) {
                        if (!(a = c[l + " " + o] || c["* " + o]))
                            for (r in c)
                                if ((s = r.split(" "))[1] === o && (a = c[l + " " + s[0]] || c["* " + s[0]])) {
                                    !0 === a ? a = c[r] : !0 !== c[r] && (o = s[0], h.unshift(s[1]));
                                    break
                                } if (!0 !== a)
                            if (a && e.throws) t = a(t);
                            else try {
                                t = a(t)
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: a ? e : "No conversion from " + l + " to " + o
                                }
                            }
                    }
                    return {
                        state: "success",
                        data: t
                    }
                }(g, s, x, r), r ? (g.ifModified && ((l = x.getResponseHeader("Last-Modified")) && (_.lastModified[u] = l), (l = x.getResponseHeader("etag")) && (_.etag[u] = l)), 204 === e || "HEAD" === g.type ? c = "nocontent" : 304 === e ? c = "notmodified" : (c = s.state, o = s.data, r = !(a = s.error))) : (a = c, !e && c || (c = "error", e < 0 && (e = 0))), x.status = e, x.statusText = (t || c) + "", r ? y.resolveWith(E, [o, c, x]) : y.rejectWith(E, [x, c, a]), x.statusCode(b), b = void 0, m && v.trigger(r ? "ajaxSuccess" : "ajaxError", [x, g, r ? o : a]), T.fireWith(E, [x, c]), m && (v.trigger("ajaxComplete", [x, g]), --_.active || _.event.trigger("ajaxStop")))
            }
            return x
        },
        getJSON: function (e, t, i) {
            return _.get(e, t, i, "json")
        },
        getScript: function (e, t) {
            return _.get(e, void 0, t, "script")
        }
    }), _.each(["get", "post"], function (e, r) {
        _[r] = function (e, t, i, n) {
            return v(t) && (n = n || i, i = t, t = void 0), _.ajax(_.extend({
                url: e,
                type: r,
                dataType: n,
                data: t,
                success: i
            }, _.isPlainObject(e) && e))
        }
    }), _._evalUrl = function (e) {
        return _.ajax({
            url: e,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            throws: !0
        })
    }, _.fn.extend({
        wrapAll: function (e) {
            var t;
            return this[0] && (v(e) && (e = e.call(this[0])), t = _(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
                for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                return e
            }).append(this)), this
        },
        wrapInner: function (i) {
            return v(i) ? this.each(function (e) {
                _(this).wrapInner(i.call(this, e))
            }) : this.each(function () {
                var e = _(this),
                    t = e.contents();
                t.length ? t.wrapAll(i) : e.append(i)
            })
        },
        wrap: function (t) {
            var i = v(t);
            return this.each(function (e) {
                _(this).wrapAll(i ? t.call(this, e) : t)
            })
        },
        unwrap: function (e) {
            return this.parent(e).not("body").each(function () {
                _(this).replaceWith(this.childNodes)
            }), this
        }
    }), _.expr.pseudos.hidden = function (e) {
        return !_.expr.pseudos.visible(e)
    }, _.expr.pseudos.visible = function (e) {
        return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
    }, _.ajaxSettings.xhr = function () {
        try {
            return new R.XMLHttpRequest
        } catch (e) {}
    };
    var Nt = {
            0: 200,
            1223: 204
        },
        Bt = _.ajaxSettings.xhr();
    E.cors = !!Bt && "withCredentials" in Bt, E.ajax = Bt = !!Bt, _.ajaxTransport(function (r) {
        var o, a;
        if (E.cors || Bt && !r.crossDomain) return {
            send: function (e, t) {
                var i, n = r.xhr();
                if (n.open(r.type, r.url, r.async, r.username, r.password), r.xhrFields)
                    for (i in r.xhrFields) n[i] = r.xhrFields[i];
                for (i in r.mimeType && n.overrideMimeType && n.overrideMimeType(r.mimeType), r.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) n.setRequestHeader(i, e[i]);
                o = function (e) {
                    return function () {
                        o && (o = a = n.onload = n.onerror = n.onabort = n.ontimeout = n.onreadystatechange = null, "abort" === e ? n.abort() : "error" === e ? "number" != typeof n.status ? t(0, "error") : t(n.status, n.statusText) : t(Nt[n.status] || n.status, n.statusText, "text" !== (n.responseType || "text") || "string" != typeof n.responseText ? {
                            binary: n.response
                        } : {
                            text: n.responseText
                        }, n.getAllResponseHeaders()))
                    }
                }, n.onload = o(), a = n.onerror = n.ontimeout = o("error"), void 0 !== n.onabort ? n.onabort = a : n.onreadystatechange = function () {
                    4 === n.readyState && R.setTimeout(function () {
                        o && a()
                    })
                }, o = o("abort");
                try {
                    n.send(r.hasContent && r.data || null)
                } catch (e) {
                    if (o) throw e
                }
            },
            abort: function () {
                o && o()
            }
        }
    }), _.ajaxPrefilter(function (e) {
        e.crossDomain && (e.contents.script = !1)
    }), _.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function (e) {
                return _.globalEval(e), e
            }
        }
    }), _.ajaxPrefilter("script", function (e) {
        void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
    }), _.ajaxTransport("script", function (i) {
        var n, r;
        if (i.crossDomain) return {
            send: function (e, t) {
                n = _("<script>").prop({
                    charset: i.scriptCharset,
                    src: i.url
                }).on("load error", r = function (e) {
                    n.remove(), r = null, e && t("error" === e.type ? 404 : 200, e.type)
                }), w.head.appendChild(n[0])
            },
            abort: function () {
                r && r()
            }
        }
    });
    var It, $t = [],
        Gt = /(=)\?(?=&|$)|\?\?/;
    _.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            var e = $t.pop() || _.expando + "_" + bt++;
            return this[e] = !0, e
        }
    }), _.ajaxPrefilter("json jsonp", function (e, t, i) {
        var n, r, o, a = !1 !== e.jsonp && (Gt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Gt.test(e.data) && "data");
        if (a || "jsonp" === e.dataTypes[0]) return n = e.jsonpCallback = v(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Gt, "$1" + n) : !1 !== e.jsonp && (e.url += (xt.test(e.url) ? "&" : "?") + e.jsonp + "=" + n), e.converters["script json"] = function () {
            return o || _.error(n + " was not called"), o[0]
        }, e.dataTypes[0] = "json", r = R[n], R[n] = function () {
            o = arguments
        }, i.always(function () {
            void 0 === r ? _(R).removeProp(n) : R[n] = r, e[n] && (e.jsonpCallback = t.jsonpCallback, $t.push(n)), o && v(r) && r(o[0]), o = r = void 0
        }), "script"
    }), E.createHTMLDocument = ((It = w.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === It.childNodes.length), _.parseHTML = function (e, t, i) {
        return "string" != typeof e ? [] : ("boolean" == typeof t && (i = t, t = !1), t || (E.createHTMLDocument ? ((n = (t = w.implementation.createHTMLDocument("")).createElement("base")).href = w.location.href, t.head.appendChild(n)) : t = w), o = !i && [], (r = C.exec(e)) ? [t.createElement(r[1])] : (r = ve([e], t, o), o && o.length && _(o).remove(), _.merge([], r.childNodes)));
        var n, r, o
    }, _.fn.load = function (e, t, i) {
        var n, r, o, a = this,
            s = e.indexOf(" ");
        return -1 < s && (n = pt(e.slice(s)), e = e.slice(0, s)), v(t) ? (i = t, t = void 0) : t && "object" == typeof t && (r = "POST"), 0 < a.length && _.ajax({
            url: e,
            type: r || "GET",
            dataType: "html",
            data: t
        }).done(function (e) {
            o = arguments, a.html(n ? _("<div>").append(_.parseHTML(e)).find(n) : e)
        }).always(i && function (e, t) {
            a.each(function () {
                i.apply(this, o || [e.responseText, t, e])
            })
        }), this
    }, _.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
        _.fn[t] = function (e) {
            return this.on(t, e)
        }
    }), _.expr.pseudos.animated = function (t) {
        return _.grep(_.timers, function (e) {
            return t === e.elem
        }).length
    }, _.offset = {
        setOffset: function (e, t, i) {
            var n, r, o, a, s, l, c = _.css(e, "position"),
                h = _(e),
                u = {};
            "static" === c && (e.style.position = "relative"), s = h.offset(), o = _.css(e, "top"), l = _.css(e, "left"), r = ("absolute" === c || "fixed" === c) && -1 < (o + l).indexOf("auto") ? (a = (n = h.position()).top, n.left) : (a = parseFloat(o) || 0, parseFloat(l) || 0), v(t) && (t = t.call(e, i, _.extend({}, s))), null != t.top && (u.top = t.top - s.top + a), null != t.left && (u.left = t.left - s.left + r), "using" in t ? t.using.call(e, u) : h.css(u)
        }
    }, _.fn.extend({
        offset: function (t) {
            if (arguments.length) return void 0 === t ? this : this.each(function (e) {
                _.offset.setOffset(this, t, e)
            });
            var e, i, n = this[0];
            return n ? n.getClientRects().length ? (e = n.getBoundingClientRect(), i = n.ownerDocument.defaultView, {
                top: e.top + i.pageYOffset,
                left: e.left + i.pageXOffset
            }) : {
                top: 0,
                left: 0
            } : void 0
        },
        position: function () {
            if (this[0]) {
                var e, t, i, n = this[0],
                    r = {
                        top: 0,
                        left: 0
                    };
                if ("fixed" === _.css(n, "position")) t = n.getBoundingClientRect();
                else {
                    for (t = this.offset(), i = n.ownerDocument, e = n.offsetParent || i.documentElement; e && (e === i.body || e === i.documentElement) && "static" === _.css(e, "position");) e = e.parentNode;
                    e && e !== n && 1 === e.nodeType && ((r = _(e).offset()).top += _.css(e, "borderTopWidth", !0), r.left += _.css(e, "borderLeftWidth", !0))
                }
                return {
                    top: t.top - r.top - _.css(n, "marginTop", !0),
                    left: t.left - r.left - _.css(n, "marginLeft", !0)
                }
            }
        },
        offsetParent: function () {
            return this.map(function () {
                for (var e = this.offsetParent; e && "static" === _.css(e, "position");) e = e.offsetParent;
                return e || ye
            })
        }
    }), _.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function (t, r) {
        var o = "pageYOffset" === r;
        _.fn[t] = function (e) {
            return I(this, function (e, t, i) {
                var n;
                if (y(e) ? n = e : 9 === e.nodeType && (n = e.defaultView), void 0 === i) return n ? n[r] : e[t];
                n ? n.scrollTo(o ? n.pageXOffset : i, o ? i : n.pageYOffset) : e[t] = i
            }, t, e, arguments.length)
        }
    }), _.each(["top", "left"], function (e, i) {
        _.cssHooks[i] = Ne(E.pixelPosition, function (e, t) {
            if (t) return t = Ve(e, i), Fe.test(t) ? _(e).position()[i] + "px" : t
        })
    }), _.each({
        Height: "height",
        Width: "width"
    }, function (a, s) {
        _.each({
            padding: "inner" + a,
            content: s,
            "": "outer" + a
        }, function (n, o) {
            _.fn[o] = function (e, t) {
                var i = arguments.length && (n || "boolean" != typeof e),
                    r = n || (!0 === e || !0 === t ? "margin" : "border");
                return I(this, function (e, t, i) {
                    var n;
                    return y(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (n = e.documentElement, Math.max(e.body["scroll" + a], n["scroll" + a], e.body["offset" + a], n["offset" + a], n["client" + a])) : void 0 === i ? _.css(e, t, r) : _.style(e, t, i, r)
                }, s, i ? e : void 0, i)
            }
        })
    }), _.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, i) {
        _.fn[i] = function (e, t) {
            return 0 < arguments.length ? this.on(i, null, e, t) : this.trigger(i)
        }
    }), _.fn.extend({
        hover: function (e, t) {
            return this.mouseenter(e).mouseleave(t || e)
        }
    }), _.fn.extend({
        bind: function (e, t, i) {
            return this.on(e, null, t, i)
        },
        unbind: function (e, t) {
            return this.off(e, null, t)
        },
        delegate: function (e, t, i, n) {
            return this.on(t, e, i, n)
        },
        undelegate: function (e, t, i) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", i)
        }
    }), _.proxy = function (e, t) {
        var i, n, r;
        if ("string" == typeof t && (i = e[t], t = e, e = i), v(e)) return n = s.call(arguments, 2), (r = function () {
            return e.apply(t || this, n.concat(s.call(arguments)))
        }).guid = e.guid = e.guid || _.guid++, r
    }, _.holdReady = function (e) {
        e ? _.readyWait++ : _.ready(!0)
    }, _.isArray = Array.isArray, _.parseJSON = JSON.parse, _.nodeName = M, _.isFunction = v, _.isWindow = y, _.camelCase = q, _.type = b, _.now = Date.now, _.isNumeric = function (e) {
        var t = _.type(e);
        return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
    }, "function" == typeof define && define.amd && define("jquery", [], function () {
        return _
    });
    var Wt = R.jQuery,
        qt = R.$;
    return _.noConflict = function (e) {
        return R.$ === _ && (R.$ = qt), e && R.jQuery === _ && (R.jQuery = Wt), _
    }, e || (R.jQuery = R.$ = _), _
}),
function (e) {
    "function" == typeof define && define.amd ? define(["jquery"], e) : "object" == typeof exports ? module.exports = e(require("jquery")) : e(jQuery)
}(function (h) {
    var u, f, n, d = [],
        p = document,
        m = window,
        g = p.documentElement;

    function t() {
        if (d.length) {
            var e, t, i, n = 0,
                r = h.map(d, function (e) {
                    var t = e.data.selector,
                        i = e.$element;
                    return t ? i.find(t) : i
                });
            for (u = u || ((i = {
                    height: m.innerHeight,
                    width: m.innerWidth
                }).height || !(e = p.compatMode) && h.support.boxModel || (i = {
                    height: (t = "CSS1Compat" === e ? g : p.body).clientHeight,
                    width: t.clientWidth
                }), i), f = f || {
                    top: m.pageYOffset || g.scrollTop || p.body.scrollTop,
                    left: m.pageXOffset || g.scrollLeft || p.body.scrollLeft
                }; n < d.length; n++)
                if (h.contains(g, r[n][0])) {
                    var o = h(r[n]),
                        a = o[0].offsetHeight,
                        s = o[0].offsetWidth,
                        l = o.offset(),
                        c = o.data("inview");
                    if (!f || !u) return;
                    l.top + a > f.top && l.top < f.top + u.height && l.left + s > f.left && l.left < f.left + u.width ? c || o.data("inview", !0).trigger("inview", [!0]) : c && o.data("inview", !1).trigger("inview", [!1])
                }
        }
    }
    h.event.special.inview = {
        add: function (e) {
            d.push({
                data: e,
                $element: h(this),
                element: this
            }), !n && d.length && (n = setInterval(t, 250))
        },
        remove: function (e) {
            for (var t = 0; t < d.length; t++) {
                var i = d[t];
                if (i.element === this && i.data.guid === e.guid) {
                    d.splice(t, 1);
                    break
                }
            }
            d.length || (clearInterval(n), n = null)
        }
    }, h(m).bind("scroll resize scrollstop", function () {
        u = f = null
    }), !g.addEventListener && g.attachEvent && g.attachEvent("onfocusin", function () {
        f = null
    })
});
var THREE = {
    REVISION: "66"
};
self.console = self.console || {
        info: function () {},
        log: function () {},
        debug: function () {},
        warn: function () {},
        error: function () {}
    },
    function () {
        for (var r = 0, e = ["ms", "moz", "webkit", "o"], t = 0; t < e.length && !self.requestAnimationFrame; ++t) self.requestAnimationFrame = self[e[t] + "RequestAnimationFrame"], self.cancelAnimationFrame = self[e[t] + "CancelAnimationFrame"] || self[e[t] + "CancelRequestAnimationFrame"];
        void 0 === self.requestAnimationFrame && void 0 !== self.setTimeout && (self.requestAnimationFrame = function (e) {
            var t = Date.now(),
                i = Math.max(0, 16 - (t - r)),
                n = self.setTimeout(function () {
                    e(t + i)
                }, i);
            return r = t + i, n
        }), void 0 === self.cancelAnimationFrame && void 0 !== self.clearTimeout && (self.cancelAnimationFrame = function (e) {
            self.clearTimeout(e)
        })
    }(), THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, THREE.DoubleSide = 2, THREE.NoShading = 0, THREE.FlatShading = 1, THREE.SmoothShading = 2, THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, THREE.ReverseSubtractEquation = 102, THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, THREE.SrcAlphaSaturateFactor = 210, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, THREE.AddOperation = 2, THREE.UVMapping = function () {}, THREE.CubeReflectionMapping = function () {}, THREE.CubeRefractionMapping = function () {}, THREE.SphericalReflectionMapping = function () {}, THREE.SphericalRefractionMapping = function () {}, THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023, THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, THREE.Color = function (e) {
        return 3 === arguments.length ? this.setRGB(e, arguments[1], arguments[2]) : this.set(e)
    }, THREE.Color.prototype = {
        constructor: THREE.Color,
        r: 1,
        g: 1,
        b: 1,
        set: function (e) {
            return e instanceof THREE.Color ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        },
        setHex: function (e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        },
        setRGB: function (e, t, i) {
            return this.r = e, this.g = t, this.b = i, this
        },
        setHSL: function (e, t, i) {
            if (0 === t) this.r = this.g = this.b = i;
            else {
                var n = function (e, t, i) {
                    return i < 0 && (i += 1), 1 < i && (i -= 1), i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
                };
                i = 2 * i - (t = i <= .5 ? i * (1 + t) : i + t - i * t), this.r = n(i, t, e + 1 / 3), this.g = n(i, t, e), this.b = n(i, t, e - 1 / 3)
            }
            return this
        },
        setStyle: function (e) {
            return /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(e) ? (e = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(e), this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, this) : /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(e) ? (e = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(e), this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, this) : /^\#([0-9a-f]{6})$/i.test(e) ? (e = /^\#([0-9a-f]{6})$/i.exec(e), this.setHex(parseInt(e[1], 16)), this) : /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e) ? (e = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e), this.setHex(parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3], 16)), this) : /^(\w+)$/i.test(e) ? (this.setHex(THREE.ColorKeywords[e]), this) : void 0
        },
        copy: function (e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        },
        copyGammaToLinear: function (e) {
            return this.r = e.r * e.r, this.g = e.g * e.g, this.b = e.b * e.b, this
        },
        copyLinearToGamma: function (e) {
            return this.r = Math.sqrt(e.r), this.g = Math.sqrt(e.g), this.b = Math.sqrt(e.b), this
        },
        convertGammaToLinear: function () {
            var e = this.r,
                t = this.g,
                i = this.b;
            return this.r = e * e, this.g = t * t, this.b = i * i, this
        },
        convertLinearToGamma: function () {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
        },
        getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function (e) {
            e = e || {
                h: 0,
                s: 0,
                l: 0
            };
            var t, i = this.r,
                n = this.g,
                r = this.b,
                o = Math.max(i, n, r),
                a = ((l = Math.min(i, n, r)) + o) / 2;
            if (l === o) l = t = 0;
            else {
                var s = o - l,
                    l = a <= .5 ? s / (o + l) : s / (2 - o - l);
                switch (o) {
                    case i:
                        t = (n - r) / s + (n < r ? 6 : 0);
                        break;
                    case n:
                        t = (r - i) / s + 2;
                        break;
                    case r:
                        t = (i - n) / s + 4
                }
                t /= 6
            }
            return e.h = t, e.s = l, e.l = a, e
        },
        getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function (e, t, i) {
            var n = this.getHSL();
            return n.h += e, n.s += t, n.l += i, this.setHSL(n.h, n.s, n.l), this
        },
        add: function (e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        },
        addColors: function (e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        },
        addScalar: function (e) {
            return this.r += e, this.g += e, this.b += e, this
        },
        multiply: function (e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        },
        multiplyScalar: function (e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        },
        lerp: function (e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        },
        equals: function (e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function (e) {
            return this.r = e[0], this.g = e[1], this.b = e[2], this
        },
        toArray: function () {
            return [this.r, this.g, this.b]
        },
        clone: function () {
            return (new THREE.Color).setRGB(this.r, this.g, this.b)
        }
    }, THREE.ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, THREE.Quaternion = function (e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
    }, THREE.Quaternion.prototype = {
        constructor: THREE.Quaternion,
        _x: 0,
        _y: 0,
        _z: 0,
        _w: 0,
        _euler: void 0,
        _updateEuler: function (e) {
            void 0 !== this._euler && this._euler.setFromQuaternion(this, void 0, !1)
        },
        get x() {
            return this._x
        },
        set x(e) {
            this._x = e, this._updateEuler()
        },
        get y() {
            return this._y
        },
        set y(e) {
            this._y = e, this._updateEuler()
        },
        get z() {
            return this._z
        },
        set z(e) {
            this._z = e, this._updateEuler()
        },
        get w() {
            return this._w
        },
        set w(e) {
            this._w = e, this._updateEuler()
        },
        set: function (e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._w = n, this._updateEuler(), this
        },
        copy: function (e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._w = e._w, this._updateEuler(), this
        },
        setFromEuler: function (e, t) {
            if (!1 == e instanceof THREE.Euler) throw Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
            var i = Math.cos(e._x / 2),
                n = Math.cos(e._y / 2),
                r = Math.cos(e._z / 2),
                o = Math.sin(e._x / 2),
                a = Math.sin(e._y / 2),
                s = Math.sin(e._z / 2);
            return "XYZ" === e.order ? (this._x = o * n * r + i * a * s, this._y = i * a * r - o * n * s, this._z = i * n * s + o * a * r, this._w = i * n * r - o * a * s) : "YXZ" === e.order ? (this._x = o * n * r + i * a * s, this._y = i * a * r - o * n * s, this._z = i * n * s - o * a * r, this._w = i * n * r + o * a * s) : "ZXY" === e.order ? (this._x = o * n * r - i * a * s, this._y = i * a * r + o * n * s, this._z = i * n * s + o * a * r, this._w = i * n * r - o * a * s) : "ZYX" === e.order ? (this._x = o * n * r - i * a * s, this._y = i * a * r + o * n * s, this._z = i * n * s - o * a * r, this._w = i * n * r + o * a * s) : "YZX" === e.order ? (this._x = o * n * r + i * a * s, this._y = i * a * r + o * n * s, this._z = i * n * s - o * a * r, this._w = i * n * r - o * a * s) : "XZY" === e.order && (this._x = o * n * r - i * a * s, this._y = i * a * r - o * n * s, this._z = i * n * s + o * a * r, this._w = i * n * r + o * a * s), !1 !== t && this._updateEuler(), this
        },
        setFromAxisAngle: function (e, t) {
            var i = t / 2,
                n = Math.sin(i);
            return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._updateEuler(), this
        },
        setFromRotationMatrix: function (e) {
            var t = (i = e.elements)[0];
            e = i[4];
            var i, n = i[8],
                r = i[1],
                o = i[5],
                a = i[9],
                s = i[2],
                l = i[6],
                c = t + o + (i = i[10]);
            return this._z = 0 < c ? (t = .5 / Math.sqrt(c + 1), this._w = .25 / t, this._x = (l - a) * t, this._y = (n - s) * t, (r - e) * t) : o < t && i < t ? (t = 2 * Math.sqrt(1 + t - o - i), this._w = (l - a) / t, this._x = .25 * t, this._y = (e + r) / t, (n + s) / t) : i < o ? (t = 2 * Math.sqrt(1 + o - t - i), this._w = (n - s) / t, this._x = (e + r) / t, this._y = .25 * t, (a + l) / t) : (t = 2 * Math.sqrt(1 + i - t - o), this._w = (r - e) / t, this._x = (n + s) / t, this._y = (a + l) / t, .25 * t), this._updateEuler(), this
        },
        inverse: function () {
            return this.conjugate().normalize(), this
        },
        conjugate: function () {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._updateEuler(), this
        },
        lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function () {
            var e = this.length();
            return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this
        },
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        multiplyQuaternions: function (e, t) {
            var i = e._x,
                n = e._y,
                r = e._z,
                o = e._w,
                a = t._x,
                s = t._y,
                l = t._z,
                c = t._w;
            return this._x = i * c + o * a + n * l - r * s, this._y = n * c + o * s + r * a - i * l, this._z = r * c + o * l + i * s - n * a, this._w = o * c - i * a - n * s - r * l, this._updateEuler(), this
        },
        multiplyVector3: function (e) {
            return console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
        },
        slerp: function (e, t) {
            var i = this._x,
                n = this._y,
                r = this._z,
                o = this._w,
                a = o * e._w + i * e._x + n * e._y + r * e._z;
            if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), 1 <= a) return this._w = o, this._x = i, this._y = n, this._z = r, this;
            var s = Math.acos(a),
                l = Math.sqrt(1 - a * a);
            return Math.abs(l) < .001 ? (this._w = .5 * (o + this._w), this._x = .5 * (i + this._x), this._y = .5 * (n + this._y), this._z = .5 * (r + this._z)) : (a = Math.sin((1 - t) * s) / l, s = Math.sin(t * s) / l, this._w = o * a + this._w * s, this._x = i * a + this._x * s, this._y = n * a + this._y * s, this._z = r * a + this._z * s, this._updateEuler()), this
        },
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function (e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], this._w = e[3], this._updateEuler(), this
        },
        toArray: function () {
            return [this._x, this._y, this._z, this._w]
        },
        clone: function () {
            return new THREE.Quaternion(this._x, this._y, this._z, this._w)
        }
    }, THREE.Quaternion.slerp = function (e, t, i, n) {
        return i.copy(e).slerp(t, n)
    }, THREE.Vector2 = function (e, t) {
        this.x = e || 0, this.y = t || 0
    }, THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        set: function (e, t) {
            return this.x = e, this.y = t, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this
        },
        divideScalar: function (e) {
            return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e) : this.y = this.x = 0, this
        },
        min: function (e) {
            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this
        },
        max: function (e) {
            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this
        },
        clamp: function (e, t) {
            return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this
        },
        clampScalar: function () {
            var i, n;
            return function (e, t) {
                return void 0 === i && (i = new THREE.Vector2, n = new THREE.Vector2), i.set(e, e), n.set(t, t), this.clamp(i, n)
            }
        }(),
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function () {
            return this.multiplyScalar(-1)
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        normalize: function () {
            return this.divideScalar(this.length())
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x;
            return t * t + (e = this.y - e.y) * e
        },
        setLength: function (e) {
            var t = this.length();
            return 0 !== t && e !== t && this.multiplyScalar(e / t), this
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function (e) {
            return this.x = e[0], this.y = e[1], this
        },
        toArray: function () {
            return [this.x, this.y]
        },
        clone: function () {
            return new THREE.Vector2(this.x, this.y)
        }
    }, THREE.Vector3 = function (e, t, i) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0
    }, THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        set: function (e, t, i) {
            return this.x = e, this.y = t, this.z = i, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setZ: function (e) {
            return this.z = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        },
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        },
        multiplyVectors: function (e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        },
        applyEuler: function () {
            var t;
            return function (e) {
                return !1 == e instanceof THREE.Euler && console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code."), void 0 === t && (t = new THREE.Quaternion), this.applyQuaternion(t.setFromEuler(e)), this
            }
        }(),
        applyAxisAngle: function () {
            var i;
            return function (e, t) {
                return void 0 === i && (i = new THREE.Quaternion), this.applyQuaternion(i.setFromAxisAngle(e, t)), this
            }
        }(),
        applyMatrix3: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[3] * i + e[6] * n, this.y = e[1] * t + e[4] * i + e[7] * n, this.z = e[2] * t + e[5] * i + e[8] * n, this
        },
        applyMatrix4: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n + e[12], this.y = e[1] * t + e[5] * i + e[9] * n + e[13], this.z = e[2] * t + e[6] * i + e[10] * n + e[14], this
        },
        applyProjection: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = 1 / ((e = e.elements)[3] * t + e[7] * i + e[11] * n + e[15]);
            return this.x = (e[0] * t + e[4] * i + e[8] * n + e[12]) * r, this.y = (e[1] * t + e[5] * i + e[9] * n + e[13]) * r, this.z = (e[2] * t + e[6] * i + e[10] * n + e[14]) * r, this
        },
        applyQuaternion: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = e.x,
                o = e.y,
                a = e.z,
                s = (e = e.w) * t + o * n - a * i,
                l = e * i + a * t - r * n,
                c = e * n + r * i - o * t;
            t = -r * t - o * i - a * n;
            return this.x = s * e + t * -r + l * -a - c * -o, this.y = l * e + t * -o + c * -r - s * -a, this.z = c * e + t * -a + s * -o - l * -r, this
        },
        transformDirection: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n, this.y = e[1] * t + e[5] * i + e[9] * n, this.z = e[2] * t + e[6] * i + e[10] * n, this.normalize(), this
        },
        divide: function (e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        },
        divideScalar: function (e) {
            return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e) : this.z = this.y = this.x = 0, this
        },
        min: function (e) {
            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this
        },
        max: function (e) {
            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this
        },
        clamp: function (e, t) {
            return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this
        },
        clampScalar: function () {
            var i, n;
            return function (e, t) {
                return void 0 === i && (i = new THREE.Vector3, n = new THREE.Vector3), i.set(e, e, e), n.set(t, t, t), this.clamp(i, n)
            }
        }(),
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function () {
            return this.multiplyScalar(-1)
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function () {
            return this.divideScalar(this.length())
        },
        setLength: function (e) {
            var t = this.length();
            return 0 !== t && e !== t && this.multiplyScalar(e / t), this
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        },
        cross: function (e, t) {
            if (void 0 !== t) return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
            var i = this.x,
                n = this.y,
                r = this.z;
            return this.x = n * e.z - r * e.y, this.y = r * e.x - i * e.z, this.z = i * e.y - n * e.x, this
        },
        crossVectors: function (e, t) {
            var i = e.x,
                n = e.y,
                r = e.z,
                o = t.x,
                a = t.y,
                s = t.z;
            return this.x = n * s - r * a, this.y = r * o - i * s, this.z = i * a - n * o, this
        },
        projectOnVector: function () {
            var t, i;
            return function (e) {
                return void 0 === t && (t = new THREE.Vector3), t.copy(e).normalize(), i = this.dot(t), this.copy(t).multiplyScalar(i)
            }
        }(),
        projectOnPlane: function () {
            var t;
            return function (e) {
                return void 0 === t && (t = new THREE.Vector3), t.copy(this).projectOnVector(e), this.sub(t)
            }
        }(),
        reflect: function () {
            var t;
            return function (e) {
                return void 0 === t && (t = new THREE.Vector3), this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        }(),
        angleTo: function (e) {
            return e = this.dot(e) / (this.length() * e.length()), Math.acos(THREE.Math.clamp(e, -1, 1))
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x,
                i = this.y - e.y;
            return t * t + i * i + (e = this.z - e.z) * e
        },
        setEulerFromRotationMatrix: function (e, t) {
            console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.")
        },
        setEulerFromQuaternion: function (e, t) {
            console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.")
        },
        getPositionFromMatrix: function (e) {
            return console.warn("DEPRECATED: Vector3's .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function (e) {
            return console.warn("DEPRECATED: Vector3's .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function (e, t) {
            return console.warn("DEPRECATED: Vector3's .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code."), this.setFromMatrixColumn(e, t)
        },
        setFromMatrixPosition: function (e) {
            return this.x = e.elements[12], this.y = e.elements[13], this.z = e.elements[14], this
        },
        setFromMatrixScale: function (e) {
            var t = this.set(e.elements[0], e.elements[1], e.elements[2]).length(),
                i = this.set(e.elements[4], e.elements[5], e.elements[6]).length();
            return e = this.set(e.elements[8], e.elements[9], e.elements[10]).length(), this.x = t, this.y = i, this.z = e, this
        },
        setFromMatrixColumn: function (e, t) {
            var i = 4 * e,
                n = t.elements;
            return this.x = n[i], this.y = n[i + 1], this.z = n[i + 2], this
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function (e) {
            return this.x = e[0], this.y = e[1], this.z = e[2], this
        },
        toArray: function () {
            return [this.x, this.y, this.z]
        },
        clone: function () {
            return new THREE.Vector3(this.x, this.y, this.z)
        }
    }, THREE.Vector4 = function (e, t, i, n) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
    }, THREE.Vector4.prototype = {
        constructor: THREE.Vector4,
        set: function (e, t, i, n) {
            return this.x = e, this.y = t, this.z = i, this.w = n, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setZ: function (e) {
            return this.z = e, this
        },
        setW: function (e) {
            return this.w = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        },
        applyMatrix4: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = this.w;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n + e[12] * r, this.y = e[1] * t + e[5] * i + e[9] * n + e[13] * r, this.z = e[2] * t + e[6] * i + e[10] * n + e[14] * r, this.w = e[3] * t + e[7] * i + e[11] * n + e[15] * r, this
        },
        divideScalar: function (e) {
            return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e) : (this.z = this.y = this.x = 0, this.w = 1), this
        },
        setAxisAngleFromQuaternion: function (e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return this.z = t < 1e-4 ? (this.x = 1, this.y = 0) : (this.x = e.x / t, this.y = e.y / t, e.z / t), this
        },
        setAxisAngleFromRotationMatrix: function (e) {
            var t, i, n, r = (e = e.elements)[0];
            n = e[4];
            var o = e[8],
                a = e[1],
                s = e[5],
                l = e[9];
            i = e[2], t = e[6];
            var c = e[10];
            return Math.abs(n - a) < .01 && Math.abs(o - i) < .01 && Math.abs(l - t) < .01 ? Math.abs(n + a) < .1 && Math.abs(o + i) < .1 && Math.abs(l + t) < .1 && Math.abs(r + s + c - 3) < .1 ? this.set(1, 0, 0, 0) : (e = Math.PI, c = (c + 1) / 2, n = (n + a) / 4, o = (o + i) / 4, l = (l + t) / 4, (s = (s + 1) / 2) < (r = (r + 1) / 2) && c < r ? n = r < .01 ? (t = 0, i = .707106781) : (i = n / (t = Math.sqrt(r)), o / t) : c < s ? n = s < .01 ? (i = 0, t = .707106781) : (t = n / (i = Math.sqrt(s)), l / i) : c < .01 ? (i = t = .707106781, n = 0) : (t = o / (n = Math.sqrt(c)), i = l / n), this.set(t, i, n, e)) : (e = Math.sqrt((t - l) * (t - l) + (o - i) * (o - i) + (a - n) * (a - n)), Math.abs(e) < .001 && (e = 1), this.x = (t - l) / e, this.y = (o - i) / e, this.z = (a - n) / e, this.w = Math.acos((r + s + c - 1) / 2)), this
        },
        min: function (e) {
            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this.w > e.w && (this.w = e.w), this
        },
        max: function (e) {
            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this.w < e.w && (this.w = e.w), this
        },
        clamp: function (e, t) {
            return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this.w < e.w ? this.w = e.w : this.w > t.w && (this.w = t.w), this
        },
        clampScalar: function () {
            var i, n;
            return function (e, t) {
                return void 0 === i && (i = new THREE.Vector4, n = new THREE.Vector4), i.set(e, e, e, e), n.set(t, t, t, t), this.clamp(i, n)
            }
        }(),
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function () {
            return this.multiplyScalar(-1)
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function () {
            return this.divideScalar(this.length())
        },
        setLength: function (e) {
            var t = this.length();
            return 0 !== t && e !== t && this.multiplyScalar(e / t), this
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function (e) {
            return this.x = e[0], this.y = e[1], this.z = e[2], this.w = e[3], this
        },
        toArray: function () {
            return [this.x, this.y, this.z, this.w]
        },
        clone: function () {
            return new THREE.Vector4(this.x, this.y, this.z, this.w)
        }
    }, THREE.Euler = function (e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || THREE.Euler.DefaultOrder
    }, THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), THREE.Euler.DefaultOrder = "XYZ", THREE.Euler.prototype = {
        constructor: THREE.Euler,
        _x: 0,
        _y: 0,
        _z: 0,
        _order: THREE.Euler.DefaultOrder,
        _quaternion: void 0,
        _updateQuaternion: function () {
            void 0 !== this._quaternion && this._quaternion.setFromEuler(this, !1)
        },
        get x() {
            return this._x
        },
        set x(e) {
            this._x = e, this._updateQuaternion()
        },
        get y() {
            return this._y
        },
        set y(e) {
            this._y = e, this._updateQuaternion()
        },
        get z() {
            return this._z
        },
        set z(e) {
            this._z = e, this._updateQuaternion()
        },
        get order() {
            return this._order
        },
        set order(e) {
            this._order = e, this._updateQuaternion()
        },
        set: function (e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this._updateQuaternion(), this
        },
        copy: function (e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._updateQuaternion(), this
        },
        setFromRotationMatrix: function (e, t) {
            function i(e) {
                return Math.min(Math.max(e, -1), 1)
            }
            var n = (u = e.elements)[0],
                r = u[4],
                o = u[8],
                a = u[1],
                s = u[5],
                l = u[9],
                c = u[2],
                h = u[6],
                u = u[10];
            return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(i(o)), Math.abs(o) < .99999 ? (this._x = Math.atan2(-l, u), this._z = Math.atan2(-r, n)) : (this._x = Math.atan2(h, s), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-i(l)), Math.abs(l) < .99999 ? (this._y = Math.atan2(o, u), this._z = Math.atan2(a, s)) : (this._y = Math.atan2(-c, n), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(i(h)), Math.abs(h) < .99999 ? (this._y = Math.atan2(-c, u), this._z = Math.atan2(-r, s)) : (this._y = 0, this._z = Math.atan2(a, n))) : "ZYX" === t ? (this._y = Math.asin(-i(c)), Math.abs(c) < .99999 ? (this._x = Math.atan2(h, u), this._z = Math.atan2(a, n)) : (this._x = 0, this._z = Math.atan2(-r, s))) : "YZX" === t ? (this._z = Math.asin(i(a)), Math.abs(a) < .99999 ? (this._x = Math.atan2(-l, s), this._y = Math.atan2(-c, n)) : (this._x = 0, this._y = Math.atan2(o, u))) : "XZY" === t ? (this._z = Math.asin(-i(r)), Math.abs(r) < .99999 ? (this._x = Math.atan2(h, s), this._y = Math.atan2(o, n)) : (this._x = Math.atan2(-l, u), this._y = 0)) : console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + t), this._order = t, this._updateQuaternion(), this
        },
        setFromQuaternion: function (e, t, i) {
            function n(e) {
                return Math.min(Math.max(e, -1), 1)
            }
            var r = e.x * e.x,
                o = e.y * e.y,
                a = e.z * e.z,
                s = e.w * e.w;
            return "XYZ" === (t = t || this._order) ? (this._x = Math.atan2(2 * (e.x * e.w - e.y * e.z), s - r - o + a), this._y = Math.asin(n(2 * (e.x * e.z + e.y * e.w))), this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), s + r - o - a)) : "YXZ" === t ? (this._x = Math.asin(n(2 * (e.x * e.w - e.y * e.z))), this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), s - r - o + a), this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), s - r + o - a)) : "ZXY" === t ? (this._x = Math.asin(n(2 * (e.x * e.w + e.y * e.z))), this._y = Math.atan2(2 * (e.y * e.w - e.z * e.x), s - r - o + a), this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), s - r + o - a)) : "ZYX" === t ? (this._x = Math.atan2(2 * (e.x * e.w + e.z * e.y), s - r - o + a), this._y = Math.asin(n(2 * (e.y * e.w - e.x * e.z))), this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), s + r - o - a)) : "YZX" === t ? (this._x = Math.atan2(2 * (e.x * e.w - e.z * e.y), s - r + o - a), this._y = Math.atan2(2 * (e.y * e.w - e.x * e.z), s + r - o - a), this._z = Math.asin(n(2 * (e.x * e.y + e.z * e.w)))) : "XZY" === t ? (this._x = Math.atan2(2 * (e.x * e.w + e.y * e.z), s - r + o - a), this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), s + r - o - a), this._z = Math.asin(n(2 * (e.z * e.w - e.x * e.y)))) : console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " + t), this._order = t, !1 !== i && this._updateQuaternion(), this
        },
        reorder: function () {
            var t = new THREE.Quaternion;
            return function (e) {
                t.setFromEuler(this), this.setFromQuaternion(t, e)
            }
        }(),
        fromArray: function (e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._updateQuaternion(), this
        },
        toArray: function () {
            return [this._x, this._y, this._z, this._order]
        },
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        clone: function () {
            return new THREE.Euler(this._x, this._y, this._z, this._order)
        }
    }, THREE.Line3 = function (e, t) {
        this.start = void 0 !== e ? e : new THREE.Vector3, this.end = void 0 !== t ? t : new THREE.Vector3
    }, THREE.Line3.prototype = {
        constructor: THREE.Line3,
        set: function (e, t) {
            return this.start.copy(e), this.end.copy(t), this
        },
        copy: function (e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        },
        center: function (e) {
            return (e || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function (e) {
            return (e || new THREE.Vector3).subVectors(this.end, this.start)
        },
        distanceSq: function () {
            return this.start.distanceToSquared(this.end)
        },
        distance: function () {
            return this.start.distanceTo(this.end)
        },
        at: function (e, t) {
            var i = t || new THREE.Vector3;
            return this.delta(i).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function () {
            var n = new THREE.Vector3,
                r = new THREE.Vector3;
            return function (e, t) {
                n.subVectors(e, this.start), r.subVectors(this.end, this.start);
                var i = r.dot(r);
                i = r.dot(n) / i;
                return t && (i = THREE.Math.clamp(i, 0, 1)), i
            }
        }(),
        closestPointToPoint: function (e, t, i) {
            return e = this.closestPointToPointParameter(e, t), i = i || new THREE.Vector3, this.delta(i).multiplyScalar(e).add(this.start)
        },
        applyMatrix4: function (e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        },
        equals: function (e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        },
        clone: function () {
            return (new THREE.Line3).copy(this)
        }
    }, THREE.Box2 = function (e, t) {
        this.min = void 0 !== e ? e : new THREE.Vector2(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new THREE.Vector2(-1 / 0, -1 / 0)
    }, THREE.Box2.prototype = {
        constructor: THREE.Box2,
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function (e) {
            if (0 < e.length) {
                var t = e[0];
                this.min.copy(t), this.max.copy(t);
                for (var i = 1, n = e.length; i < n; i++)(t = e[i]).x < this.min.x ? this.min.x = t.x : t.x > this.max.x && (this.max.x = t.x), t.y < this.min.y ? this.min.y = t.y : t.y > this.max.y && (this.max.y = t.y)
            } else this.makeEmpty();
            return this
        },
        setFromCenterAndSize: function () {
            var n = new THREE.Vector2;
            return function (e, t) {
                var i = n.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
            }
        }(),
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        empty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        center: function (e) {
            return (e || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function (e) {
            return (e || new THREE.Vector2).subVectors(this.max, this.min)
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function (e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function (e, t) {
            return (t || new THREE.Vector2).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        isIntersectionBox: function (e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function (e, t) {
            return (t || new THREE.Vector2).copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function () {
            var t = new THREE.Vector2;
            return function (e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        },
        clone: function () {
            return (new THREE.Box2).copy(this)
        }
    }, THREE.Box3 = function (e, t) {
        this.min = void 0 !== e ? e : new THREE.Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0)
    }, THREE.Box3.prototype = {
        constructor: THREE.Box3,
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        addPoint: function (e) {
            e.x < this.min.x ? this.min.x = e.x : e.x > this.max.x && (this.max.x = e.x), e.y < this.min.y ? this.min.y = e.y : e.y > this.max.y && (this.max.y = e.y), e.z < this.min.z ? this.min.z = e.z : e.z > this.max.z && (this.max.z = e.z)
        },
        setFromPoints: function (e) {
            if (0 < e.length) {
                var t = e[0];
                this.min.copy(t), this.max.copy(t);
                t = 1;
                for (var i = e.length; t < i; t++) this.addPoint(e[t])
            } else this.makeEmpty();
            return this
        },
        setFromCenterAndSize: function () {
            var n = new THREE.Vector3;
            return function (e, t) {
                var i = n.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
            }
        }(),
        setFromObject: function () {
            var o = new THREE.Vector3;
            return function (e) {
                var r = this;
                return e.updateMatrixWorld(!0), this.makeEmpty(), e.traverse(function (e) {
                    if (void 0 !== e.geometry && void 0 !== e.geometry.vertices)
                        for (var t = e.geometry.vertices, i = 0, n = t.length; i < n; i++) o.copy(t[i]), o.applyMatrix4(e.matrixWorld), r.expandByPoint(o)
                }), this
            }
        }(),
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        empty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        center: function (e) {
            return (e || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function (e) {
            return (e || new THREE.Vector3).subVectors(this.max, this.min)
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function (e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function (e, t) {
            return (t || new THREE.Vector3).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        isIntersectionBox: function (e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        clampPoint: function (e, t) {
            return (t || new THREE.Vector3).copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function () {
            var t = new THREE.Vector3;
            return function (e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        getBoundingSphere: function () {
            var t = new THREE.Vector3;
            return function (e) {
                return (e = e || new THREE.Sphere).center = this.center(), e.radius = .5 * this.size(t).length(), e
            }
        }(),
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        applyMatrix4: function () {
            var t = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
            return function (e) {
                return t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.makeEmpty(), this.setFromPoints(t), this
            }
        }(),
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        },
        clone: function () {
            return (new THREE.Box3).copy(this)
        }
    }, THREE.Matrix3 = function (e, t, i, n, r, o, a, s, l) {
        this.elements = new Float32Array(9), this.set(void 0 !== e ? e : 1, t || 0, i || 0, n || 0, void 0 !== r ? r : 1, o || 0, a || 0, s || 0, void 0 !== l ? l : 1)
    }, THREE.Matrix3.prototype = {
        constructor: THREE.Matrix3,
        set: function (e, t, i, n, r, o, a, s, l) {
            var c = this.elements;
            return c[0] = e, c[3] = t, c[6] = i, c[1] = n, c[4] = r, c[7] = o, c[2] = a, c[5] = s, c[8] = l, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        copy: function (e) {
            return e = e.elements, this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]), this
        },
        multiplyVector3: function (e) {
            return console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function () {
            var n = new THREE.Vector3;
            return function (e) {
                for (var t = 0, i = e.length; t < i; t += 3) n.x = e[t], n.y = e[t + 1], n.z = e[t + 2], n.applyMatrix3(this), e[t] = n.x, e[t + 1] = n.y, e[t + 2] = n.z;
                return e
            }
        }(),
        multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        },
        determinant: function () {
            var e, t = (e = this.elements)[0],
                i = e[1],
                n = e[2],
                r = e[3],
                o = e[4],
                a = e[5],
                s = e[6],
                l = e[7];
            return t * o * (e = e[8]) - t * a * l - i * r * e + i * a * s + n * r * l - n * o * s
        },
        getInverse: function (e, t) {
            var i = e.elements,
                n = this.elements;
            if (n[0] = i[10] * i[5] - i[6] * i[9], n[1] = -i[10] * i[1] + i[2] * i[9], n[2] = i[6] * i[1] - i[2] * i[5], n[3] = -i[10] * i[4] + i[6] * i[8], n[4] = i[10] * i[0] - i[2] * i[8], n[5] = -i[6] * i[0] + i[2] * i[4], n[6] = i[9] * i[4] - i[5] * i[8], n[7] = -i[9] * i[0] + i[1] * i[8], n[8] = i[5] * i[0] - i[1] * i[4], 0 != (i = i[0] * n[0] + i[1] * n[3] + i[2] * n[6])) return this.multiplyScalar(1 / i), this;
            if (t) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
            return console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
        },
        transpose: function () {
            var e, t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        },
        getNormalMatrix: function (e) {
            return this.getInverse(e).transpose(), this
        },
        transposeIntoArray: function (e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        },
        fromArray: function (e) {
            return this.elements.set(e), this
        },
        toArray: function () {
            var e = this.elements;
            return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
        },
        clone: function () {
            var e = this.elements;
            return new THREE.Matrix3(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8])
        }
    }, THREE.Matrix4 = function (e, t, i, n, r, o, a, s, l, c, h, u, f, d, p, m) {
        var g = this.elements = new Float32Array(16);
        g[0] = void 0 !== e ? e : 1, g[4] = t || 0, g[8] = i || 0, g[12] = n || 0, g[1] = r || 0, g[5] = void 0 !== o ? o : 1, g[9] = a || 0, g[13] = s || 0, g[2] = l || 0, g[6] = c || 0, g[10] = void 0 !== h ? h : 1, g[14] = u || 0, g[3] = f || 0, g[7] = d || 0, g[11] = p || 0, g[15] = void 0 !== m ? m : 1
    }, THREE.Matrix4.prototype = {
        constructor: THREE.Matrix4,
        set: function (e, t, i, n, r, o, a, s, l, c, h, u, f, d, p, m) {
            var g = this.elements;
            return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = f, g[7] = d, g[11] = p, g[15] = m, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        copy: function (e) {
            return this.elements.set(e.elements), this
        },
        extractPosition: function (e) {
            return console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        copyPosition: function (e) {
            var t = this.elements;
            return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
        },
        extractRotation: function () {
            var o = new THREE.Vector3;
            return function (e) {
                var t = this.elements;
                e = e.elements;
                var i = 1 / o.set(e[0], e[1], e[2]).length(),
                    n = 1 / o.set(e[4], e[5], e[6]).length(),
                    r = 1 / o.set(e[8], e[9], e[10]).length();
                return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[8] = e[8] * r, t[9] = e[9] * r, t[10] = e[10] * r, this
            }
        }(),
        makeRotationFromEuler: function (e) {
            !1 == e instanceof THREE.Euler && console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
            var t = this.elements,
                i = e.x,
                n = e.y,
                r = e.z,
                o = Math.cos(i),
                a = (i = Math.sin(i), Math.cos(n)),
                s = (n = Math.sin(n), Math.cos(r));
            r = Math.sin(r);
            if ("XYZ" === e.order) {
                e = o * s;
                var l = o * r,
                    c = i * s,
                    h = i * r;
                t[0] = a * s, t[4] = -a * r, t[8] = n, t[1] = l + c * n, t[5] = e - h * n, t[9] = -i * a, t[2] = h - e * n, t[6] = c + l * n, t[10] = o * a
            } else "YXZ" === e.order ? (e = a * s, l = a * r, c = n * s, h = n * r, t[0] = e + h * i, t[4] = c * i - l, t[8] = o * n, t[1] = o * r, t[5] = o * s, t[9] = -i, t[2] = l * i - c, t[6] = h + e * i, t[10] = o * a) : "ZXY" === e.order ? (e = a * s, l = a * r, c = n * s, h = n * r, t[0] = e - h * i, t[4] = -o * r, t[8] = c + l * i, t[1] = l + c * i, t[5] = o * s, t[9] = h - e * i, t[2] = -o * n, t[6] = i, t[10] = o * a) : "ZYX" === e.order ? (e = o * s, l = o * r, c = i * s, h = i * r, t[0] = a * s, t[4] = c * n - l, t[8] = e * n + h, t[1] = a * r, t[5] = h * n + e, t[9] = l * n - c, t[2] = -n, t[6] = i * a, t[10] = o * a) : "YZX" === e.order ? (e = o * a, l = o * n, c = i * a, h = i * n, t[0] = a * s, t[4] = h - e * r, t[8] = c * r + l, t[1] = r, t[5] = o * s, t[9] = -i * s, t[2] = -n * s, t[6] = l * r + c, t[10] = e - h * r) : "XZY" === e.order && (e = o * a, l = o * n, c = i * a, h = i * n, t[0] = a * s, t[4] = -r, t[8] = n * s, t[1] = e * r + h, t[5] = o * s, t[9] = l * r - c, t[2] = c * r - l, t[6] = i * s, t[10] = h * r + e);
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        setRotationFromQuaternion: function (e) {
            return console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code."), this.makeRotationFromQuaternion(e)
        },
        makeRotationFromQuaternion: function (e) {
            var t = this.elements,
                i = e.x,
                n = e.y,
                r = e.z,
                o = e.w,
                a = r + r;
            e = i * (c = i + i);
            var s = i * (h = n + n),
                l = (i = i * a, n * h),
                c = (n = n * a, r = r * a, o * c),
                h = o * h;
            o *= a;
            return t[0] = 1 - (l + r), t[4] = s - o, t[8] = i + h, t[1] = s + o, t[5] = 1 - (e + r), t[9] = n - c, t[2] = i - h, t[6] = n + c, t[10] = 1 - (e + l), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        lookAt: function () {
            var r = new THREE.Vector3,
                o = new THREE.Vector3,
                a = new THREE.Vector3;
            return function (e, t, i) {
                var n = this.elements;
                return a.subVectors(e, t).normalize(), 0 === a.length() && (a.z = 1), r.crossVectors(i, a).normalize(), 0 === r.length() && (a.x += 1e-4, r.crossVectors(i, a).normalize()), o.crossVectors(a, r), n[0] = r.x, n[4] = o.x, n[8] = a.x, n[1] = r.y, n[5] = o.y, n[9] = a.y, n[2] = r.z, n[6] = o.z, n[10] = a.z, this
            }
        }(),
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        multiplyMatrices: function (e, t) {
            var i = e.elements,
                n = t.elements,
                r = this.elements,
                o = i[0],
                a = i[4],
                s = i[8],
                l = i[12],
                c = i[1],
                h = i[5],
                u = i[9],
                f = i[13],
                d = i[2],
                p = i[6],
                m = i[10],
                g = i[14],
                E = i[3],
                v = i[7],
                y = i[11],
                T = (i = i[15], n[0]),
                b = n[4],
                x = n[8],
                R = n[12],
                w = n[1],
                _ = n[5],
                H = n[9],
                S = n[13],
                M = n[2],
                C = n[6],
                A = n[10],
                P = n[14],
                L = n[3],
                D = n[7],
                z = n[11];
            n = n[15];
            return r[0] = o * T + a * w + s * M + l * L, r[4] = o * b + a * _ + s * C + l * D, r[8] = o * x + a * H + s * A + l * z, r[12] = o * R + a * S + s * P + l * n, r[1] = c * T + h * w + u * M + f * L, r[5] = c * b + h * _ + u * C + f * D, r[9] = c * x + h * H + u * A + f * z, r[13] = c * R + h * S + u * P + f * n, r[2] = d * T + p * w + m * M + g * L, r[6] = d * b + p * _ + m * C + g * D, r[10] = d * x + p * H + m * A + g * z, r[14] = d * R + p * S + m * P + g * n, r[3] = E * T + v * w + y * M + i * L, r[7] = E * b + v * _ + y * C + i * D, r[11] = E * x + v * H + y * A + i * z, r[15] = E * R + v * S + y * P + i * n, this
        },
        multiplyToArray: function (e, t, i) {
            var n = this.elements;
            return this.multiplyMatrices(e, t), i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this
        },
        multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        },
        multiplyVector3: function (e) {
            return console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), e.applyProjection(this)
        },
        multiplyVector4: function (e) {
            return console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function () {
            var n = new THREE.Vector3;
            return function (e) {
                for (var t = 0, i = e.length; t < i; t += 3) n.x = e[t], n.y = e[t + 1], n.z = e[t + 2], n.applyProjection(this), e[t] = n.x, e[t + 1] = n.y, e[t + 2] = n.z;
                return e
            }
        }(),
        rotateAxis: function (e) {
            console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
        },
        crossVector: function (e) {
            return console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        determinant: function () {
            var e = this.elements,
                t = e[0],
                i = e[4],
                n = e[8],
                r = e[12],
                o = e[1],
                a = e[5],
                s = e[9],
                l = e[13],
                c = e[2],
                h = e[6],
                u = e[10],
                f = e[14];
            return e[3] * (+r * s * h - n * l * h - r * a * u + i * l * u + n * a * f - i * s * f) + e[7] * (+t * s * f - t * l * u + r * o * u - n * o * f + n * l * c - r * s * c) + e[11] * (+t * l * h - t * a * f - r * o * h + i * o * f + r * a * c - i * l * c) + e[15] * (-n * a * c - t * s * h + t * a * u + n * o * h - i * o * u + i * s * c)
        },
        transpose: function () {
            var e, t = this.elements;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        },
        flattenToArray: function (e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
        },
        flattenToArrayOffset: function (e, t) {
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
        },
        getPosition: function () {
            var t = new THREE.Vector3;
            return function () {
                console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                var e = this.elements;
                return t.set(e[12], e[13], e[14])
            }
        }(),
        setPosition: function (e) {
            var t = this.elements;
            return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
        },
        getInverse: function (e, t) {
            var i = this.elements,
                n = (v = e.elements)[0],
                r = v[4],
                o = v[8],
                a = v[12],
                s = v[1],
                l = v[5],
                c = v[9],
                h = v[13],
                u = v[2],
                f = v[6],
                d = v[10],
                p = v[14],
                m = v[3],
                g = v[7],
                E = v[11],
                v = v[15];
            if (i[0] = c * p * g - h * d * g + h * f * E - l * p * E - c * f * v + l * d * v, i[4] = a * d * g - o * p * g - a * f * E + r * p * E + o * f * v - r * d * v, i[8] = o * h * g - a * c * g + a * l * E - r * h * E - o * l * v + r * c * v, i[12] = a * c * f - o * h * f - a * l * d + r * h * d + o * l * p - r * c * p, i[1] = h * d * m - c * p * m - h * u * E + s * p * E + c * u * v - s * d * v, i[5] = o * p * m - a * d * m + a * u * E - n * p * E - o * u * v + n * d * v, i[9] = a * c * m - o * h * m - a * s * E + n * h * E + o * s * v - n * c * v, i[13] = o * h * u - a * c * u + a * s * d - n * h * d - o * s * p + n * c * p, i[2] = l * p * m - h * f * m + h * u * g - s * p * g - l * u * v + s * f * v, i[6] = a * f * m - r * p * m - a * u * g + n * p * g + r * u * v - n * f * v, i[10] = r * h * m - a * l * m + a * s * g - n * h * g - r * s * v + n * l * v, i[14] = a * l * u - r * h * u - a * s * f + n * h * f + r * s * p - n * l * p, i[3] = c * f * m - l * d * m - c * u * g + s * d * g + l * u * E - s * f * E, i[7] = r * d * m - o * f * m + o * u * g - n * d * g - r * u * E + n * f * E, i[11] = o * l * m - r * c * m - o * s * g + n * c * g + r * s * E - n * l * E, i[15] = r * c * u - o * l * u + o * s * f - n * c * f - r * s * d + n * l * d, 0 != (i = n * i[0] + s * i[4] + u * i[8] + m * i[12])) return this.multiplyScalar(1 / i), this;
            if (t) throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
            return console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
        },
        translate: function (e) {
            console.warn("DEPRECATED: Matrix4's .translate() has been removed.")
        },
        rotateX: function (e) {
            console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.")
        },
        rotateY: function (e) {
            console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.")
        },
        rotateZ: function (e) {
            console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.")
        },
        rotateByAxis: function (e, t) {
            console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.")
        },
        scale: function (e) {
            var t = this.elements,
                i = e.x,
                n = e.y;
            return e = e.z, t[0] *= i, t[4] *= n, t[8] *= e, t[1] *= i, t[5] *= n, t[9] *= e, t[2] *= i, t[6] *= n, t[10] *= e, t[3] *= i, t[7] *= n, t[11] *= e, this
        },
        getMaxScaleOnAxis: function () {
            var e = this.elements;
            return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], Math.max(e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10])))
        },
        makeTranslation: function (e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
        },
        makeRotationX: function (e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function (e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function (e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function (e, t) {
            var i = Math.cos(t),
                n = Math.sin(t),
                r = 1 - i,
                o = e.x,
                a = e.y,
                s = e.z,
                l = r * o,
                c = r * a;
            return this.set(l * o + i, l * a - n * s, l * s + n * a, 0, l * a + n * s, c * a + i, c * s - n * o, 0, l * s - n * a, c * s + n * o, r * s * s + i, 0, 0, 0, 0, 1), this
        },
        makeScale: function (e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        },
        compose: function (e, t, i) {
            return this.makeRotationFromQuaternion(t), this.scale(i), this.setPosition(e), this
        },
        decompose: function () {
            var l = new THREE.Vector3,
                c = new THREE.Matrix4;
            return function (e, t, i) {
                var n = this.elements,
                    r = l.set(n[0], n[1], n[2]).length(),
                    o = l.set(n[4], n[5], n[6]).length(),
                    a = l.set(n[8], n[9], n[10]).length();
                this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], c.elements.set(this.elements), e = 1 / r;
                n = 1 / o;
                var s = 1 / a;
                return c.elements[0] *= e, c.elements[1] *= e, c.elements[2] *= e, c.elements[4] *= n, c.elements[5] *= n, c.elements[6] *= n, c.elements[8] *= s, c.elements[9] *= s, c.elements[10] *= s, t.setFromRotationMatrix(c), i.x = r, i.y = o, i.z = a, this
            }
        }(),
        makeFrustum: function (e, t, i, n, r, o) {
            var a = this.elements;
            return a[0] = 2 * r / (t - e), a[4] = 0, a[8] = (t + e) / (t - e), a[12] = 0, a[1] = 0, a[5] = 2 * r / (n - i), a[9] = (n + i) / (n - i), a[13] = 0, a[2] = 0, a[6] = 0, a[10] = -(o + r) / (o - r), a[14] = -2 * o * r / (o - r), a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makePerspective: function (e, t, i, n) {
            var r = -(e = i * Math.tan(THREE.Math.degToRad(.5 * e)));
            return this.makeFrustum(r * t, e * t, r, e, i, n)
        },
        makeOrthographic: function (e, t, i, n, r, o) {
            var a = this.elements,
                s = t - e,
                l = i - n,
                c = o - r;
            return a[0] = 2 / s, a[4] = 0, a[8] = 0, a[12] = -(t + e) / s, a[1] = 0, a[5] = 2 / l, a[9] = 0, a[13] = -(i + n) / l, a[2] = 0, a[6] = 0, a[10] = -2 / c, a[14] = -(o + r) / c, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        fromArray: function (e) {
            return this.elements.set(e), this
        },
        toArray: function () {
            var e = this.elements;
            return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
        },
        clone: function () {
            var e = this.elements;
            return new THREE.Matrix4(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15])
        }
    }, THREE.Ray = function (e, t) {
        this.origin = void 0 !== e ? e : new THREE.Vector3, this.direction = void 0 !== t ? t : new THREE.Vector3
    }, THREE.Ray.prototype = {
        constructor: THREE.Ray,
        set: function (e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        },
        copy: function (e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        },
        at: function (e, t) {
            return (t || new THREE.Vector3).copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        recast: function () {
            var t = new THREE.Vector3;
            return function (e) {
                return this.origin.copy(this.at(e, t)), this
            }
        }(),
        closestPointToPoint: function (e, t) {
            var i = t || new THREE.Vector3;
            i.subVectors(e, this.origin);
            var n = i.dot(this.direction);
            return n < 0 ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function () {
            var i = new THREE.Vector3;
            return function (e) {
                var t = i.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceTo(e) : (i.copy(this.direction).multiplyScalar(t).add(this.origin), i.distanceTo(e))
            }
        }(),
        distanceSqToSegment: function (e, t, i, n) {
            var r = e.clone().add(t).multiplyScalar(.5),
                o = t.clone().sub(e).normalize(),
                a = .5 * e.distanceTo(t),
                s = this.origin.clone().sub(r);
            e = -this.direction.dot(o), t = s.dot(this.direction);
            var l, c, h = -s.dot(o),
                u = s.lengthSq(),
                f = Math.abs(1 - e * e);
            return e = 0 <= f ? (l = e * t - h, c = a * f, 0 <= (s = e * h - t) ? -c <= l ? l <= c ? (s *= a = 1 / f) * (s + e * (l *= a) + 2 * t) + l * (e * s + l + 2 * h) + u : (l = a, -(s = Math.max(0, -(e * l + t))) * s + l * (l + 2 * h) + u) : (l = -a, -(s = Math.max(0, -(e * l + t))) * s + l * (l + 2 * h) + u) : l <= -c ? -(s = Math.max(0, -(-e * a + t))) * s + (l = 0 < s ? -a : Math.min(Math.max(-a, -h), a)) * (l + 2 * h) + u : l <= c ? (s = 0, (l = Math.min(Math.max(-a, -h), a)) * (l + 2 * h) + u) : -(s = Math.max(0, -(e * a + t))) * s + (l = 0 < s ? a : Math.min(Math.max(-a, -h), a)) * (l + 2 * h) + u) : (l = 0 < e ? -a : a, -(s = Math.max(0, -(e * l + t))) * s + l * (l + 2 * h) + u), i && i.copy(this.direction.clone().multiplyScalar(s).add(this.origin)), n && n.copy(o.clone().multiplyScalar(l).add(r)), e
        },
        isIntersectionSphere: function (e) {
            return this.distanceToPoint(e.center) <= e.radius
        },
        isIntersectionPlane: function (e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        },
        distanceToPlane: function (e) {
            var t = e.normal.dot(this.direction);
            return 0 == t ? 0 == e.distanceToPoint(this.origin) ? 0 : null : 0 <= (e = -(this.origin.dot(e.normal) + e.constant) / t) ? e : null
        },
        intersectPlane: function (e, t) {
            var i = this.distanceToPlane(e);
            return null === i ? null : this.at(i, t)
        },
        isIntersectionBox: function () {
            var t = new THREE.Vector3;
            return function (e) {
                return null !== this.intersectBox(e, t)
            }
        }(),
        intersectBox: function (e, t) {
            var i, n, r, o, a;
            n = 1 / this.direction.x, o = 1 / this.direction.y, a = 1 / this.direction.z;
            var s = this.origin;
            return 0 <= n ? (i = (e.min.x - s.x) * n, n *= e.max.x - s.x) : (i = (e.max.x - s.x) * n, n *= e.min.x - s.x), 0 <= o ? (r = (e.min.y - s.y) * o, o *= e.max.y - s.y) : (r = (e.max.y - s.y) * o, o *= e.min.y - s.y), o < i || n < r ? null : ((i < r || i != i) && (i = r), (o < n || n != n) && (n = o), 0 <= a ? (r = (e.min.z - s.z) * a, a *= e.max.z - s.z) : (r = (e.max.z - s.z) * a, a *= e.min.z - s.z), a < i || n < r ? null : ((i < r || i != i) && (i = r), (a < n || n != n) && (n = a), n < 0 ? null : this.at(0 <= i ? i : n, t)))
        },
        intersectTriangle: function () {
            var o = new THREE.Vector3,
                a = new THREE.Vector3,
                s = new THREE.Vector3,
                l = new THREE.Vector3;
            return function (e, t, i, n, r) {
                if (a.subVectors(t, e), s.subVectors(i, e), l.crossVectors(a, s), 0 < (t = this.direction.dot(l))) {
                    if (n) return null;
                    n = 1
                } else {
                    if (!(t < 0)) return null;
                    n = -1, t = -t
                }
                return o.subVectors(this.origin, e), (e = n * this.direction.dot(s.crossVectors(o, s))) < 0 ? null : (i = n * this.direction.dot(a.cross(o))) < 0 || t < e + i ? null : (e = -n * o.dot(l)) < 0 ? null : this.at(e / t, r)
            }
        }(),
        applyMatrix4: function (e) {
            return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this
        },
        equals: function (e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        },
        clone: function () {
            return (new THREE.Ray).copy(this)
        }
    }, THREE.Sphere = function (e, t) {
        this.center = void 0 !== e ? e : new THREE.Vector3, this.radius = void 0 !== t ? t : 0
    }, THREE.Sphere.prototype = {
        constructor: THREE.Sphere,
        set: function (e, t) {
            return this.center.copy(e), this.radius = t, this
        },
        setFromPoints: function () {
            var a = new THREE.Box3;
            return function (e, t) {
                var i = this.center;
                void 0 !== t ? i.copy(t) : a.setFromPoints(e).center(i);
                for (var n = 0, r = 0, o = e.length; r < o; r++) n = Math.max(n, i.distanceToSquared(e[r]));
                return this.radius = Math.sqrt(n), this
            }
        }(),
        copy: function (e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        },
        empty: function () {
            return this.radius <= 0
        },
        containsPoint: function (e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function (e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function (e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        clampPoint: function (e, t) {
            var i = this.center.distanceToSquared(e),
                n = t || new THREE.Vector3;
            return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
        },
        getBoundingBox: function (e) {
            return (e = e || new THREE.Box3).set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function (e) {
            return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
        },
        translate: function (e) {
            return this.center.add(e), this
        },
        equals: function (e) {
            return e.center.equals(this.center) && e.radius === this.radius
        },
        clone: function () {
            return (new THREE.Sphere).copy(this)
        }
    }, THREE.Frustum = function (e, t, i, n, r, o) {
        this.planes = [void 0 !== e ? e : new THREE.Plane, void 0 !== t ? t : new THREE.Plane, void 0 !== i ? i : new THREE.Plane, void 0 !== n ? n : new THREE.Plane, void 0 !== r ? r : new THREE.Plane, void 0 !== o ? o : new THREE.Plane]
    }, THREE.Frustum.prototype = {
        constructor: THREE.Frustum,
        set: function (e, t, i, n, r, o) {
            var a = this.planes;
            return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this
        },
        copy: function (e) {
            for (var t = this.planes, i = 0; i < 6; i++) t[i].copy(e.planes[i]);
            return this
        },
        setFromMatrix: function (e) {
            var t = this.planes;
            e = (g = e.elements)[0];
            var i = g[1],
                n = g[2],
                r = g[3],
                o = g[4],
                a = g[5],
                s = g[6],
                l = g[7],
                c = g[8],
                h = g[9],
                u = g[10],
                f = g[11],
                d = g[12],
                p = g[13],
                m = g[14],
                g = g[15];
            return t[0].setComponents(r - e, l - o, f - c, g - d).normalize(), t[1].setComponents(r + e, l + o, f + c, g + d).normalize(), t[2].setComponents(r + i, l + a, f + h, g + p).normalize(), t[3].setComponents(r - i, l - a, f - h, g - p).normalize(), t[4].setComponents(r - n, l - s, f - u, g - m).normalize(), t[5].setComponents(r + n, l + s, f + u, g + m).normalize(), this
        },
        intersectsObject: function () {
            var i = new THREE.Sphere;
            return function (e) {
                var t = e.geometry;
                return null === t.boundingSphere && t.computeBoundingSphere(), i.copy(t.boundingSphere), i.applyMatrix4(e.matrixWorld), this.intersectsSphere(i)
            }
        }(),
        intersectsSphere: function (e) {
            var t = this.planes,
                i = e.center;
            e = -e.radius;
            for (var n = 0; n < 6; n++)
                if (t[n].distanceToPoint(i) < e) return !1;
            return !0
        },
        intersectsBox: function () {
            var o = new THREE.Vector3,
                a = new THREE.Vector3;
            return function (e) {
                for (var t = this.planes, i = 0; i < 6; i++) {
                    var n = t[i];
                    o.x = 0 < n.normal.x ? e.min.x : e.max.x, a.x = 0 < n.normal.x ? e.max.x : e.min.x, o.y = 0 < n.normal.y ? e.min.y : e.max.y, a.y = 0 < n.normal.y ? e.max.y : e.min.y, o.z = 0 < n.normal.z ? e.min.z : e.max.z, a.z = 0 < n.normal.z ? e.max.z : e.min.z;
                    var r = n.distanceToPoint(o);
                    n = n.distanceToPoint(a);
                    if (r < 0 && n < 0) return !1
                }
                return !0
            }
        }(),
        containsPoint: function (e) {
            for (var t = this.planes, i = 0; i < 6; i++)
                if (t[i].distanceToPoint(e) < 0) return !1;
            return !0
        },
        clone: function () {
            return (new THREE.Frustum).copy(this)
        }
    }, THREE.Plane = function (e, t) {
        this.normal = void 0 !== e ? e : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }, THREE.Plane.prototype = {
        constructor: THREE.Plane,
        set: function (e, t) {
            return this.normal.copy(e), this.constant = t, this
        },
        setComponents: function (e, t, i, n) {
            return this.normal.set(e, t, i), this.constant = n, this
        },
        setFromNormalAndCoplanarPoint: function (e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        },
        setFromCoplanarPoints: function () {
            var n = new THREE.Vector3,
                r = new THREE.Vector3;
            return function (e, t, i) {
                return t = n.subVectors(i, t).cross(r.subVectors(e, t)).normalize(), this.setFromNormalAndCoplanarPoint(t, e), this
            }
        }(),
        copy: function (e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        },
        normalize: function () {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        },
        negate: function () {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function (e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function (e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function (e, t) {
            return this.orthoPoint(e, t).sub(e).negate()
        },
        orthoPoint: function (e, t) {
            var i = this.distanceToPoint(e);
            return (t || new THREE.Vector3).copy(this.normal).multiplyScalar(i)
        },
        isIntersectionLine: function (e) {
            var t = this.distanceToPoint(e.start);
            return e = this.distanceToPoint(e.end), t < 0 && 0 < e || e < 0 && 0 < t
        },
        intersectLine: function () {
            var o = new THREE.Vector3;
            return function (e, t) {
                var i = t || new THREE.Vector3,
                    n = e.delta(o),
                    r = this.normal.dot(n);
                return 0 != r ? (r = -(e.start.dot(this.normal) + this.constant) / r) < 0 || 1 < r ? void 0 : i.copy(n).multiplyScalar(r).add(e.start) : 0 == this.distanceToPoint(e.start) ? i.copy(e.start) : void 0
            }
        }(),
        coplanarPoint: function (e) {
            return (e || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function () {
            var r = new THREE.Vector3,
                o = new THREE.Vector3,
                a = new THREE.Matrix3;
            return function (e, t) {
                var i = t || a.getNormalMatrix(e),
                    n = (i = r.copy(this.normal).applyMatrix3(i), this.coplanarPoint(o));
                return n.applyMatrix4(e), this.setFromNormalAndCoplanarPoint(i, n), this
            }
        }(),
        translate: function (e) {
            return this.constant -= e.dot(this.normal), this
        },
        equals: function (e) {
            return e.normal.equals(this.normal) && e.constant == this.constant
        },
        clone: function () {
            return (new THREE.Plane).copy(this)
        }
    }, THREE.Math = {
        PI2: 2 * Math.PI,
        generateUUID: function () {
            var t, i = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                n = Array(36),
                r = 0;
            return function () {
                for (var e = 0; e < 36; e++) n[e] = 8 == e || 13 == e || 18 == e || 23 == e ? "-" : 14 == e ? "4" : (r <= 2 && (r = 33554432 + 16777216 * Math.random() | 0), t = 15 & r, r >>= 4, i[19 == e ? 3 & t | 8 : t]);
                return n.join("")
            }
        }(),
        clamp: function (e, t, i) {
            return e < t ? t : i < e ? i : e
        },
        clampBottom: function (e, t) {
            return e < t ? t : e
        },
        mapLinear: function (e, t, i, n, r) {
            return n + (e - t) * (r - n) / (i - t)
        },
        smoothstep: function (e, t, i) {
            return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
        },
        smootherstep: function (e, t, i) {
            return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        random16: function () {
            return (65280 * Math.random() + 255 * Math.random()) / 65535
        },
        randInt: function (e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function (e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function (e) {
            return e * (.5 - Math.random())
        },
        sign: function (e) {
            return e < 0 ? -1 : 0 < e ? 1 : 0
        },
        degToRad: function () {
            var t = Math.PI / 180;
            return function (e) {
                return e * t
            }
        }(),
        radToDeg: function () {
            var t = 180 / Math.PI;
            return function (e) {
                return e * t
            }
        }(),
        isPowerOfTwo: function (e) {
            return 0 == (e & e - 1) && 0 !== e
        }
    }, THREE.Spline = function (e) {
        function t(e, t, i, n, r, o, a) {
            return (2 * (t - i) + (e = .5 * (i - e)) + (n = .5 * (n - t))) * a + (-3 * (t - i) - 2 * e - n) * o + e * r + t
        }
        this.points = e;
        var i, n, r, o, a, s, l, c, h, u = [],
            f = {
                x: 0,
                y: 0,
                z: 0
            };
        this.initFromArray = function (e) {
            this.points = [];
            for (var t = 0; t < e.length; t++) this.points[t] = {
                x: e[t][0],
                y: e[t][1],
                z: e[t][2]
            }
        }, this.getPoint = function (e) {
            return i = (this.points.length - 1) * e, n = Math.floor(i), r = i - n, u[0] = 0 === n ? n : n - 1, u[1] = n, u[2] = n > this.points.length - 2 ? this.points.length - 1 : n + 1, u[3] = n > this.points.length - 3 ? this.points.length - 1 : n + 2, s = this.points[u[0]], l = this.points[u[1]], c = this.points[u[2]], h = this.points[u[3]], a = r * (o = r * r), f.x = t(s.x, l.x, c.x, h.x, r, o, a), f.y = t(s.y, l.y, c.y, h.y, r, o, a), f.z = t(s.z, l.z, c.z, h.z, r, o, a), f
        }, this.getControlPointsArray = function () {
            var e, t, i = this.points.length,
                n = [];
            for (e = 0; e < i; e++) t = this.points[e], n[e] = [t.x, t.y, t.z];
            return n
        }, this.getLength = function (e) {
            var t, i, n, r = t = t = 0,
                o = new THREE.Vector3,
                a = new THREE.Vector3,
                s = [],
                l = 0;
            for (s[0] = 0, e || (e = 100), i = this.points.length * e, o.copy(this.points[0]), e = 1; e < i; e++) t = e / i, n = this.getPoint(t), a.copy(n), l += a.distanceTo(o), o.copy(n), t *= this.points.length - 1, (t = Math.floor(t)) != r && (s[t] = l, r = t);
            return s[s.length] = l, {
                chunks: s,
                total: l
            }
        }, this.reparametrizeByArcLength = function (e) {
            var t, i, n, r, o, a, s = [],
                l = new THREE.Vector3,
                c = this.getLength();
            for (s.push(l.copy(this.points[0]).clone()), t = 1; t < this.points.length; t++) {
                for (i = c.chunks[t] - c.chunks[t - 1], a = Math.ceil(e * i / c.total), r = (t - 1) / (this.points.length - 1), o = t / (this.points.length - 1), i = 1; i < a - 1; i++) n = r + 1 / a * i * (o - r), n = this.getPoint(n), s.push(l.copy(n).clone());
                s.push(l.copy(this.points[t]).clone())
            }
            this.points = s
        }
    }, THREE.Triangle = function (e, t, i) {
        this.a = void 0 !== e ? e : new THREE.Vector3, this.b = void 0 !== t ? t : new THREE.Vector3, this.c = void 0 !== i ? i : new THREE.Vector3
    }, THREE.Triangle.normal = function () {
        var r = new THREE.Vector3;
        return function (e, t, i, n) {
            return (n = n || new THREE.Vector3).subVectors(i, t), r.subVectors(e, t), n.cross(r), 0 < (e = n.lengthSq()) ? n.multiplyScalar(1 / Math.sqrt(e)) : n.set(0, 0, 0)
        }
    }(), THREE.Triangle.barycoordFromPoint = function () {
        var s = new THREE.Vector3,
            l = new THREE.Vector3,
            c = new THREE.Vector3;
        return function (e, t, i, n, r) {
            s.subVectors(n, t), l.subVectors(i, t), c.subVectors(e, t), e = s.dot(s), t = s.dot(l), i = s.dot(c);
            var o = l.dot(l);
            n = l.dot(c);
            var a = e * o - t * t;
            return r = r || new THREE.Vector3, 0 == a ? r.set(-2, -1, -1) : (o = (o * i - t * n) * (a = 1 / a), e = (e * n - t * i) * a, r.set(1 - o - e, e, o))
        }
    }(), THREE.Triangle.containsPoint = function () {
        var r = new THREE.Vector3;
        return function (e, t, i, n) {
            return 0 <= (e = THREE.Triangle.barycoordFromPoint(e, t, i, n, r)).x && 0 <= e.y && e.x + e.y <= 1
        }
    }(), THREE.Triangle.prototype = {
        constructor: THREE.Triangle,
        set: function (e, t, i) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
        },
        setFromPointsAndIndices: function (e, t, i, n) {
            return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this
        },
        copy: function (e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        area: function () {
            var e = new THREE.Vector3,
                t = new THREE.Vector3;
            return function () {
                return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
            }
        }(),
        midpoint: function (e) {
            return (e || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function (e) {
            return THREE.Triangle.normal(this.a, this.b, this.c, e)
        },
        plane: function (e) {
            return (e || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function (e, t) {
            return THREE.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t)
        },
        containsPoint: function (e) {
            return THREE.Triangle.containsPoint(e, this.a, this.b, this.c)
        },
        equals: function (e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        },
        clone: function () {
            return (new THREE.Triangle).copy(this)
        }
    }, THREE.Vertex = function (e) {
        return console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead."), e
    }, THREE.UV = function (e, t) {
        return console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead."), new THREE.Vector2(e, t)
    }, THREE.Clock = function (e) {
        this.autoStart = void 0 === e || e, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
    }, THREE.Clock.prototype = {
        constructor: THREE.Clock,
        start: function () {
            this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), this.running = !0
        },
        stop: function () {
            this.getElapsedTime(), this.running = !1
        },
        getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function () {
            var e = 0;
            if (this.autoStart && !this.running && this.start(), this.running) {
                var t = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
                e = .001 * (t - this.oldTime);
                this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    }, THREE.EventDispatcher = function () {}, THREE.EventDispatcher.prototype = {
        constructor: THREE.EventDispatcher,
        apply: function (e) {
            e.addEventListener = THREE.EventDispatcher.prototype.addEventListener, e.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, e.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, e.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
        },
        addEventListener: function (e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
        },
        hasEventListener: function (e, t) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[e] && -1 !== i[e].indexOf(t)
        },
        removeEventListener: function (e, t) {
            if (void 0 !== this._listeners) {
                var i = this._listeners[e];
                if (void 0 !== i) {
                    var n = i.indexOf(t); - 1 !== n && i.splice(n, 1)
                }
            }
        },
        dispatchEvent: function () {
            var r = [];
            return function (e) {
                if (void 0 !== this._listeners) {
                    var t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        for (var i = t.length, n = 0; n < i; n++) r[n] = t[n];
                        for (n = 0; n < i; n++) r[n].call(this, e)
                    }
                }
            }
        }()
    },
    function (b) {
        b.Raycaster = function (e, t, i, n) {
            this.ray = new b.Ray(e, t), this.near = i || 0, this.far = n || 1 / 0
        };
        var x = new b.Sphere,
            R = new b.Ray;
        new b.Plane, new b.Vector3;
        var w = new b.Vector3,
            _ = new b.Matrix4,
            o = function (e, t) {
                return e.distance - t.distance
            },
            H = new b.Vector3,
            S = new b.Vector3,
            M = new b.Vector3,
            C = function (e, t, i) {
                if (e instanceof b.Sprite) {
                    w.setFromMatrixPosition(e.matrixWorld);
                    var n = t.ray.distanceToPoint(w);
                    if (n > e.scale.x) return i;
                    i.push({
                        distance: n,
                        point: e.position,
                        face: null,
                        object: e
                    })
                } else if (e instanceof b.LOD) w.setFromMatrixPosition(e.matrixWorld), n = t.ray.origin.distanceTo(w), C(e.getObjectForDistance(n), t, i);
                else if (e instanceof b.Mesh) {
                    if (null === (m = e.geometry).boundingSphere && m.computeBoundingSphere(), x.copy(m.boundingSphere), x.applyMatrix4(e.matrixWorld), !1 === t.ray.isIntersectionSphere(x)) return i;
                    if (_.getInverse(e.matrixWorld), R.copy(t.ray).applyMatrix4(_), null !== m.boundingBox && !1 === R.isIntersectionBox(m.boundingBox)) return i;
                    if (m instanceof b.BufferGeometry) {
                        var r = e.material;
                        if (void 0 === r) return i;
                        var o, a, s = m.attributes,
                            l = t.precision;
                        if (void 0 !== s.index)
                            for (var c = m.offsets, h = s.index.array, u = s.position.array, f = 0, d = c.length; f < d; ++f) {
                                s = c[f].start;
                                for (var p = c[f].index, m = s, g = s + c[f].count; m < g; m += 3) {
                                    s = p + h[m], o = p + h[m + 1], a = p + h[m + 2], H.set(u[3 * s], u[3 * s + 1], u[3 * s + 2]), S.set(u[3 * o], u[3 * o + 1], u[3 * o + 2]), M.set(u[3 * a], u[3 * a + 1], u[3 * a + 2]);
                                    var E = r.side === b.BackSide ? R.intersectTriangle(M, S, H, !0) : R.intersectTriangle(H, S, M, r.side !== b.DoubleSide);
                                    null !== E && (E.applyMatrix4(e.matrixWorld), (n = t.ray.origin.distanceTo(E)) < l || n < t.near || n > t.far || i.push({
                                        distance: n,
                                        point: E,
                                        indices: [s, o, a],
                                        face: null,
                                        faceIndex: null,
                                        object: e
                                    }))
                                }
                            } else
                                for (u = s.position.array, m = 0, g = s.position.array.length; m < g; m += 3) o = (s = m) + 1, a = m + 2, H.set(u[3 * s], u[3 * s + 1], u[3 * s + 2]), S.set(u[3 * o], u[3 * o + 1], u[3 * o + 2]), M.set(u[3 * a], u[3 * a + 1], u[3 * a + 2]), null !== (E = r.side === b.BackSide ? R.intersectTriangle(M, S, H, !0) : R.intersectTriangle(H, S, M, r.side !== b.DoubleSide)) && (E.applyMatrix4(e.matrixWorld), (n = t.ray.origin.distanceTo(E)) < l || n < t.near || n > t.far || i.push({
                                    distance: n,
                                    point: E,
                                    indices: [s, o, a],
                                    face: null,
                                    faceIndex: null,
                                    object: e
                                }))
                    } else if (m instanceof b.Geometry)
                        for (u = !0 === (h = e.material instanceof b.MeshFaceMaterial) ? e.material.materials : null, l = t.precision, c = m.vertices, f = 0, d = m.faces.length; f < d; f++)
                            if (p = m.faces[f], void 0 !== (r = !0 === h ? u[p.materialIndex] : e.material)) {
                                if (s = c[p.a], o = c[p.b], a = c[p.c], !0 === r.morphTargets) {
                                    n = m.morphTargets, E = e.morphTargetInfluences, H.set(0, 0, 0), S.set(0, 0, 0), M.set(0, 0, 0);
                                    g = 0;
                                    for (var v = n.length; g < v; g++) {
                                        var y = E[g];
                                        if (0 !== y) {
                                            var T = n[g].vertices;
                                            H.x += (T[p.a].x - s.x) * y, H.y += (T[p.a].y - s.y) * y, H.z += (T[p.a].z - s.z) * y, S.x += (T[p.b].x - o.x) * y, S.y += (T[p.b].y - o.y) * y, S.z += (T[p.b].z - o.z) * y, M.x += (T[p.c].x - a.x) * y, M.y += (T[p.c].y - a.y) * y, M.z += (T[p.c].z - a.z) * y
                                        }
                                    }
                                    H.add(s), S.add(o), M.add(a), s = H, o = S, a = M
                                }
                                null !== (E = r.side === b.BackSide ? R.intersectTriangle(a, o, s, !0) : R.intersectTriangle(s, o, a, r.side !== b.DoubleSide)) && (E.applyMatrix4(e.matrixWorld), (n = t.ray.origin.distanceTo(E)) < l || n < t.near || n > t.far || i.push({
                                    distance: n,
                                    point: E,
                                    face: p,
                                    faceIndex: f,
                                    object: e
                                }))
                            }
                } else if (e instanceof b.Line) {
                    if (r = (l = t.linePrecision) * l, null === (m = e.geometry).boundingSphere && m.computeBoundingSphere(), x.copy(m.boundingSphere), x.applyMatrix4(e.matrixWorld), !1 === t.ray.isIntersectionSphere(x)) return i;
                    if (_.getInverse(e.matrixWorld), R.copy(t.ray).applyMatrix4(_), m instanceof b.Geometry)
                        for (l = (c = m.vertices).length, s = new b.Vector3, o = new b.Vector3, a = e.type === b.LineStrip ? 1 : 2, m = 0; m < l - 1; m += a) R.distanceSqToSegment(c[m], c[m + 1], o, s) > r || ((n = R.origin.distanceTo(o)) < t.near || n > t.far || i.push({
                            distance: n,
                            point: s.clone().applyMatrix4(e.matrixWorld),
                            face: null,
                            faceIndex: null,
                            object: e
                        }))
                }
            },
            a = function (e, t, i) {
                for (var n = 0, r = (e = e.getDescendants()).length; n < r; n++) C(e[n], t, i)
            };
        b.Raycaster.prototype.precision = 1e-4, b.Raycaster.prototype.linePrecision = 1, b.Raycaster.prototype.set = function (e, t) {
            this.ray.set(e, t)
        }, b.Raycaster.prototype.intersectObject = function (e, t) {
            var i = [];
            return !0 === t && a(e, this, i), C(e, this, i), i.sort(o), i
        }, b.Raycaster.prototype.intersectObjects = function (e, t) {
            for (var i = [], n = 0, r = e.length; n < r; n++) C(e[n], this, i), !0 === t && a(e[n], this, i);
            return i.sort(o), i
        }
    }(THREE), THREE.Object3D = function () {
        this.id = THREE.Object3DIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.parent = void 0, this.children = [], this.up = new THREE.Vector3(0, 1, 0), this.position = new THREE.Vector3, this._rotation = new THREE.Euler, this._quaternion = new THREE.Quaternion, this.scale = new THREE.Vector3(1, 1, 1), this._rotation._quaternion = this.quaternion, this._quaternion._euler = this.rotation, this.renderDepth = null, this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.matrixWorld = new THREE.Matrix4, this.visible = this.matrixWorldNeedsUpdate = this.matrixAutoUpdate = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.userData = {}
    }, THREE.Object3D.prototype = {
        constructor: THREE.Object3D,
        get rotation() {
            return this._rotation
        },
        set rotation(e) {
            this._rotation = e, this._rotation._quaternion = this._quaternion, this._quaternion._euler = this._rotation, this._rotation._updateQuaternion()
        },
        get quaternion() {
            return this._quaternion
        },
        set quaternion(e) {
            this._quaternion = e, this._quaternion._euler = this._rotation, this._rotation._quaternion = this._quaternion, this._quaternion._updateEuler()
        },
        get eulerOrder() {
            return console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."), this.rotation.order
        },
        set eulerOrder(e) {
            console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."), this.rotation.order = e
        },
        get useQuaternion() {
            console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set useQuaternion(e) {
            console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        applyMatrix: function (e) {
            this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        setRotationFromAxisAngle: function (e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function (e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function (e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function (e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function () {
            var i = new THREE.Quaternion;
            return function (e, t) {
                return i.setFromAxisAngle(e, t), this.quaternion.multiply(i), this
            }
        }(),
        rotateX: function () {
            var t = new THREE.Vector3(1, 0, 0);
            return function (e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateY: function () {
            var t = new THREE.Vector3(0, 1, 0);
            return function (e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateZ: function () {
            var t = new THREE.Vector3(0, 0, 1);
            return function (e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        translateOnAxis: function () {
            var i = new THREE.Vector3;
            return function (e, t) {
                return i.copy(e), i.applyQuaternion(this.quaternion), this.position.add(i.multiplyScalar(t)), this
            }
        }(),
        translate: function (e, t) {
            return console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed."), this.translateOnAxis(t, e)
        },
        translateX: function () {
            var t = new THREE.Vector3(1, 0, 0);
            return function (e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateY: function () {
            var t = new THREE.Vector3(0, 1, 0);
            return function (e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateZ: function () {
            var t = new THREE.Vector3(0, 0, 1);
            return function (e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        localToWorld: function (e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function () {
            var t = new THREE.Matrix4;
            return function (e) {
                return e.applyMatrix4(t.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function () {
            var t = new THREE.Matrix4;
            return function (e) {
                t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t)
            }
        }(),
        add: function (e) {
            if (e === this) console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");
            else if (e instanceof THREE.Object3D) {
                void 0 !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                    type: "added"
                }), this.children.push(e);
                for (var t = this; void 0 !== t.parent;) t = t.parent;
                void 0 !== t && t instanceof THREE.Scene && t.__addObject(e)
            }
        },
        remove: function (e) {
            var t = this.children.indexOf(e);
            if (-1 !== t) {
                for (e.parent = void 0, e.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(t, 1), t = this; void 0 !== t.parent;) t = t.parent;
                void 0 !== t && t instanceof THREE.Scene && t.__removeObject(e)
            }
        },
        traverse: function (e) {
            e(this);
            for (var t = 0, i = this.children.length; t < i; t++) this.children[t].traverse(e)
        },
        getObjectById: function (e, t) {
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i];
                if (r.id === e || !0 === t && void 0 !== (r = r.getObjectById(e, t))) return r
            }
        },
        getObjectByName: function (e, t) {
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i];
                if (r.name === e || !0 === t && void 0 !== (r = r.getObjectByName(e, t))) return r
            }
        },
        getChildByName: function (e, t) {
            return console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e, t)
        },
        getDescendants: function (e) {
            void 0 === e && (e = []), Array.prototype.push.apply(e, this.children);
            for (var t = 0, i = this.children.length; t < i; t++) this.children[t].getDescendants(e);
            return e
        },
        updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function (e) {
            !0 === this.matrixAutoUpdate && this.updateMatrix(), !0 !== this.matrixWorldNeedsUpdate && !0 !== e || (void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e = !(this.matrixWorldNeedsUpdate = !1));
            for (var t = 0, i = this.children.length; t < i; t++) this.children[t].updateMatrixWorld(e)
        },
        clone: function (e, t) {
            if (void 0 === e && (e = new THREE.Object3D), void 0 === t && (t = !0), e.name = this.name, e.up.copy(this.up), e.position.copy(this.position), e.quaternion.copy(this.quaternion), e.scale.copy(this.scale), e.renderDepth = this.renderDepth, e.rotationAutoUpdate = this.rotationAutoUpdate, e.matrix.copy(this.matrix), e.matrixWorld.copy(this.matrixWorld), e.matrixAutoUpdate = this.matrixAutoUpdate, e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, e.visible = this.visible, e.castShadow = this.castShadow, e.receiveShadow = this.receiveShadow, e.frustumCulled = this.frustumCulled, e.userData = JSON.parse(JSON.stringify(this.userData)), !0 === t)
                for (var i = 0; i < this.children.length; i++) e.add(this.children[i].clone());
            return e
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, THREE.Projector = function () {
        function k() {
            if (V !== t) return X[V++];
            var e = new THREE.RenderableVertex;
            return X.push(e), t++, V++, e
        }

        function O() {
            if (B !== l) return s[B++];
            var e = new THREE.RenderableFace;
            return s.push(e), l++, B++, e
        }

        function F() {
            if ($ !== h) return c[$++];
            var e = new THREE.RenderableLine;
            return c.push(e), h++, $++, e
        }

        function j(e, t) {
            return e.z !== t.z ? t.z - e.z : e.id !== t.id ? e.id - t.id : 0
        }
        var n, U, r, V, N, B, I, $, G, W, q, i, o = [],
            a = 0,
            X = [],
            t = 0,
            s = [],
            l = 0,
            c = [],
            h = 0,
            Y = [],
            K = 0,
            Q = {
                objects: [],
                lights: [],
                elements: []
            },
            Z = new THREE.Vector3,
            J = new THREE.Vector3,
            ee = new THREE.Vector3,
            u = new THREE.Vector3,
            te = new THREE.Vector4,
            f = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
            d = new THREE.Box3,
            p = Array(3),
            ie = new THREE.Matrix4,
            ne = new THREE.Matrix4,
            re = new THREE.Matrix4,
            oe = new THREE.Matrix3,
            ae = new THREE.Frustum,
            se = new THREE.Vector4,
            le = new THREE.Vector4;
        this.projectVector = function (e, t) {
            return t.matrixWorldInverse.getInverse(t.matrixWorld), ne.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), e.applyProjection(ne)
        }, this.unprojectVector = (i = new THREE.Matrix4, function (e, t) {
            return i.getInverse(t.projectionMatrix), ne.multiplyMatrices(t.matrixWorld, i), e.applyProjection(ne)
        }), this.pickingRay = function (e, t) {
            e.z = -1;
            var i = new THREE.Vector3(e.x, e.y, 1);
            return this.unprojectVector(e, t), this.unprojectVector(i, t), i.sub(e).normalize(), new THREE.Raycaster(e, i)
        };
        var ce = function (e) {
                if (!1 !== e.visible) {
                    if (e instanceof THREE.Light) Q.lights.push(e);
                    else if ((e instanceof THREE.Mesh || e instanceof THREE.Line || e instanceof THREE.Sprite) && (!1 === e.frustumCulled || !0 === ae.intersectsObject(e))) {
                        if (U === a) {
                            var t = new THREE.RenderableObject;
                            o.push(t), a++, U++, n = t
                        } else n = o[U++];
                        n.id = e.id, null !== (n.object = e).renderDepth ? n.z = e.renderDepth : (u.setFromMatrixPosition(e.matrixWorld), u.applyProjection(ne), n.z = u.z), Q.objects.push(n)
                    }
                    t = 0;
                    for (var i = e.children.length; t < i; t++) ce(e.children[t])
                }
            },
            he = new function () {
                var a = [],
                    s = null,
                    l = new THREE.Matrix3,
                    n = function (e) {
                        var t = e.positionWorld,
                            i = e.positionScreen;
                        t.copy(e.position).applyMatrix4(q), i.copy(t).applyMatrix4(ne), t = 1 / i.w, i.x *= t, i.y *= t, i.z *= t, e.visible = -1 <= i.x && i.x <= 1 && -1 <= i.y && i.y <= 1 && -1 <= i.z && i.z <= 1
                    },
                    c = function (e, t, i) {
                        return p[0] = e.positionScreen, p[1] = t.positionScreen, p[2] = i.positionScreen, !(!0 !== e.visible && !0 !== t.visible && !0 !== i.visible && !f.isIntersectionBox(d.setFromPoints(p))) && (i.positionScreen.x - e.positionScreen.x) * (t.positionScreen.y - e.positionScreen.y) - (i.positionScreen.y - e.positionScreen.y) * (t.positionScreen.x - e.positionScreen.x) < 0
                    };
                return {
                    setObject: function (e) {
                        s = e, l.getNormalMatrix(s.matrixWorld), a.length = 0
                    },
                    projectVertex: n,
                    checkTriangleVisibility: c,
                    pushVertex: function (e, t, i) {
                        (r = k()).position.set(e, t, i), n(r)
                    },
                    pushNormal: function (e, t, i) {
                        a.push(e, t, i)
                    },
                    pushLine: function (e, t) {
                        var i = X[e],
                            n = X[t];
                        (I = F()).id = s.id, I.v1.copy(i), I.v2.copy(n), I.z = (i.positionScreen.z + n.positionScreen.z) / 2, I.material = s.material, Q.elements.push(I)
                    },
                    pushTriangle: function (e, t, i) {
                        var n = X[e],
                            r = X[t],
                            o = X[i];
                        if (!0 === c(n, r, o)) {
                            for ((N = O()).id = s.id, N.v1.copy(n), N.v2.copy(r), N.v3.copy(o), N.z = (n.positionScreen.z + r.positionScreen.z + o.positionScreen.z) / 3, n = 0; n < 3; n++) r = 3 * arguments[n], (o = N.vertexNormalsModel[n]).set(a[r + 0], a[r + 1], a[r + 2]), o.applyMatrix3(l).normalize();
                            N.vertexNormalsLength = 3, N.material = s.material, Q.elements.push(N)
                        }
                    }
                }
            };
        this.projectScene = function (e, t, i, n) {
            var r, o, a, s, l, c, h, u, f, d, p, m, g, E, v, y, T;
            for (W = $ = B = 0, !(Q.elements.length = 0) === e.autoUpdate && e.updateMatrixWorld(), void 0 === t.parent && t.updateMatrixWorld(), ie.copy(t.matrixWorldInverse.getInverse(t.matrixWorld)), ne.multiplyMatrices(t.projectionMatrix, ie), ae.setFromMatrix(ne), U = 0, Q.objects.length = 0, Q.lights.length = 0, ce(e), !0 === i && Q.objects.sort(j), e = 0, i = Q.objects.length; e < i; e++)
                if (o = (r = Q.objects[e].object).geometry, he.setObject(r), q = r.matrixWorld, V = 0, r instanceof THREE.Mesh) {
                    if (o instanceof THREE.BufferGeometry) {
                        if (c = o.attributes, r = o.offsets, void 0 !== c.position) {
                            for (o = 0, s = (u = c.position.array).length; o < s; o += 3) he.pushVertex(u[o], u[o + 1], u[o + 2]);
                            for (o = 0, s = (f = c.normal.array).length; o < s; o += 3) he.pushNormal(f[o], f[o + 1], f[o + 2]);
                            if (void 0 !== c.index)
                                if (c = c.index.array, 0 < r.length)
                                    for (e = 0; e < r.length; e++)
                                        for (u = (s = r[e]).index, o = s.start, s = s.start + s.count; o < s; o += 3) he.pushTriangle(c[o] + u, c[o + 1] + u, c[o + 2] + u);
                                else
                                    for (o = 0, s = c.length; o < s; o += 3) he.pushTriangle(c[o], c[o + 1], c[o + 2]);
                            else
                                for (o = 0, s = u.length / 3; o < s; o += 3) he.pushTriangle(o, o + 1, o + 2)
                        }
                    } else if (o instanceof THREE.Geometry) {
                        a = o.vertices, s = o.faces, c = o.faceVertexUvs, oe.getNormalMatrix(q), f = !0 === (u = r.material instanceof THREE.MeshFaceMaterial) ? r.material : null;
                        for (var b = 0, x = a.length; b < x; b++) {
                            var R = a[b];
                            he.pushVertex(R.x, R.y, R.z)
                        }
                        for (b = 0, x = s.length; b < x; b++) {
                            a = s[b];
                            var w = !0 === u ? f.materials[a.materialIndex] : r.material;
                            if (void 0 !== w) {
                                h = w.side;
                                R = X[a.a];
                                var _ = X[a.b],
                                    H = X[a.c];
                                if (!0 === w.morphTargets) {
                                    l = o.morphTargets;
                                    var S = r.morphTargetInfluences,
                                        M = R.position,
                                        C = _.position,
                                        A = H.position;
                                    Z.set(0, 0, 0), J.set(0, 0, 0), ee.set(0, 0, 0);
                                    for (var P = 0, L = l.length; P < L; P++) {
                                        var D = S[P];
                                        if (0 !== D) {
                                            var z = l[P].vertices;
                                            Z.x += (z[a.a].x - M.x) * D, Z.y += (z[a.a].y - M.y) * D, Z.z += (z[a.a].z - M.z) * D, J.x += (z[a.b].x - C.x) * D, J.y += (z[a.b].y - C.y) * D, J.z += (z[a.b].z - C.z) * D, ee.x += (z[a.c].x - A.x) * D, ee.y += (z[a.c].y - A.y) * D, ee.z += (z[a.c].z - A.z) * D
                                        }
                                    }
                                    R.position.add(Z), _.position.add(J), H.position.add(ee), he.projectVertex(R), he.projectVertex(_), he.projectVertex(H)
                                }
                                if (!(!1 === (S = he.checkTriangleVisibility(R, _, H)) && h === THREE.FrontSide || !0 === S && h === THREE.BackSide)) {
                                    for ((N = O()).id = r.id, N.v1.copy(R), N.v2.copy(_), N.v3.copy(H), N.normalModel.copy(a.normal), !1 !== S || h !== THREE.BackSide && h !== THREE.DoubleSide || N.normalModel.negate(), N.normalModel.applyMatrix3(oe).normalize(), N.centroidModel.copy(a.centroid).applyMatrix4(q), l = a.vertexNormals, M = 0, C = Math.min(l.length, 3); M < C; M++)(A = N.vertexNormalsModel[M]).copy(l[M]), !1 !== S || h !== THREE.BackSide && h !== THREE.DoubleSide || A.negate(), A.applyMatrix3(oe).normalize();
                                    for (N.vertexNormalsLength = l.length, l = 0, S = Math.min(c.length, 3); l < S; l++)
                                        if (void 0 !== (h = c[l][b]))
                                            for (M = 0, C = h.length; M < C; M++) N.uvs[l][M] = h[M];
                                    N.color = a.color, N.material = w, N.z = (R.positionScreen.z + _.positionScreen.z + H.positionScreen.z) / 3, Q.elements.push(N)
                                }
                            }
                        }
                    }
                } else if (r instanceof THREE.Line) {
                if (o instanceof THREE.BufferGeometry) {
                    if (void 0 !== (c = o.attributes).position) {
                        for (o = 0, s = (u = c.position.array).length; o < s; o += 3) he.pushVertex(u[o], u[o + 1], u[o + 2]);
                        if (void 0 !== c.index)
                            for (o = 0, s = (c = c.index.array).length; o < s; o += 2) he.pushLine(c[o], c[o + 1]);
                        else
                            for (o = 0, s = u.length / 3 - 1; o < s; o++) he.pushLine(o, o + 1)
                    }
                } else if (o instanceof THREE.Geometry && (re.multiplyMatrices(ne, q), 0 !== (a = r.geometry.vertices).length))
                    for ((R = k()).positionScreen.copy(a[0]).applyMatrix4(re), o = r.type === THREE.LinePieces ? 2 : 1, b = 1, x = a.length; b < x; b++)(R = k()).positionScreen.copy(a[b]).applyMatrix4(re), 0 < (b + 1) % o || (_ = X[V - 2], se.copy(R.positionScreen), le.copy(_.positionScreen), !0 == (p = le, g = m = void 0, m = 0, g = 1, E = (d = se).z + d.w, v = p.z + p.w, y = -d.z + d.w, T = -p.z + p.w, 0 <= E && 0 <= v && 0 <= y && 0 <= T || !(E < 0 && v < 0 || y < 0 && T < 0) && (E < 0 ? m = Math.max(m, E / (E - v)) : v < 0 && (g = Math.min(g, E / (E - v))), y < 0 ? m = Math.max(m, y / (y - T)) : T < 0 && (g = Math.min(g, y / (y - T))), !(g < m || (d.lerp(p, m), p.lerp(d, 1 - g), 0)))) && (se.multiplyScalar(1 / se.w), le.multiplyScalar(1 / le.w), (I = F()).id = r.id, I.v1.positionScreen.copy(se), I.v2.positionScreen.copy(le), I.z = Math.max(se.z, le.z), I.material = r.material, r.material.vertexColors === THREE.VertexColors && (I.vertexColors[0].copy(r.geometry.colors[b]), I.vertexColors[1].copy(r.geometry.colors[b - 1])), Q.elements.push(I)))
            } else r instanceof THREE.Sprite && (te.set(q.elements[12], q.elements[13], q.elements[14], 1), te.applyMatrix4(ne), o = 1 / te.w, te.z *= o, -1 <= te.z && te.z <= 1 && ((G = W === K ? (s = new THREE.RenderableSprite, Y.push(s), K++, W++, s) : Y[W++]).id = r.id, G.x = te.x * o, G.y = te.y * o, G.z = te.z, G.object = r, G.rotation = r.rotation, G.scale.x = r.scale.x * Math.abs(G.x - (te.x + t.projectionMatrix.elements[0]) / (te.w + t.projectionMatrix.elements[12])), G.scale.y = r.scale.y * Math.abs(G.y - (te.y + t.projectionMatrix.elements[5]) / (te.w + t.projectionMatrix.elements[13])), G.material = r.material, Q.elements.push(G)));
            return !0 === n && Q.elements.sort(j), Q
        }
    }, THREE.Face3 = function (e, t, i, n, r, o) {
        this.a = e, this.b = t, this.c = i, this.normal = n instanceof THREE.Vector3 ? n : new THREE.Vector3, this.vertexNormals = n instanceof Array ? n : [], this.color = r instanceof THREE.Color ? r : new THREE.Color, this.vertexColors = r instanceof Array ? r : [], this.vertexTangents = [], this.materialIndex = void 0 !== o ? o : 0, this.centroid = new THREE.Vector3
    }, THREE.Face3.prototype = {
        constructor: THREE.Face3,
        clone: function () {
            var e, t, i = new THREE.Face3(this.a, this.b, this.c);
            for (i.normal.copy(this.normal), i.color.copy(this.color), i.centroid.copy(this.centroid), i.materialIndex = this.materialIndex, e = 0, t = this.vertexNormals.length; e < t; e++) i.vertexNormals[e] = this.vertexNormals[e].clone();
            for (e = 0, t = this.vertexColors.length; e < t; e++) i.vertexColors[e] = this.vertexColors[e].clone();
            for (e = 0, t = this.vertexTangents.length; e < t; e++) i.vertexTangents[e] = this.vertexTangents[e].clone();
            return i
        }
    }, THREE.Face4 = function (e, t, i, n, r, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(e, t, i, r, o, a)
    }, THREE.BufferGeometry = function () {
        this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.attributes = {}, this.offsets = [], this.boundingSphere = this.boundingBox = null
    }, THREE.BufferGeometry.prototype = {
        constructor: THREE.BufferGeometry,
        addAttribute: function (e, t, i, n) {
            return this.attributes[e] = {
                array: new t(i * n),
                itemSize: n
            }, this.attributes[e]
        },
        applyMatrix: function (e) {
            var t = this.attributes.position;
            void 0 !== t && (e.multiplyVector3Array(t.array), t.needsUpdate = !0), void 0 !== (t = this.attributes.normal) && ((new THREE.Matrix3).getNormalMatrix(e).multiplyVector3Array(t.array), t.needsUpdate = !0)
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3);
            var e = this.attributes.position.array;
            if (e) {
                var t = this.boundingBox;
                3 <= e.length && (t.min.x = t.max.x = e[0], t.min.y = t.max.y = e[1], t.min.z = t.max.z = e[2]);
                for (var i = 3, n = e.length; i < n; i += 3) {
                    var r = e[i],
                        o = e[i + 1],
                        a = e[i + 2];
                    r < t.min.x ? t.min.x = r : r > t.max.x && (t.max.x = r), o < t.min.y ? t.min.y = o : o > t.max.y && (t.max.y = o), a < t.min.z ? t.min.z = a : a > t.max.z && (t.max.z = a)
                }
            }
            void 0 !== e && 0 !== e.length || (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0))
        },
        computeBoundingSphere: function () {
            var o = new THREE.Box3,
                a = new THREE.Vector3;
            return function () {
                null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
                var e = this.attributes.position.array;
                if (e) {
                    o.makeEmpty();
                    for (var t = this.boundingSphere.center, i = 0, n = e.length; i < n; i += 3) a.set(e[i], e[i + 1], e[i + 2]), o.addPoint(a);
                    o.center(t);
                    var r = 0;
                    for (i = 0, n = e.length; i < n; i += 3) a.set(e[i], e[i + 1], e[i + 2]), r = Math.max(r, t.distanceToSquared(a));
                    this.boundingSphere.radius = Math.sqrt(r)
                }
            }
        }(),
        computeVertexNormals: function () {
            if (this.attributes.position) {
                var e, t, i, n;
                if (e = this.attributes.position.array.length, void 0 === this.attributes.normal) this.attributes.normal = {
                    itemSize: 3,
                    array: new Float32Array(e)
                };
                else
                    for (e = 0, t = this.attributes.normal.array.length; e < t; e++) this.attributes.normal.array[e] = 0;
                var r, o, a, s, l, c, h = this.attributes.position.array,
                    u = this.attributes.normal.array,
                    f = new THREE.Vector3,
                    d = new THREE.Vector3,
                    p = new THREE.Vector3,
                    m = new THREE.Vector3,
                    g = new THREE.Vector3;
                if (this.attributes.index) {
                    var E = this.attributes.index.array,
                        v = this.offsets;
                    for (i = 0, n = v.length; i < n; ++i) {
                        t = v[i].start, r = v[i].count;
                        var y = v[i].index;
                        for (e = t, t += r; e < t; e += 3) r = y + E[e], o = y + E[e + 1], a = y + E[e + 2], s = h[3 * r], l = h[3 * r + 1], c = h[3 * r + 2], f.set(s, l, c), s = h[3 * o], l = h[3 * o + 1], c = h[3 * o + 2], d.set(s, l, c), s = h[3 * a], l = h[3 * a + 1], c = h[3 * a + 2], p.set(s, l, c), m.subVectors(p, d), g.subVectors(f, d), m.cross(g), u[3 * r] += m.x, u[3 * r + 1] += m.y, u[3 * r + 2] += m.z, u[3 * o] += m.x, u[3 * o + 1] += m.y, u[3 * o + 2] += m.z, u[3 * a] += m.x, u[3 * a + 1] += m.y, u[3 * a + 2] += m.z
                    }
                } else
                    for (e = 0, t = h.length; e < t; e += 9) s = h[e], l = h[e + 1], c = h[e + 2], f.set(s, l, c), s = h[e + 3], l = h[e + 4], c = h[e + 5], d.set(s, l, c), s = h[e + 6], l = h[e + 7], c = h[e + 8], p.set(s, l, c), m.subVectors(p, d), g.subVectors(f, d), m.cross(g), u[e] = m.x, u[e + 1] = m.y, u[e + 2] = m.z, u[e + 3] = m.x, u[e + 4] = m.y, u[e + 5] = m.z, u[e + 6] = m.x, u[e + 7] = m.y, u[e + 8] = m.z;
                this.normalizeNormals(), this.normalsNeedUpdate = !0
            }
        },
        normalizeNormals: function () {
            for (var e, t, i, n = this.attributes.normal.array, r = 0, o = n.length; r < o; r += 3) e = n[r], t = n[r + 1], i = n[r + 2], e = 1 / Math.sqrt(e * e + t * t + i * i), n[r] *= e, n[r + 1] *= e, n[r + 2] *= e
        },
        computeTangents: function () {
            function e(e) {
                K.x = n[3 * e], K.y = n[3 * e + 1], K.z = n[3 * e + 2], Q.copy(K), W = s[e], X.copy(W), X.sub(K.multiplyScalar(K.dot(W))).normalize(), Y.crossVectors(Q, W), q = Y.dot(l[e]), G = q < 0 ? -1 : 1, a[4 * e] = X.x, a[4 * e + 1] = X.y, a[4 * e + 2] = X.z, a[4 * e + 3] = G
            }
            if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
            else {
                var t = this.attributes.index.array,
                    i = this.attributes.position.array,
                    n = this.attributes.normal.array,
                    r = this.attributes.uv.array,
                    o = i.length / 3;
                void 0 === this.attributes.tangent && (this.attributes.tangent = {
                    itemSize: 4,
                    array: new Float32Array(4 * o)
                });
                for (var a = this.attributes.tangent.array, s = [], l = [], c = 0; c < o; c++) s[c] = new THREE.Vector3, l[c] = new THREE.Vector3;
                var h, u, f, d, p, m, g, E, v, y, T, b, x, R, w, _, H, S, M, C, A, P, L, D, z, k, O, F, j, U, V, N = new THREE.Vector3,
                    B = new THREE.Vector3,
                    I = this.offsets;
                c = 0;
                for (F = I.length; c < F; ++c) {
                    O = I[c].start, j = I[c].count;
                    var $ = I[c].index;
                    o = O;
                    for (O += j; o < O; o += 3) j = $ + t[o], U = $ + t[o + 1], V = $ + t[o + 2], J = U, ee = V, h = i[3 * (Z = j)], u = i[3 * Z + 1], f = i[3 * Z + 2], d = i[3 * J], p = i[3 * J + 1], m = i[3 * J + 2], g = i[3 * ee], E = i[3 * ee + 1], v = i[3 * ee + 2], y = r[2 * Z], T = r[2 * Z + 1], b = r[2 * J], x = r[2 * J + 1], R = r[2 * ee], w = r[2 * ee + 1], _ = d - h, H = g - h, S = p - u, M = E - u, C = m - f, A = v - f, k = 1 / ((P = b - y) * (z = w - T) - (L = R - y) * (D = x - T)), N.set((z * _ - D * H) * k, (z * S - D * M) * k, (z * C - D * A) * k), B.set((P * H - L * _) * k, (P * M - L * S) * k, (P * A - L * C) * k), s[Z].add(N), s[J].add(N), s[ee].add(N), l[Z].add(B), l[J].add(B), l[ee].add(B)
                }
                var G, W, q, X = new THREE.Vector3,
                    Y = new THREE.Vector3,
                    K = new THREE.Vector3,
                    Q = new THREE.Vector3;
                c = 0;
                for (F = I.length; c < F; ++c)
                    for (O = I[c].start, j = I[c].count, $ = I[c].index, o = O, O += j; o < O; o += 3) j = $ + t[o], U = $ + t[o + 1], V = $ + t[o + 2], e(j), e(U), e(V)
            }
            var Z, J, ee
        },
        computeOffsets: function (e) {
            var t = e;
            void 0 === e && (t = 65535), Date.now(), e = this.attributes.index.array;
            for (var i = this.attributes.position.array, n = e.length / 3, r = new Uint16Array(e.length), o = 0, a = 0, s = [{
                    start: 0,
                    count: 0,
                    index: 0
                }], l = s[0], c = 0, h = new Int32Array(6), u = new Int32Array(i.length), f = new Int32Array(i.length), d = 0; d < i.length; d++) u[d] = -1, f[d] = -1;
            for (i = 0; i < n; i++) {
                for (var p = c = 0; p < 3; p++) - 1 == u[d = e[3 * i + p]] ? (h[2 * p] = d, h[2 * p + 1] = -1, c++) : u[d] < l.index ? (h[2 * p] = d, h[2 * p + 1] = -1, 0) : (h[2 * p] = d, h[2 * p + 1] = u[d]);
                if (a + c > l.index + t)
                    for (l = {
                            start: o,
                            count: 0,
                            index: a
                        }, s.push(l), c = 0; c < 6; c += 2) - 1 < (p = h[c + 1]) && p < l.index && (h[c + 1] = -1);
                for (c = 0; c < 6; c += 2) d = h[c], -1 === (p = h[c + 1]) && (p = a++), f[u[d] = p] = d, r[o++] = p - l.index, l.count++
            }
            return this.reorderBuffers(r, f, a), this.offsets = s
        },
        reorderBuffers: function (e, t, i) {
            var n, r = {},
                o = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            for (n in this.attributes)
                if ("index" != n)
                    for (var a = this.attributes[n].array, s = 0, l = o.length; s < l; s++) {
                        if (a instanceof(c = o[s])) {
                            r[n] = new c(this.attributes[n].itemSize * i);
                            break
                        }
                    }
            for (o = 0; o < i; o++)
                for (n in a = t[o], this.attributes)
                    if ("index" != n) {
                        s = this.attributes[n].array, l = this.attributes[n].itemSize;
                        for (var c = r[n], h = 0; h < l; h++) c[o * l + h] = s[a * l + h]
                    } for (n in this.attributes.index.array = e, this.attributes) "index" != n && (this.attributes[n].array = r[n], this.attributes[n].numItems = this.attributes[n].itemSize * i)
        },
        clone: function () {
            var e, t = new THREE.BufferGeometry,
                i = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            for (e in this.attributes) {
                for (var n = (o = this.attributes[e]).array, r = {
                        itemSize: o.itemSize,
                        array: null
                    }, o = 0, a = i.length; o < a; o++) {
                    var s = i[o];
                    if (n instanceof s) {
                        r.array = new s(n);
                        break
                    }
                }
                t.attributes[e] = r
            }
            for (o = 0, a = this.offsets.length; o < a; o++) i = this.offsets[o], t.offsets.push({
                start: i.start,
                index: i.index,
                count: i.count
            });
            return t
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.Geometry = function () {
        this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.hasTangents = !1, this.dynamic = !0, this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
    }, THREE.Geometry.prototype = {
        constructor: THREE.Geometry,
        applyMatrix: function (e) {
            for (var t = (new THREE.Matrix3).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(e);
            for (i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i];
                r.normal.applyMatrix3(t).normalize();
                for (var o = 0, a = r.vertexNormals.length; o < a; o++) r.vertexNormals[o].applyMatrix3(t).normalize();
                r.centroid.applyMatrix4(e)
            }
            this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox(), this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere()
        },
        computeCentroids: function () {
            var e, t, i;
            for (e = 0, t = this.faces.length; e < t; e++)(i = this.faces[e]).centroid.set(0, 0, 0), i.centroid.add(this.vertices[i.a]), i.centroid.add(this.vertices[i.b]), i.centroid.add(this.vertices[i.c]), i.centroid.divideScalar(3)
        },
        computeFaceNormals: function () {
            for (var e = new THREE.Vector3, t = new THREE.Vector3, i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i],
                    o = this.vertices[r.a],
                    a = this.vertices[r.b];
                e.subVectors(this.vertices[r.c], a), t.subVectors(o, a), e.cross(t), e.normalize(), r.normal.copy(e)
            }
        },
        computeVertexNormals: function (e) {
            var t, i, n;
            for (n = Array(this.vertices.length), t = 0, i = this.vertices.length; t < i; t++) n[t] = new THREE.Vector3;
            if (e) {
                var r, o, a, s = new THREE.Vector3,
                    l = new THREE.Vector3;
                for (new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, e = 0, t = this.faces.length; e < t; e++) i = this.faces[e], r = this.vertices[i.a], o = this.vertices[i.b], a = this.vertices[i.c], s.subVectors(a, o), l.subVectors(r, o), s.cross(l), n[i.a].add(s), n[i.b].add(s), n[i.c].add(s)
            } else
                for (e = 0, t = this.faces.length; e < t; e++) n[(i = this.faces[e]).a].add(i.normal), n[i.b].add(i.normal), n[i.c].add(i.normal);
            for (t = 0, i = this.vertices.length; t < i; t++) n[t].normalize();
            for (e = 0, t = this.faces.length; e < t; e++)(i = this.faces[e]).vertexNormals[0] = n[i.a].clone(), i.vertexNormals[1] = n[i.b].clone(), i.vertexNormals[2] = n[i.c].clone()
        },
        computeMorphNormals: function () {
            var e, t, i, n, r;
            for (i = 0, n = this.faces.length; i < n; i++)
                for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; e < t; e++) r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
            var o = new THREE.Geometry;
            for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [], r = this.morphNormals[e].faceNormals;
                    var a, s, l = this.morphNormals[e].vertexNormals;
                    for (i = 0, n = this.faces.length; i < n; i++) a = new THREE.Vector3, s = {
                        a: new THREE.Vector3,
                        b: new THREE.Vector3,
                        c: new THREE.Vector3
                    }, r.push(a), l.push(s)
                }
                for (l = this.morphNormals[e], o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], a = l.faceNormals[i], s = l.vertexNormals[i], a.copy(r.normal), s.a.copy(r.vertexNormals[0]), s.b.copy(r.vertexNormals[1]), s.c.copy(r.vertexNormals[2])
            }
            for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
        },
        computeTangents: function () {
            var e, t, i, n, r, o, a, s, l, c, h, u, f, d, p, m, g, E = [],
                v = [];
            i = new THREE.Vector3;
            var y = new THREE.Vector3,
                T = new THREE.Vector3,
                b = new THREE.Vector3,
                x = new THREE.Vector3;
            for (e = 0, t = this.vertices.length; e < t; e++) E[e] = new THREE.Vector3, v[e] = new THREE.Vector3;
            for (e = 0, t = this.faces.length; e < t; e++) r = this.faces[e], o = this.faceVertexUvs[0][e], n = r.a, g = r.b, r = r.c, a = this.vertices[n], s = this.vertices[g], l = this.vertices[r], c = o[0], h = o[1], u = o[2], o = s.x - a.x, f = l.x - a.x, d = s.y - a.y, p = l.y - a.y, s = s.z - a.z, a = l.z - a.z, l = h.x - c.x, m = u.x - c.x, h = h.y - c.y, u = 1 / (l * (c = u.y - c.y) - m * h), i.set((c * o - h * f) * u, (c * d - h * p) * u, (c * s - h * a) * u), y.set((l * f - m * o) * u, (l * p - m * d) * u, (l * a - m * s) * u), E[n].add(i), E[g].add(i), E[r].add(i), v[n].add(y), v[g].add(y), v[r].add(y);
            for (y = ["a", "b", "c", "d"], e = 0, t = this.faces.length; e < t; e++)
                for (r = this.faces[e], i = 0; i < Math.min(r.vertexNormals.length, 3); i++) x.copy(r.vertexNormals[i]), g = E[n = r[y[i]]], T.copy(g), T.sub(x.multiplyScalar(x.dot(g))).normalize(), b.crossVectors(r.vertexNormals[i], g), n = (n = b.dot(v[n])) < 0 ? -1 : 1, r.vertexTangents[i] = new THREE.Vector4(T.x, T.y, T.z, n);
            this.hasTangents = !0
        },
        computeLineDistances: function () {
            for (var e = 0, t = this.vertices, i = 0, n = t.length; i < n; i++) 0 < i && (e += t[i].distanceTo(t[i - 1])), this.lineDistances[i] = e
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), this.boundingSphere.setFromPoints(this.vertices)
        },
        mergeVertices: function () {
            var e, t, i, n = {},
                r = [],
                o = [],
                a = Math.pow(10, 4);
            for (t = 0, i = this.vertices.length; t < i; t++) e = this.vertices[t], void 0 === n[e = Math.round(e.x * a) + "_" + Math.round(e.y * a) + "_" + Math.round(e.z * a)] ? (n[e] = t, r.push(this.vertices[t]), o[t] = r.length - 1) : o[t] = o[n[e]];
            for (n = [], t = 0, i = this.faces.length; t < i; t++)
                for ((a = this.faces[t]).a = o[a.a], a.b = o[a.b], a.c = o[a.c], a = [a.a, a.b, a.c], e = 0; e < 3; e++)
                    if (a[e] == a[(e + 1) % 3]) {
                        n.push(t);
                        break
                    } for (t = n.length - 1; 0 <= t; t--)
                for (a = n[t], this.faces.splice(a, 1), o = 0, i = this.faceVertexUvs.length; o < i; o++) this.faceVertexUvs[o].splice(a, 1);
            return t = this.vertices.length - r.length, this.vertices = r, t
        },
        makeGroups: function () {
            var c = 0;
            return function (e) {
                var t, i, n, r, o = {},
                    a = this.morphTargets.length,
                    s = this.morphNormals.length;
                for (this.geometryGroups = {}, t = 0, i = this.faces.length; t < i; t++) n = this.faces[t], (n = e ? n.materialIndex : 0) in o || (o[n] = {
                    hash: n,
                    counter: 0
                }), (r = o[n].hash + "_" + o[n].counter) in this.geometryGroups || (this.geometryGroups[r] = {
                    faces3: [],
                    materialIndex: n,
                    vertices: 0,
                    numMorphTargets: a,
                    numMorphNormals: s
                }), 65535 < this.geometryGroups[r].vertices + 3 && (o[n].counter += 1, (r = o[n].hash + "_" + o[n].counter) in this.geometryGroups || (this.geometryGroups[r] = {
                    faces3: [],
                    materialIndex: n,
                    vertices: 0,
                    numMorphTargets: a,
                    numMorphNormals: s
                })), this.geometryGroups[r].faces3.push(t), this.geometryGroups[r].vertices += 3;
                for (var l in this.geometryGroupsList = [], this.geometryGroups) this.geometryGroups[l].id = c++, this.geometryGroupsList.push(this.geometryGroups[l])
            }
        }(),
        clone: function () {
            for (var e = new THREE.Geometry, t = this.vertices, i = 0, n = t.length; i < n; i++) e.vertices.push(t[i].clone());
            for (i = 0, n = (t = this.faces).length; i < n; i++) e.faces.push(t[i].clone());
            for (i = 0, n = (t = this.faceVertexUvs[0]).length; i < n; i++) {
                for (var r = t[i], o = [], a = 0, s = r.length; a < s; a++) o.push(new THREE.Vector2(r[a].x, r[a].y));
                e.faceVertexUvs[0].push(o)
            }
            return e
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, THREE.Geometry2 = function (e) {
        THREE.BufferGeometry.call(this), this.vertices = this.addAttribute("position", Float32Array, e, 3).array, this.normals = this.addAttribute("normal", Float32Array, e, 3).array, this.uvs = this.addAttribute("uv", Float32Array, e, 2).array, this.boundingSphere = this.boundingBox = null
    }, THREE.Geometry2.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.Camera = function () {
        THREE.Object3D.call(this), this.matrixWorldInverse = new THREE.Matrix4, this.projectionMatrix = new THREE.Matrix4
    }, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.lookAt = function () {
        var t = new THREE.Matrix4;
        return function (e) {
            t.lookAt(this.position, e, this.up), this.quaternion.setFromRotationMatrix(t)
        }
    }(), THREE.Camera.prototype.clone = function (e) {
        return void 0 === e && (e = new THREE.Camera), THREE.Object3D.prototype.clone.call(this, e), e.matrixWorldInverse.copy(this.matrixWorldInverse), e.projectionMatrix.copy(this.projectionMatrix), e
    }, THREE.OrthographicCamera = function (e, t, i, n, r, o) {
        THREE.Camera.call(this), this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
        this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far)
    }, THREE.OrthographicCamera.prototype.clone = function () {
        var e = new THREE.OrthographicCamera;
        return THREE.Camera.prototype.clone.call(this, e), e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e
    }, THREE.PerspectiveCamera = function (e, t, i, n) {
        THREE.Camera.call(this), this.fov = void 0 !== e ? e : 50, this.aspect = void 0 !== t ? t : 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.setLens = function (e, t) {
        void 0 === t && (t = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(t / (2 * e))), this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype.setViewOffset = function (e, t, i, n, r, o) {
        this.fullWidth = e, this.fullHeight = t, this.x = i, this.y = n, this.width = r, this.height = o, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
        if (this.fullWidth) {
            var e = this.fullWidth / this.fullHeight,
                t = Math.tan(THREE.Math.degToRad(.5 * this.fov)) * this.near,
                i = e * (n = -t),
                n = (e = Math.abs(e * t - i), Math.abs(t - n));
            this.projectionMatrix.makeFrustum(i + this.x * e / this.fullWidth, i + (this.x + this.width) * e / this.fullWidth, t - (this.y + this.height) * n / this.fullHeight, t - this.y * n / this.fullHeight, this.near, this.far)
        } else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far)
    }, THREE.PerspectiveCamera.prototype.clone = function () {
        var e = new THREE.PerspectiveCamera;
        return THREE.Camera.prototype.clone.call(this, e), e.fov = this.fov, e.aspect = this.aspect, e.near = this.near, e.far = this.far, e
    }, THREE.Light = function (e) {
        THREE.Object3D.call(this), this.color = new THREE.Color(e)
    }, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.clone = function (e) {
        return void 0 === e && (e = new THREE.Light), THREE.Object3D.prototype.clone.call(this, e), e.color.copy(this.color), e
    }, THREE.AmbientLight = function (e) {
        THREE.Light.call(this, e)
    }, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.clone = function () {
        var e = new THREE.AmbientLight;
        return THREE.Light.prototype.clone.call(this, e), e
    }, THREE.AreaLight = function (e, t) {
        THREE.Light.call(this, e), this.normal = new THREE.Vector3(0, -1, 0), this.right = new THREE.Vector3(1, 0, 0), this.intensity = void 0 !== t ? t : 1, this.height = this.width = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, this.quadraticAttenuation = .1
    }, THREE.AreaLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight = function (e, t) {
        THREE.Light.call(this, e), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, this.shadowCameraTop = this.shadowCameraRight = 500, this.shadowCameraBottom = -500, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowCascade = !1, this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3), this.shadowCascadeCount = 2, this.shadowCascadeBias = [0, 0, 0], this.shadowCascadeWidth = [512, 512, 512], this.shadowCascadeHeight = [512, 512, 512], this.shadowCascadeNearZ = [-1, .99, .998], this.shadowCascadeFarZ = [.99, .998, 1], this.shadowCascadeArray = [], this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
    }, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.clone = function () {
        var e = new THREE.DirectionalLight;
        return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e
    }, THREE.HemisphereLight = function (e, t, i) {
        THREE.Light.call(this, e), this.position.set(0, 100, 0), this.groundColor = new THREE.Color(t), this.intensity = void 0 !== i ? i : 1
    }, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.clone = function () {
        var e = new THREE.HemisphereLight;
        return THREE.Light.prototype.clone.call(this, e), e.groundColor.copy(this.groundColor), e.intensity = this.intensity, e
    }, THREE.PointLight = function (e, t, i) {
        THREE.Light.call(this, e), this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== i ? i : 0
    }, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.clone = function () {
        var e = new THREE.PointLight;
        return THREE.Light.prototype.clone.call(this, e), e.intensity = this.intensity, e.distance = this.distance, e
    }, THREE.SpotLight = function (e, t, i, n, r) {
        THREE.Light.call(this, e), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.exponent = void 0 !== r ? r : 10, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraFov = 50, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
    }, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.clone = function () {
        var e = new THREE.SpotLight;
        return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.distance = this.distance, e.angle = this.angle, e.exponent = this.exponent, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e
    }, THREE.Loader = function (e) {
        this.statusDomElement = (this.showStatus = e) ? THREE.Loader.prototype.addStatusElement() : null, this.onLoadStart = function () {}, this.onLoadProgress = function () {}, this.onLoadComplete = function () {}
    }, THREE.Loader.prototype = {
        constructor: THREE.Loader,
        crossOrigin: void 0,
        addStatusElement: function () {
            var e = document.createElement("div");
            return e.style.position = "absolute", e.style.right = "0px", e.style.top = "0px", e.style.fontSize = "0.8em", e.style.textAlign = "left", e.style.background = "rgba(0,0,0,0.25)", e.style.color = "#fff", e.style.width = "120px", e.style.padding = "0.5em 0.5em 0.5em 0.5em", e.style.zIndex = 1e3, e.innerHTML = "Loading ...", e
        },
        updateProgress: function (e) {
            var t = "Loaded ";
            t = e.total ? t + ((100 * e.loaded / e.total).toFixed(0) + "%") : t + ((e.loaded / 1e3).toFixed(2) + " KB");
            this.statusDomElement.innerHTML = t
        },
        extractUrlBase: function (e) {
            return 1 === (e = e.split("/")).length ? "./" : (e.pop(), e.join("/") + "/")
        },
        initMaterials: function (e, t) {
            for (var i = [], n = 0; n < e.length; ++n) i[n] = THREE.Loader.prototype.createMaterial(e[n], t);
            return i
        },
        needsTangents: function (e) {
            for (var t = 0, i = e.length; t < i; t++)
                if (e[t] instanceof THREE.ShaderMaterial) return !0;
            return !1
        },
        createMaterial: function (e, d) {
            function p(e) {
                return e = Math.log(e) / Math.LN2, Math.floor(e) == e
            }

            function m(e) {
                return e = Math.log(e) / Math.LN2, Math.pow(2, Math.round(e))
            }

            function t(e, t, i, n, r, o, a) {
                var s, l, c, h = /\.dds$/i.test(i),
                    u = d + i;
                if (h) {
                    var f = THREE.ImageUtils.loadCompressedTexture(u);
                    e[t] = f
                } else f = document.createElement("canvas"), e[t] = new THREE.Texture(f);
                e[t].sourceFile = i, n && (e[t].repeat.set(n[0], n[1]), 1 !== n[0] && (e[t].wrapS = THREE.RepeatWrapping), 1 !== n[1] && (e[t].wrapT = THREE.RepeatWrapping)), r && e[t].offset.set(r[0], r[1]), o && (void 0 !== (i = {
                    repeat: THREE.RepeatWrapping,
                    mirror: THREE.MirroredRepeatWrapping
                })[o[0]] && (e[t].wrapS = i[o[0]]), void 0 !== i[o[1]] && (e[t].wrapT = i[o[1]])), a && (e[t].anisotropy = a), h || (s = e[t], l = u, (c = new Image).onload = function () {
                    if (p(this.width) && p(this.height)) s.image = this;
                    else {
                        var e = m(this.width),
                            t = m(this.height);
                        s.image.width = e, s.image.height = t, s.image.getContext("2d").drawImage(this, 0, 0, e, t)
                    }
                    s.needsUpdate = !0
                }, void 0 !== g.crossOrigin && (c.crossOrigin = g.crossOrigin), c.src = l)
            }

            function i(e) {
                return (255 * e[0] << 16) + (255 * e[1] << 8) + 255 * e[2]
            }
            var g = this,
                n = "MeshLambertMaterial",
                r = {
                    color: 15658734,
                    opacity: 1,
                    map: null,
                    lightMap: null,
                    normalMap: null,
                    bumpMap: null,
                    wireframe: !1
                };
            if (e.shading) {
                var o = e.shading.toLowerCase();
                "phong" === o ? n = "MeshPhongMaterial" : "basic" === o && (n = "MeshBasicMaterial")
            }
            return void 0 !== e.blending && void 0 !== THREE[e.blending] && (r.blending = THREE[e.blending]), (void 0 !== e.transparent || e.opacity < 1) && (r.transparent = e.transparent), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.flipSided && (r.side = THREE.BackSide), void 0 !== e.doubleSided && (r.side = THREE.DoubleSide), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.vertexColors && ("face" === e.vertexColors ? r.vertexColors = THREE.FaceColors : e.vertexColors && (r.vertexColors = THREE.VertexColors)), e.colorDiffuse ? r.color = i(e.colorDiffuse) : e.DbgColor && (r.color = e.DbgColor), e.colorSpecular && (r.specular = i(e.colorSpecular)), e.colorAmbient && (r.ambient = i(e.colorAmbient)), e.transparency && (r.opacity = e.transparency), e.specularCoef && (r.shininess = e.specularCoef), e.mapDiffuse && d && t(r, "map", e.mapDiffuse, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy), e.mapLight && d && t(r, "lightMap", e.mapLight, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy), e.mapBump && d && t(r, "bumpMap", e.mapBump, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy), e.mapNormal && d && t(r, "normalMap", e.mapNormal, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy), e.mapSpecular && d && t(r, "specularMap", e.mapSpecular, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy), e.mapBumpScale && (r.bumpScale = e.mapBumpScale), e.mapNormal ? (n = THREE.ShaderLib.normalmap, (o = THREE.UniformsUtils.clone(n.uniforms)).tNormal.value = r.normalMap, e.mapNormalFactor && o.uNormalScale.value.set(e.mapNormalFactor, e.mapNormalFactor), r.map && (o.tDiffuse.value = r.map, o.enableDiffuse.value = !0), r.specularMap && (o.tSpecular.value = r.specularMap, o.enableSpecular.value = !0), r.lightMap && (o.tAO.value = r.lightMap, o.enableAO.value = !0), o.diffuse.value.setHex(r.color), o.specular.value.setHex(r.specular), o.ambient.value.setHex(r.ambient), o.shininess.value = r.shininess, void 0 !== r.opacity && (o.opacity.value = r.opacity), n = new THREE.ShaderMaterial({
                fragmentShader: n.fragmentShader,
                vertexShader: n.vertexShader,
                uniforms: o,
                lights: !0,
                fog: !0
            }), r.transparent && (n.transparent = !0)) : n = new THREE[n](r), void 0 !== e.DbgName && (n.name = e.DbgName), n
        }
    }, THREE.XHRLoader = function (e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.XHRLoader.prototype = {
        constructor: THREE.XHRLoader,
        load: function (t, i, n, r) {
            var o = this,
                e = new XMLHttpRequest;
            void 0 !== i && e.addEventListener("load", function (e) {
                i(e.target.responseText), o.manager.itemEnd(t)
            }, !1), void 0 !== n && e.addEventListener("progress", function (e) {
                n(e)
            }, !1), void 0 !== r && e.addEventListener("error", function (e) {
                r(e)
            }, !1), void 0 !== this.crossOrigin && (e.crossOrigin = this.crossOrigin), e.open("GET", t, !0), e.send(null), o.manager.itemStart(t)
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        }
    }, THREE.ImageLoader = function (e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.ImageLoader.prototype = {
        constructor: THREE.ImageLoader,
        load: function (t, i, n, r) {
            var o = this,
                e = document.createElement("img");
            return void 0 !== i && e.addEventListener("load", function (e) {
                o.manager.itemEnd(t), i(this)
            }, !1), void 0 !== n && e.addEventListener("progress", function (e) {
                n(e)
            }, !1), void 0 !== r && e.addEventListener("error", function (e) {
                r(e)
            }, !1), void 0 !== this.crossOrigin && (e.crossOrigin = this.crossOrigin), e.src = t, o.manager.itemStart(t), e
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        }
    }, THREE.JSONLoader = function (e) {
        THREE.Loader.call(this, e), this.withCredentials = !1
    }, THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype), THREE.JSONLoader.prototype.load = function (e, t, i) {
        i = i && "string" == typeof i ? i : this.extractUrlBase(e), this.onLoadStart(), this.loadAjaxJSON(this, e, t, i)
    }, THREE.JSONLoader.prototype.loadAjaxJSON = function (t, i, n, r, o) {
        var a = new XMLHttpRequest,
            s = 0;
        a.onreadystatechange = function () {
            if (a.readyState === a.DONE)
                if (200 === a.status || 0 === a.status) {
                    if (a.responseText) {
                        var e = JSON.parse(a.responseText);
                        if ("scene" === e.metadata.type) return void console.error('THREE.JSONLoader: "' + i + '" seems to be a Scene. Use THREE.SceneLoader instead.');
                        e = t.parse(e, r), n(e.geometry, e.materials)
                    } else console.error('THREE.JSONLoader: "' + i + '" seems to be unreachable or the file is empty.');
                    t.onLoadComplete()
                } else console.error("THREE.JSONLoader: Couldn't load \"" + i + '" (' + a.status + ")");
            else a.readyState === a.LOADING ? o && (0 === s && (s = a.getResponseHeader("Content-Length")), o({
                total: s,
                loaded: a.responseText.length
            })) : a.readyState === a.HEADERS_RECEIVED && void 0 !== o && (s = a.getResponseHeader("Content-Length"))
        }, a.open("GET", i, !0), a.withCredentials = this.withCredentials, a.send(null)
    }, THREE.JSONLoader.prototype.parse = function (v, e) {
        var y = new THREE.Geometry,
            t = void 0 !== v.scale ? 1 / v.scale : 1;
        return function (e) {
                var t, i, n, r, o, a, s, l, c, h, u, f, d, p = v.faces;
                a = v.vertices;
                var m = v.normals,
                    g = v.colors,
                    E = 0;
                if (void 0 !== v.uvs) {
                    for (t = 0; t < v.uvs.length; t++) v.uvs[t].length && E++;
                    for (t = 0; t < E; t++) y.faceVertexUvs[t] = []
                }
                for (r = 0, o = a.length; r < o;)(t = new THREE.Vector3).x = a[r++] * e, t.y = a[r++] * e, t.z = a[r++] * e, y.vertices.push(t);
                for (r = 0, o = p.length; r < o;)
                    if (c = 1 & (e = p[r++]), n = 2 & e, t = 8 & e, s = 16 & e, h = 32 & e, a = 64 & e, e &= 128, c) {
                        if ((c = new THREE.Face3).a = p[r], c.b = p[r + 1], c.c = p[r + 3], (u = new THREE.Face3).a = p[r + 1], u.b = p[r + 2], u.c = p[r + 3], r += 4, n && (n = p[r++], c.materialIndex = n, u.materialIndex = n), n = y.faces.length, t)
                            for (t = 0; t < E; t++)
                                for (f = v.uvs[t], y.faceVertexUvs[t][n] = [], y.faceVertexUvs[t][n + 1] = [], i = 0; i < 4; i++) d = f[2 * (l = p[r++])], l = f[2 * l + 1], d = new THREE.Vector2(d, l), 2 !== i && y.faceVertexUvs[t][n].push(d), 0 !== i && y.faceVertexUvs[t][n + 1].push(d);
                        if (s && (s = 3 * p[r++], c.normal.set(m[s++], m[s++], m[s]), u.normal.copy(c.normal)), h)
                            for (t = 0; t < 4; t++) s = 3 * p[r++], h = new THREE.Vector3(m[s++], m[s++], m[s]), 2 !== t && c.vertexNormals.push(h), 0 !== t && u.vertexNormals.push(h);
                        if (a && (a = g[a = p[r++]], c.color.setHex(a), u.color.setHex(a)), e)
                            for (t = 0; t < 4; t++) a = g[a = p[r++]], 2 !== t && c.vertexColors.push(new THREE.Color(a)), 0 !== t && u.vertexColors.push(new THREE.Color(a));
                        y.faces.push(c), y.faces.push(u)
                    } else {
                        if ((c = new THREE.Face3).a = p[r++], c.b = p[r++], c.c = p[r++], n && (n = p[r++], c.materialIndex = n), n = y.faces.length, t)
                            for (t = 0; t < E; t++)
                                for (f = v.uvs[t], y.faceVertexUvs[t][n] = [], i = 0; i < 3; i++) d = f[2 * (l = p[r++])], l = f[2 * l + 1], d = new THREE.Vector2(d, l), y.faceVertexUvs[t][n].push(d);
                        if (s && (s = 3 * p[r++], c.normal.set(m[s++], m[s++], m[s])), h)
                            for (t = 0; t < 3; t++) s = 3 * p[r++], h = new THREE.Vector3(m[s++], m[s++], m[s]), c.vertexNormals.push(h);
                        if (a && (a = p[r++], c.color.setHex(g[a])), e)
                            for (t = 0; t < 3; t++) a = p[r++], c.vertexColors.push(new THREE.Color(g[a]));
                        y.faces.push(c)
                    }
            }(t),
            function () {
                if (v.skinWeights)
                    for (var e = 0, t = v.skinWeights.length; e < t; e += 2) y.skinWeights.push(new THREE.Vector4(v.skinWeights[e], v.skinWeights[e + 1], 0, 0));
                if (v.skinIndices)
                    for (e = 0, t = v.skinIndices.length; e < t; e += 2) y.skinIndices.push(new THREE.Vector4(v.skinIndices[e], v.skinIndices[e + 1], 0, 0));
                y.bones = v.bones, y.bones && 0 < y.bones.length && (y.skinWeights.length !== y.skinIndices.length || y.skinIndices.length !== y.vertices.length) && console.warn("When skinning, number of vertices (" + y.vertices.length + "), skinIndices (" + y.skinIndices.length + "), and skinWeights (" + y.skinWeights.length + ") should match."), y.animation = v.animation, y.animations = v.animations
            }(),
            function (e) {
                var t, i, n, r, o, a;
                if (void 0 !== v.morphTargets)
                    for (t = 0, i = v.morphTargets.length; t < i; t++)
                        for (y.morphTargets[t] = {}, y.morphTargets[t].name = v.morphTargets[t].name, y.morphTargets[t].vertices = [], o = y.morphTargets[t].vertices, n = 0, r = (a = v.morphTargets[t].vertices).length; n < r; n += 3) {
                            var s = new THREE.Vector3;
                            s.x = a[n] * e, s.y = a[n + 1] * e, s.z = a[n + 2] * e, o.push(s)
                        }
                if (void 0 !== v.morphColors)
                    for (t = 0, i = v.morphColors.length; t < i; t++)
                        for (y.morphColors[t] = {}, y.morphColors[t].name = v.morphColors[t].name, y.morphColors[t].colors = [], r = y.morphColors[t].colors, e = 0, n = (o = v.morphColors[t].colors).length; e < n; e += 3)(a = new THREE.Color(16755200)).setRGB(o[e], o[e + 1], o[e + 2]), r.push(a)
            }(t), y.computeCentroids(), y.computeFaceNormals(), y.computeBoundingSphere(), void 0 === v.materials ? {
                geometry: y
            } : (t = this.initMaterials(v.materials, e), this.needsTangents(t) && y.computeTangents(), {
                geometry: y,
                materials: t
            })
    }, THREE.LoadingManager = function (e, t, i) {
        var n = this,
            r = 0,
            o = 0;
        this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (e) {
            o++
        }, this.itemEnd = function (e) {
            r++, void 0 !== n.onProgress && n.onProgress(e, r, o), r === o && void 0 !== n.onLoad && n.onLoad()
        }
    }, THREE.DefaultLoadingManager = new THREE.LoadingManager, THREE.BufferGeometryLoader = function (e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.BufferGeometryLoader.prototype = {
        constructor: THREE.BufferGeometryLoader,
        load: function (e, t, i, n) {
            var r = this;
            (i = new THREE.XHRLoader).setCrossOrigin(this.crossOrigin), i.load(e, function (e) {
                t(r.parse(JSON.parse(e)))
            })
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        },
        parse: function (e) {
            var t = new THREE.BufferGeometry,
                i = e.attributes,
                n = e.offsets;
            for (var r in e = e.boundingSphere, i) {
                var o = i[r];
                t.attributes[r] = {
                    itemSize: o.itemSize,
                    array: new self[o.type](o.array)
                }
            }
            return void 0 !== n && (t.offsets = JSON.parse(JSON.stringify(n))), void 0 !== e && (t.boundingSphere = new THREE.Sphere((new THREE.Vector3).fromArray(void 0 !== e.center ? e.center : [0, 0, 0]), e.radius)), t
        }
    }, THREE.Geometry2Loader = function (e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.Geometry2Loader.prototype = {
        constructor: THREE.Geometry2Loader,
        load: function (e, t, i, n) {
            var r = this;
            (i = new THREE.XHRLoader).setCrossOrigin(this.crossOrigin), i.load(e, function (e) {
                t(r.parse(JSON.parse(e)))
            })
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        },
        parse: function (e) {
            var t, i = new THREE.Geometry2(e.vertices.length / 3),
                n = ["vertices", "normals", "uvs"],
                r = e.boundingSphere;
            for (t in n) {
                var o = n[t];
                i[o].set(e[o])
            }
            return void 0 !== r && (i.boundingSphere = new THREE.Sphere((new THREE.Vector3).fromArray(void 0 !== r.center ? r.center : [0, 0, 0]), r.radius)), i
        }
    }, THREE.MaterialLoader = function (e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.MaterialLoader.prototype = {
        constructor: THREE.MaterialLoader,
        load: function (e, t, i, n) {
            var r = this;
            (i = new THREE.XHRLoader).setCrossOrigin(this.crossOrigin), i.load(e, function (e) {
                t(r.parse(JSON.parse(e)))
            })
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        },
        parse: function (e) {
            var t = new THREE[e.type];
            if (void 0 !== e.color && t.color.setHex(e.color), void 0 !== e.ambient && t.ambient.setHex(e.ambient), void 0 !== e.emissive && t.emissive.setHex(e.emissive), void 0 !== e.specular && t.specular.setHex(e.specular), void 0 !== e.shininess && (t.shininess = e.shininess), void 0 !== e.vertexColors && (t.vertexColors = e.vertexColors), void 0 !== e.blending && (t.blending = e.blending), void 0 !== e.side && (t.side = e.side), void 0 !== e.opacity && (t.opacity = e.opacity), void 0 !== e.transparent && (t.transparent = e.transparent), void 0 !== e.wireframe && (t.wireframe = e.wireframe), void 0 !== e.materials)
                for (var i = 0, n = e.materials.length; i < n; i++) t.materials.push(this.parse(e.materials[i]));
            return t
        }
    }, THREE.ObjectLoader = function (e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.ObjectLoader.prototype = {
        constructor: THREE.ObjectLoader,
        load: function (e, t, i, n) {
            var r = this;
            (i = new THREE.XHRLoader(r.manager)).setCrossOrigin(this.crossOrigin), i.load(e, function (e) {
                t(r.parse(JSON.parse(e)))
            })
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        },
        parse: function (e) {
            var t = this.parseGeometries(e.geometries),
                i = this.parseMaterials(e.materials);
            return this.parseObject(e.object, t, i)
        },
        parseGeometries: function (e) {
            var t = {};
            if (void 0 !== e)
                for (var i = new THREE.JSONLoader, n = new THREE.Geometry2Loader, r = new THREE.BufferGeometryLoader, o = 0, a = e.length; o < a; o++) {
                    var s, l = e[o];
                    switch (l.type) {
                        case "PlaneGeometry":
                            s = new THREE.PlaneGeometry(l.width, l.height, l.widthSegments, l.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "CubeGeometry":
                            s = new THREE.BoxGeometry(l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                            break;
                        case "CircleGeometry":
                            s = new THREE.CircleGeometry(l.radius, l.segments);
                            break;
                        case "CylinderGeometry":
                            s = new THREE.CylinderGeometry(l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded);
                            break;
                        case "SphereGeometry":
                            s = new THREE.SphereGeometry(l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                            break;
                        case "IcosahedronGeometry":
                            s = new THREE.IcosahedronGeometry(l.radius, l.detail);
                            break;
                        case "TorusGeometry":
                            s = new THREE.TorusGeometry(l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                            break;
                        case "TorusKnotGeometry":
                            s = new THREE.TorusKnotGeometry(l.radius, l.tube, l.radialSegments, l.tubularSegments, l.p, l.q, l.heightScale);
                            break;
                        case "BufferGeometry":
                            s = r.parse(l.data);
                            break;
                        case "Geometry2":
                            s = n.parse(l.data);
                            break;
                        case "Geometry":
                            s = i.parse(l.data).geometry
                    }
                    s.uuid = l.uuid, void 0 !== l.name && (s.name = l.name), t[l.uuid] = s
                }
            return t
        },
        parseMaterials: function (e) {
            var t = {};
            if (void 0 !== e)
                for (var i = new THREE.MaterialLoader, n = 0, r = e.length; n < r; n++) {
                    var o = e[n],
                        a = i.parse(o);
                    a.uuid = o.uuid, void 0 !== o.name && (a.name = o.name), t[o.uuid] = a
                }
            return t
        },
        parseObject: function () {
            var a = new THREE.Matrix4;
            return function (e, t, i) {
                var n;
                switch (e.type) {
                    case "Scene":
                        n = new THREE.Scene;
                        break;
                    case "PerspectiveCamera":
                        n = new THREE.PerspectiveCamera(e.fov, e.aspect, e.near, e.far);
                        break;
                    case "OrthographicCamera":
                        n = new THREE.OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far);
                        break;
                    case "AmbientLight":
                        n = new THREE.AmbientLight(e.color);
                        break;
                    case "DirectionalLight":
                        n = new THREE.DirectionalLight(e.color, e.intensity);
                        break;
                    case "PointLight":
                        n = new THREE.PointLight(e.color, e.intensity, e.distance);
                        break;
                    case "SpotLight":
                        n = new THREE.SpotLight(e.color, e.intensity, e.distance, e.angle, e.exponent);
                        break;
                    case "HemisphereLight":
                        n = new THREE.HemisphereLight(e.color, e.groundColor, e.intensity);
                        break;
                    case "Mesh":
                        n = t[e.geometry];
                        var r = i[e.material];
                        void 0 === n && console.error("THREE.ObjectLoader: Undefined geometry " + e.geometry), void 0 === r && console.error("THREE.ObjectLoader: Undefined material " + e.material), n = new THREE.Mesh(n, r);
                        break;
                    case "Sprite":
                        void 0 === (r = i[e.material]) && console.error("THREE.ObjectLoader: Undefined material " + e.material), n = new THREE.Sprite(r);
                        break;
                    default:
                        n = new THREE.Object3D
                }
                if (n.uuid = e.uuid, void 0 !== e.name && (n.name = e.name), void 0 !== e.matrix ? (a.fromArray(e.matrix), a.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position), void 0 !== e.rotation && n.rotation.fromArray(e.rotation), void 0 !== e.scale && n.scale.fromArray(e.scale)), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.children)
                    for (var o in e.children) n.add(this.parseObject(e.children[o], t, i));
                return n
            }
        }()
    }, THREE.SceneLoader = function () {
        this.onLoadStart = function () {}, this.onLoadProgress = function () {}, this.onLoadComplete = function () {}, this.callbackSync = function () {}, this.callbackProgress = function () {}, this.geometryHandlers = {}, this.hierarchyHandlers = {}, this.addGeometryHandler("ascii", THREE.JSONLoader)
    }, THREE.SceneLoader.prototype = {
        constructor: THREE.SceneLoader,
        load: function (t, i, e, n) {
            var r = this;
            (e = new THREE.XHRLoader(r.manager)).setCrossOrigin(this.crossOrigin), e.load(t, function (e) {
                r.parse(JSON.parse(e), i, t)
            })
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        },
        addGeometryHandler: function (e, t) {
            this.geometryHandlers[e] = {
                loaderClass: t
            }
        },
        addHierarchyHandler: function (e, t) {
            this.hierarchyHandlers[e] = {
                loaderClass: t
            }
        },
        parse: function (e, n, t) {
            function p(e, t) {
                return "relativeToHTML" == t ? e : _ + e
            }

            function c() {
                ! function e(t, i) {
                    var n, r, o, a, s, l;
                    for (l in i) {
                        var c = T.objects[l],
                            h = i[l];
                        if (void 0 === c) {
                            if (h.type && h.type in w.hierarchyHandlers) {
                                if (void 0 === h.loading) {
                                    n = {
                                        type: 1,
                                        url: 1,
                                        material: 1,
                                        position: 1,
                                        rotation: 1,
                                        scale: 1,
                                        visible: 1,
                                        children: 1,
                                        userData: 1,
                                        skin: 1,
                                        morph: 1,
                                        mirroredLoop: 1,
                                        duration: 1
                                    };
                                    var u, f = {};
                                    for (u in h) u in n || (f[u] = h[u]);
                                    E = T.materials[h.material], h.loading = !0, (n = w.hierarchyHandlers[h.type].loaderObject).options ? n.load(p(h.url, S.urlBaseType), m(l, t, E, h)) : n.load(p(h.url, S.urlBaseType), m(l, t, E, h), f)
                                }
                            } else if (void 0 !== h.geometry) {
                                if (g = T.geometries[h.geometry]) {
                                    if (c = !1, E = T.materials[h.material], c = E instanceof THREE.ShaderMaterial, r = h.position, o = h.rotation, a = h.scale, n = h.matrix, s = h.quaternion, h.material || (E = new THREE.MeshFaceMaterial(T.face_materials[h.geometry])), E instanceof THREE.MeshFaceMaterial && 0 === E.materials.length && (E = new THREE.MeshFaceMaterial(T.face_materials[h.geometry])), E instanceof THREE.MeshFaceMaterial)
                                        for (f = 0; f < E.materials.length; f++) c = c || E.materials[f] instanceof THREE.ShaderMaterial;
                                    c && g.computeTangents(), h.skin ? c = new THREE.SkinnedMesh(g, E) : h.morph ? (c = new THREE.MorphAnimMesh(g, E), void 0 !== h.duration && (c.duration = h.duration), void 0 !== h.time && (c.time = h.time), void 0 !== h.mirroredLoop && (c.mirroredLoop = h.mirroredLoop), E.morphNormals && g.computeMorphNormals()) : c = new THREE.Mesh(g, E), c.name = l, n ? (c.matrixAutoUpdate = !1, c.matrix.set(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15])) : (c.position.fromArray(r), s ? c.quaternion.fromArray(s) : c.rotation.fromArray(o), c.scale.fromArray(a)), c.visible = h.visible, c.castShadow = h.castShadow, c.receiveShadow = h.receiveShadow, t.add(c), T.objects[l] = c
                                }
                            } else if ("AmbientLight" === h.type || "PointLight" === h.type || "DirectionalLight" === h.type || "SpotLight" === h.type || "HemisphereLight" === h.type || "AreaLight" === h.type) {
                                switch (f = h.color, n = h.intensity, r = h.distance, o = h.position, a = h.rotation, h.type) {
                                    case "AmbientLight":
                                        y = new THREE.AmbientLight(f);
                                        break;
                                    case "PointLight":
                                        (y = new THREE.PointLight(f, n, r)).position.fromArray(o);
                                        break;
                                    case "DirectionalLight":
                                        (y = new THREE.DirectionalLight(f, n)).position.fromArray(h.direction);
                                        break;
                                    case "SpotLight":
                                        (y = new THREE.SpotLight(f, n, r, 1)).angle = h.angle, y.position.fromArray(o), y.target.set(o[0], o[1] - r, o[2]), y.target.applyEuler(new THREE.Euler(a[0], a[1], a[2], "XYZ"));
                                        break;
                                    case "HemisphereLight":
                                        (y = new THREE.DirectionalLight(f, n, r)).target.set(o[0], o[1] - r, o[2]), y.target.applyEuler(new THREE.Euler(a[0], a[1], a[2], "XYZ"));
                                        break;
                                    case "AreaLight":
                                        (y = new THREE.AreaLight(f, n)).position.fromArray(o), y.width = h.size, y.height = h.size_y
                                }
                                t.add(y), y.name = l, T.lights[l] = y, T.objects[l] = y
                            } else "PerspectiveCamera" === h.type || "OrthographicCamera" === h.type ? (r = h.position, o = h.rotation, s = h.quaternion, "PerspectiveCamera" === h.type ? v = new THREE.PerspectiveCamera(h.fov, h.aspect, h.near, h.far) : "OrthographicCamera" === h.type && (v = new THREE.OrthographicCamera(h.left, h.right, h.top, h.bottom, h.near, h.far)), v.name = l, v.position.fromArray(r), void 0 !== s ? v.quaternion.fromArray(s) : void 0 !== o && v.rotation.fromArray(o), t.add(v), T.cameras[l] = v, T.objects[l] = v) : (r = h.position, o = h.rotation, a = h.scale, s = h.quaternion, (c = new THREE.Object3D).name = l, c.position.fromArray(r), s ? c.quaternion.fromArray(s) : c.rotation.fromArray(o), c.scale.fromArray(a), c.visible = void 0 !== h.visible && h.visible, t.add(c), T.objects[l] = c, T.empties[l] = c);
                            if (c) {
                                if (void 0 !== h.userData)
                                    for (var d in h.userData) c.userData[d] = h.userData[d];
                                if (void 0 !== h.groups)
                                    for (f = 0; f < h.groups.length; f++) n = h.groups[f], void 0 === T.groups[n] && (T.groups[n] = []), T.groups[n].push(l)
                            }
                        }
                        void 0 !== c && void 0 !== h.children && e(c, h.children)
                    }
                }(T.scene, S.objects)
            }

            function i(i) {
                return function (e, t) {
                    e.name = i, T.geometries[i] = e, T.face_materials[i] = t, c(), h -= 1, w.onLoadComplete(), o()
                }
            }

            function m(t, i, n, r) {
                return function (e) {
                    ! function (e, t, i, n, r) {
                        var o = r.rotation,
                            a = r.quaternion,
                            s = r.scale;
                        e.position.fromArray(r.position), a ? e.quaternion.fromArray(a) : e.rotation.fromArray(o), e.scale.fromArray(s), n && e.traverse(function (e) {
                            e.material = n
                        });
                        var l = void 0 === r.visible || r.visible;
                        e.traverse(function (e) {
                            e.visible = l
                        }), i.add(e), e.name = t, T.objects[t] = e, c()
                    }(e.content ? e.content : e.dae ? e.scene : e, t, i, n, r), h -= 1, w.onLoadComplete(), o()
                }
            }

            function r(i) {
                return function (e, t) {
                    e.name = i, T.geometries[i] = e, T.face_materials[i] = t
                }
            }

            function o() {
                if (w.callbackProgress({
                        totalModels: f,
                        totalTextures: d,
                        loadedModels: f - h,
                        loadedTextures: d - u
                    }, T), w.onLoadProgress(), 0 === h && 0 === u) {
                    for (var e = 0; e < H.length; e++) {
                        var t = H[e],
                            i = T.objects[t.targetName];
                        i ? t.object.target = i : (t.object.target = new THREE.Object3D, T.scene.add(t.object.target)), t.object.target.userData.targetInverse = t.object
                    }
                    n(T)
                }
            }

            function a(e, t) {
                if (t(e), void 0 !== e.children)
                    for (var i in e.children) a(e.children[i], t)
            }
            var g, E, v, s, l, y, h, u, f, d, T, b, x, R, w = this,
                _ = THREE.Loader.prototype.extractUrlBase(t),
                H = [],
                S = e;
            for (b in this.geometryHandlers) e = this.geometryHandlers[b].loaderClass, this.geometryHandlers[b].loaderObject = new e;
            for (b in this.hierarchyHandlers) e = this.hierarchyHandlers[b].loaderClass, this.hierarchyHandlers[b].loaderObject = new e;
            for (var M in u = h = 0, T = {
                    scene: new THREE.Scene,
                    geometries: {},
                    face_materials: {},
                    materials: {},
                    textures: {},
                    objects: {},
                    cameras: {},
                    lights: {},
                    fogs: {},
                    empties: {},
                    groups: {}
                }, S.transform && (b = S.transform.position, e = S.transform.rotation, t = S.transform.scale, b && T.scene.position.fromArray(b), e && T.scene.rotation.fromArray(e), t && T.scene.scale.fromArray(t), b || e || t) && (T.scene.updateMatrix(), T.scene.updateMatrixWorld()), b = function (e) {
                    return function () {
                        u -= e, o(), w.onLoadComplete()
                    }
                }, S.fogs) "linear" === (e = S.fogs[M]).type ? s = new THREE.Fog(0, e.near, e.far) : "exp2" === e.type && (s = new THREE.FogExp2(0, e.density)), e = e.color, s.color.setRGB(e[0], e[1], e[2]), T.fogs[M] = s;
            for (var C in S.geometries)(s = S.geometries[C]).type in this.geometryHandlers && (h += 1, w.onLoadStart());
            for (var A in S.objects) a(S.objects[A], function (e) {
                e.type && e.type in w.hierarchyHandlers && (h += 1, w.onLoadStart())
            });
            for (C in f = h, S.geometries)
                if ("cube" === (s = S.geometries[C]).type)(g = new THREE.BoxGeometry(s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments)).name = C, T.geometries[C] = g;
                else if ("plane" === s.type)(g = new THREE.PlaneGeometry(s.width, s.height, s.widthSegments, s.heightSegments)).name = C, T.geometries[C] = g;
            else if ("sphere" === s.type)(g = new THREE.SphereGeometry(s.radius, s.widthSegments, s.heightSegments)).name = C, T.geometries[C] = g;
            else if ("cylinder" === s.type)(g = new THREE.CylinderGeometry(s.topRad, s.botRad, s.height, s.radSegs, s.heightSegs)).name = C, T.geometries[C] = g;
            else if ("torus" === s.type)(g = new THREE.TorusGeometry(s.radius, s.tube, s.segmentsR, s.segmentsT)).name = C, T.geometries[C] = g;
            else if ("icosahedron" === s.type)(g = new THREE.IcosahedronGeometry(s.radius, s.subdivisions)).name = C, T.geometries[C] = g;
            else if (s.type in this.geometryHandlers) {
                for (l in A = {}, s) "type" !== l && "url" !== l && (A[l] = s[l]);
                this.geometryHandlers[s.type].loaderObject.load(p(s.url, S.urlBaseType), i(C), A)
            } else "embedded" === s.type && ((A = S.embeds[s.id]).metadata = S.metadata, A && (A = this.geometryHandlers.ascii.loaderObject.parse(A, ""), r(C)(A.geometry, A.materials)));
            for (var P in S.textures)
                if ((C = S.textures[P]).url instanceof Array)
                    for (u += C.url.length, l = 0; l < C.url.length; l++) w.onLoadStart();
                else u += 1, w.onLoadStart();
            for (P in d = u, S.textures) {
                if (void 0 !== (C = S.textures[P]).mapping && void 0 !== THREE[C.mapping] && (C.mapping = new THREE[C.mapping]), C.url instanceof Array) {
                    for (A = C.url.length, s = [], l = 0; l < A; l++) s[l] = p(C.url[l], S.urlBaseType);
                    l = (l = /\.dds$/i.test(s[0])) ? THREE.ImageUtils.loadCompressedTextureCube(s, C.mapping, b(A)) : THREE.ImageUtils.loadTextureCube(s, C.mapping, b(A))
                } else l = /\.dds$/i.test(C.url), A = p(C.url, S.urlBaseType), s = b(1), l = l ? THREE.ImageUtils.loadCompressedTexture(A, C.mapping, s) : THREE.ImageUtils.loadTexture(A, C.mapping, s), void 0 !== THREE[C.minFilter] && (l.minFilter = THREE[C.minFilter]), void 0 !== THREE[C.magFilter] && (l.magFilter = THREE[C.magFilter]), C.anisotropy && (l.anisotropy = C.anisotropy), C.repeat && (l.repeat.set(C.repeat[0], C.repeat[1]), 1 !== C.repeat[0] && (l.wrapS = THREE.RepeatWrapping), 1 !== C.repeat[1] && (l.wrapT = THREE.RepeatWrapping)), C.offset && l.offset.set(C.offset[0], C.offset[1]), C.wrap && (void 0 !== (A = {
                    repeat: THREE.RepeatWrapping,
                    mirror: THREE.MirroredRepeatWrapping
                })[C.wrap[0]] && (l.wrapS = A[C.wrap[0]]), void 0 !== A[C.wrap[1]] && (l.wrapT = A[C.wrap[1]]));
                T.textures[P] = l
            }
            for (x in S.materials) {
                for (R in (P = S.materials[x]).parameters) "envMap" === R || "map" === R || "lightMap" === R || "bumpMap" === R ? P.parameters[R] = T.textures[P.parameters[R]] : "shading" === R ? P.parameters[R] = "flat" === P.parameters[R] ? THREE.FlatShading : THREE.SmoothShading : "side" === R ? P.parameters[R] = "double" == P.parameters[R] ? THREE.DoubleSide : "back" == P.parameters[R] ? THREE.BackSide : THREE.FrontSide : "blending" === R ? P.parameters[R] = P.parameters[R] in THREE ? THREE[P.parameters[R]] : THREE.NormalBlending : "combine" === R ? P.parameters[R] = P.parameters[R] in THREE ? THREE[P.parameters[R]] : THREE.MultiplyOperation : "vertexColors" === R ? "face" == P.parameters[R] ? P.parameters[R] = THREE.FaceColors : P.parameters[R] && (P.parameters[R] = THREE.VertexColors) : "wrapRGB" === R && (b = P.parameters[R], P.parameters[R] = new THREE.Vector3(b[0], b[1], b[2]));
                void 0 !== P.parameters.opacity && P.parameters.opacity < 1 && (P.parameters.transparent = !0), (E = P.parameters.normalMap ? (b = THREE.ShaderLib.normalmap, C = THREE.UniformsUtils.clone(b.uniforms), l = P.parameters.color, A = P.parameters.specular, s = P.parameters.ambient, M = P.parameters.shininess, C.tNormal.value = T.textures[P.parameters.normalMap], P.parameters.normalScale && C.uNormalScale.value.set(P.parameters.normalScale[0], P.parameters.normalScale[1]), P.parameters.map && (C.tDiffuse.value = P.parameters.map, C.enableDiffuse.value = !0), P.parameters.envMap && (C.tCube.value = P.parameters.envMap, C.enableReflection.value = !0, C.reflectivity.value = P.parameters.reflectivity), P.parameters.lightMap && (C.tAO.value = P.parameters.lightMap, C.enableAO.value = !0), P.parameters.specularMap && (C.tSpecular.value = T.textures[P.parameters.specularMap], C.enableSpecular.value = !0), P.parameters.displacementMap && (C.tDisplacement.value = T.textures[P.parameters.displacementMap], C.enableDisplacement.value = !0, C.uDisplacementBias.value = P.parameters.displacementBias, C.uDisplacementScale.value = P.parameters.displacementScale), C.diffuse.value.setHex(l), C.specular.value.setHex(A), C.ambient.value.setHex(s), C.shininess.value = M, P.parameters.opacity && (C.opacity.value = P.parameters.opacity), new THREE.ShaderMaterial({
                    fragmentShader: b.fragmentShader,
                    vertexShader: b.vertexShader,
                    uniforms: C,
                    lights: !0,
                    fog: !0
                })) : new THREE[P.type](P.parameters)).name = x, T.materials[x] = E
            }
            for (x in S.materials)
                if ((P = S.materials[x]).parameters.materials) {
                    for (R = [], l = 0; l < P.parameters.materials.length; l++) R.push(T.materials[P.parameters.materials[l]]);
                    T.materials[x].materials = R
                } c(), T.cameras && S.defaults.camera && (T.currentCamera = T.cameras[S.defaults.camera]), T.fogs && S.defaults.fog && (T.scene.fog = T.fogs[S.defaults.fog]), w.callbackSync(T), o()
        }
    }, THREE.TextureLoader = function (e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.TextureLoader.prototype = {
        constructor: THREE.TextureLoader,
        load: function (e, t, i, n) {
            (i = new THREE.ImageLoader(this.manager)).setCrossOrigin(this.crossOrigin), i.load(e, function (e) {
                (e = new THREE.Texture(e)).needsUpdate = !0, void 0 !== t && t(e)
            })
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        }
    }, THREE.Material = function () {
        this.id = THREE.MaterialIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, this.blendEquation = THREE.AddEquation, this.depthWrite = this.depthTest = !0, this.polygonOffset = !1, this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.needsUpdate = this.visible = !0
    }, THREE.Material.prototype = {
        constructor: THREE.Material,
        setValues: function (e) {
            if (void 0 !== e)
                for (var t in e) {
                    var i = e[t];
                    if (void 0 === i) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    else if (t in this) {
                        var n = this[t];
                        n instanceof THREE.Color ? n.set(i) : n instanceof THREE.Vector3 && i instanceof THREE.Vector3 ? n.copy(i) : this[t] = "overdraw" == t ? Number(i) : i
                    }
                }
        },
        clone: function (e) {
            return void 0 === e && (e = new THREE.Material), e.name = this.name, e.side = this.side, e.opacity = this.opacity, e.transparent = this.transparent, e.blending = this.blending, e.blendSrc = this.blendSrc, e.blendDst = this.blendDst, e.blendEquation = this.blendEquation, e.depthTest = this.depthTest, e.depthWrite = this.depthWrite, e.polygonOffset = this.polygonOffset, e.polygonOffsetFactor = this.polygonOffsetFactor, e.polygonOffsetUnits = this.polygonOffsetUnits, e.alphaTest = this.alphaTest, e.overdraw = this.overdraw, e.visible = this.visible, e
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, THREE.LineBasicMaterial = function (e) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.vertexColors = !1, this.fog = !0, this.setValues(e)
    }, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineBasicMaterial.prototype.clone = function () {
        var e = new THREE.LineBasicMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.linecap = this.linecap, e.linejoin = this.linejoin, e.vertexColors = this.vertexColors, e.fog = this.fog, e
    }, THREE.LineDashedMaterial = function (e) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, this.fog = !0, this.setValues(e)
    }, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineDashedMaterial.prototype.clone = function () {
        var e = new THREE.LineDashedMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.scale = this.scale, e.dashSize = this.dashSize, e.gapSize = this.gapSize, e.vertexColors = this.vertexColors, e.fog = this.fog, e
    }, THREE.MeshBasicMaterial = function (e) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.envMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphTargets = this.skinning = !1, this.setValues(e)
    }, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshBasicMaterial.prototype.clone = function () {
        var e = new THREE.MeshBasicMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e
    }, THREE.MeshLambertMaterial = function (e) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.envMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshLambertMaterial.prototype.clone = function () {
        var e = new THREE.MeshLambertMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.ambient.copy(this.ambient), e.emissive.copy(this.emissive), e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
    }, THREE.MeshPhongMaterial = function (e) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), this.shininess = 30, this.wrapAround = this.metal = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.bumpMap = this.lightMap = this.map = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.envMap = this.specularMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshPhongMaterial.prototype.clone = function () {
        var e = new THREE.MeshPhongMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.ambient.copy(this.ambient), e.emissive.copy(this.emissive), e.specular.copy(this.specular), e.shininess = this.shininess, e.metal = this.metal, e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.bumpMap = this.bumpMap, e.bumpScale = this.bumpScale, e.normalMap = this.normalMap, e.normalScale.copy(this.normalScale), e.specularMap = this.specularMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
    }, THREE.MeshDepthMaterial = function (e) {
        THREE.Material.call(this), this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
    }, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshDepthMaterial.prototype.clone = function () {
        var e = new THREE.MeshDepthMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
    }, THREE.MeshNormalMaterial = function (e) {
        THREE.Material.call(this, e), this.shading = THREE.FlatShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(e)
    }, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshNormalMaterial.prototype.clone = function () {
        var e = new THREE.MeshNormalMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
    }, THREE.MeshFaceMaterial = function (e) {
        this.materials = e instanceof Array ? e : []
    }, THREE.MeshFaceMaterial.prototype.clone = function () {
        for (var e = new THREE.MeshFaceMaterial, t = 0; t < this.materials.length; t++) e.materials.push(this.materials[t].clone());
        return e
    }, THREE.ParticleSystemMaterial = function (e) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = !1, this.fog = !0, this.setValues(e)
    }, THREE.ParticleSystemMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ParticleSystemMaterial.prototype.clone = function () {
        var e = new THREE.ParticleSystemMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.size = this.size, e.sizeAttenuation = this.sizeAttenuation, e.vertexColors = this.vertexColors, e.fog = this.fog, e
    }, THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial, THREE.ShaderMaterial = function (e) {
        THREE.Material.call(this), this.vertexShader = this.fragmentShader = "void main() {}", this.uniforms = {}, this.defines = {}, this.attributes = null, this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = "position", this.setValues(e)
    }, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.clone = function () {
        var e = new THREE.ShaderMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.fragmentShader = this.fragmentShader, e.vertexShader = this.vertexShader, e.uniforms = THREE.UniformsUtils.clone(this.uniforms), e.attributes = this.attributes, e.defines = this.defines, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.fog = this.fog, e.lights = this.lights, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
    }, THREE.SpriteMaterial = function (e) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(e)
    }, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.clone = function () {
        var e = new THREE.SpriteMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.rotation = this.rotation, e.fog = this.fog, e
    }, THREE.SpriteCanvasMaterial = function (e) {
        THREE.Material.call(this), this.color = new THREE.Color(16777215), this.program = function (e, t) {}, this.setValues(e)
    }, THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteCanvasMaterial.prototype.clone = function () {
        var e = new THREE.SpriteCanvasMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.program = this.program, e
    }, THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial, THREE.Texture = function (e, t, i, n, r, o, a, s, l) {
        this.id = THREE.TextureIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = void 0 !== t ? t : new THREE.UVMapping, this.wrapS = void 0 !== i ? i : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== n ? n : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== r ? r : THREE.LinearFilter, this.minFilter = void 0 !== o ? o : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== a ? a : THREE.RGBAFormat, this.type = void 0 !== s ? s : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null
    }, THREE.Texture.prototype = {
        constructor: THREE.Texture,
        get needsUpdate() {
            return this._needsUpdate
        },
        set needsUpdate(e) {
            !0 === e && this.update(), this._needsUpdate = e
        },
        clone: function (e) {
            return void 0 === e && (e = new THREE.Texture), e.image = this.image, e.mipmaps = this.mipmaps.slice(0), e.mapping = this.mapping, e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.format = this.format, e.type = this.type, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.generateMipmaps = this.generateMipmaps, e.premultiplyAlpha = this.premultiplyAlpha, e.flipY = this.flipY, e.unpackAlignment = this.unpackAlignment, e
        },
        update: function () {
            this.dispatchEvent({
                type: "update"
            })
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, THREE.CompressedTexture = function (e, t, i, n, r, o, a, s, l, c, h) {
        THREE.Texture.call(this, null, o, a, s, l, c, n, r, h), this.image = {
            width: t,
            height: i
        }, this.mipmaps = e, this.generateMipmaps = !1
    }, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.clone = function () {
        var e = new THREE.CompressedTexture;
        return THREE.Texture.prototype.clone.call(this, e), e
    }, THREE.DataTexture = function (e, t, i, n, r, o, a, s, l, c, h) {
        THREE.Texture.call(this, null, o, a, s, l, c, n, r, h), this.image = {
            data: e,
            width: t,
            height: i
        }
    }, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.clone = function () {
        var e = new THREE.DataTexture;
        return THREE.Texture.prototype.clone.call(this, e), e
    }, THREE.ParticleSystem = function (e, t) {
        THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.ParticleSystemMaterial({
            color: 16777215 * Math.random()
        }), this.frustumCulled = this.sortParticles = !1
    }, THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype), THREE.ParticleSystem.prototype.clone = function (e) {
        return void 0 === e && (e = new THREE.ParticleSystem(this.geometry, this.material)), e.sortParticles = this.sortParticles, THREE.Object3D.prototype.clone.call(this, e), e
    }, THREE.Line = function (e, t, i) {
        THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.LineBasicMaterial({
            color: 16777215 * Math.random()
        }), this.type = void 0 !== i ? i : THREE.LineStrip
    }, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), THREE.Line.prototype.clone = function (e) {
        return void 0 === e && (e = new THREE.Line(this.geometry, this.material, this.type)), THREE.Object3D.prototype.clone.call(this, e), e
    }, THREE.Mesh = function (e, t) {
        THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.MeshBasicMaterial({
            color: 16777215 * Math.random()
        }), this.updateMorphTargets()
    }, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.updateMorphTargets = function () {
        if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
            this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (var e = 0, t = this.geometry.morphTargets.length; e < t; e++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e
        }
    }, THREE.Mesh.prototype.getMorphTargetIndexByName = function (e) {
        return void 0 !== this.morphTargetDictionary[e] ? this.morphTargetDictionary[e] : (console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0)
    }, THREE.Mesh.prototype.clone = function (e) {
        return void 0 === e && (e = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, e), e
    }, THREE.Bone = function (e) {
        THREE.Object3D.call(this), this.skin = e, this.skinMatrix = new THREE.Matrix4
    }, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.update = function (e, t) {
        this.matrixAutoUpdate && (t |= this.updateMatrix()), (t || this.matrixWorldNeedsUpdate) && (e ? this.skinMatrix.multiplyMatrices(e, this.matrix) : this.skinMatrix.copy(this.matrix), t = !(this.matrixWorldNeedsUpdate = !1));
        var i, n = this.children.length;
        for (i = 0; i < n; i++) this.children[i].update(this.skinMatrix, t)
    }, THREE.SkinnedMesh = function (e, t, i) {
        var n, r, o;
        if (THREE.Mesh.call(this, e, t), this.useVertexTexture = void 0 === i || i, this.identityMatrix = new THREE.Matrix4, this.bones = [], this.boneMatrices = [], this.geometry && void 0 !== this.geometry.bones) {
            for (e = 0; e < this.geometry.bones.length; e++) n = (i = this.geometry.bones[e]).pos, r = i.rotq, o = i.scl, (t = this.addBone()).name = i.name, t.position.set(n[0], n[1], n[2]), t.quaternion.set(r[0], r[1], r[2], r[3]), void 0 !== o ? t.scale.set(o[0], o[1], o[2]) : t.scale.set(1, 1, 1);
            for (e = 0; e < this.bones.length; e++) i = this.geometry.bones[e], t = this.bones[e], -1 === i.parent ? this.add(t) : this.bones[i.parent].add(t);
            e = this.bones.length, this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = e = 256 < e ? 64 : 64 < e ? 32 : 16 < e ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * e), this.pose()
        }
    }, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.addBone = function (e) {
        return void 0 === e && (e = new THREE.Bone(this)), this.bones.push(e), e
    }, THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {
        var n = new THREE.Matrix4;
        return function (e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1), e = 0;
            for (var t = this.children.length; e < t; e++) {
                var i = this.children[e];
                i instanceof THREE.Bone ? i.update(this.identityMatrix, !1) : i.updateMatrixWorld(!0)
            }
            if (null == this.boneInverses)
                for (this.boneInverses = [], e = 0, t = this.bones.length; e < t; e++)(i = new THREE.Matrix4).getInverse(this.bones[e].skinMatrix), this.boneInverses.push(i);
            for (e = 0, t = this.bones.length; e < t; e++) n.multiplyMatrices(this.bones[e].skinMatrix, this.boneInverses[e]), n.flattenToArrayOffset(this.boneMatrices, 16 * e);
            this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
        }
    }(), THREE.SkinnedMesh.prototype.pose = function () {
        this.updateMatrixWorld(!0), this.normalizeSkinWeights()
    }, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
        if (this.geometry instanceof THREE.Geometry)
            for (var e = 0; e < this.geometry.skinIndices.length; e++) {
                var t = this.geometry.skinWeights[e],
                    i = 1 / t.lengthManhattan();
                1 / 0 !== i ? t.multiplyScalar(i) : t.set(1)
            }
    }, THREE.SkinnedMesh.prototype.clone = function (e) {
        return void 0 === e && (e = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), THREE.Mesh.prototype.clone.call(this, e), e
    }, THREE.MorphAnimMesh = function (e, t) {
        THREE.Mesh.call(this, e, t), this.duration = 1e3, this.mirroredLoop = !1, this.currentKeyframe = this.lastKeyframe = this.time = 0, this.direction = 1, this.directionBackwards = !1, this.setFrameRange(0, this.geometry.morphTargets.length - 1)
    }, THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphAnimMesh.prototype.setFrameRange = function (e, t) {
        this.startKeyframe = e, this.endKeyframe = t, this.length = this.endKeyframe - this.startKeyframe + 1
    }, THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
        this.direction = 1, this.directionBackwards = !1
    }, THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
        this.direction = -1, this.directionBackwards = !0
    }, THREE.MorphAnimMesh.prototype.parseAnimations = function () {
        var e = this.geometry;
        e.animations || (e.animations = {});
        for (var t, i = e.animations, n = /([a-z]+)(\d+)/, r = 0, o = e.morphTargets.length; r < o; r++) {
            var a = e.morphTargets[r].name.match(n);
            if (a && 1 < a.length) {
                i[a = a[1]] || (i[a] = {
                    start: 1 / 0,
                    end: -1 / 0
                });
                var s = i[a];
                r < s.start && (s.start = r), r > s.end && (s.end = r), t || (t = a)
            }
        }
        e.firstAnimation = t
    }, THREE.MorphAnimMesh.prototype.setAnimationLabel = function (e, t, i) {
        this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[e] = {
            start: t,
            end: i
        }
    }, THREE.MorphAnimMesh.prototype.playAnimation = function (e, t) {
        var i = this.geometry.animations[e];
        i ? (this.setFrameRange(i.start, i.end), this.duration = (i.end - i.start) / t * 1e3, this.time = 0) : console.warn("animation[" + e + "] undefined")
    }, THREE.MorphAnimMesh.prototype.updateAnimation = function (e) {
        var t = this.duration / this.length;
        this.time += this.direction * e, this.mirroredLoop ? (this.time > this.duration || this.time < 0) && (this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), this.time < 0 && (this.time = 0, this.directionBackwards = !1)) : (this.time %= this.duration, this.time < 0 && (this.time += this.duration)), (e = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / t), 0, this.length - 1)) !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[e] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = e), t = this.time % t / t, this.directionBackwards && (t = 1 - t), this.morphTargetInfluences[this.currentKeyframe] = t, this.morphTargetInfluences[this.lastKeyframe] = 1 - t
    }, THREE.MorphAnimMesh.prototype.clone = function (e) {
        return void 0 === e && (e = new THREE.MorphAnimMesh(this.geometry, this.material)), e.duration = this.duration, e.mirroredLoop = this.mirroredLoop, e.time = this.time, e.lastKeyframe = this.lastKeyframe, e.currentKeyframe = this.currentKeyframe, e.direction = this.direction, e.directionBackwards = this.directionBackwards, THREE.Mesh.prototype.clone.call(this, e), e
    }, THREE.LOD = function () {
        THREE.Object3D.call(this), this.objects = []
    }, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.addLevel = function (e, t) {
        void 0 === t && (t = 0), t = Math.abs(t);
        for (var i = 0; i < this.objects.length && !(t < this.objects[i].distance); i++);
        this.objects.splice(i, 0, {
            distance: t,
            object: e
        }), this.add(e)
    }, THREE.LOD.prototype.getObjectForDistance = function (e) {
        for (var t = 1, i = this.objects.length; t < i && !(e < this.objects[t].distance); t++);
        return this.objects[t - 1].object
    }, THREE.LOD.prototype.update = function () {
        var n = new THREE.Vector3,
            r = new THREE.Vector3;
        return function (e) {
            if (1 < this.objects.length) {
                n.setFromMatrixPosition(e.matrixWorld), r.setFromMatrixPosition(this.matrixWorld), e = n.distanceTo(r), this.objects[0].object.visible = !0;
                for (var t = 1, i = this.objects.length; t < i && e >= this.objects[t].distance; t++) this.objects[t - 1].object.visible = !1, this.objects[t].object.visible = !0;
                for (; t < i; t++) this.objects[t].object.visible = !1
            }
        }
    }(), THREE.LOD.prototype.clone = function (e) {
        void 0 === e && (e = new THREE.LOD), THREE.Object3D.prototype.clone.call(this, e);
        for (var t = 0, i = this.objects.length; t < i; t++) {
            var n = this.objects[t].object.clone();
            n.visible = 0 === t, e.addLevel(n, this.objects[t].distance)
        }
        return e
    }, THREE.Sprite = function () {
        var t = new THREE.Geometry2(3);
        return t.vertices.set([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0]),
            function (e) {
                THREE.Object3D.call(this), this.geometry = t, this.material = void 0 !== e ? e : new THREE.SpriteMaterial
            }
    }(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.updateMatrix = function () {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }, THREE.Sprite.prototype.clone = function (e) {
        return void 0 === e && (e = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, e), e
    }, THREE.Particle = THREE.Sprite, THREE.Scene = function () {
        THREE.Object3D.call(this), this.overrideMaterial = this.fog = null, this.autoUpdate = !0, this.matrixAutoUpdate = !1, this.__lights = [], this.__objectsAdded = [], this.__objectsRemoved = []
    }, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.__addObject = function (e) {
        if (e instanceof THREE.Light) - 1 === this.__lights.indexOf(e) && this.__lights.push(e), e.target && void 0 === e.target.parent && this.add(e.target);
        else if (!(e instanceof THREE.Camera || e instanceof THREE.Bone)) {
            this.__objectsAdded.push(e);
            var t = this.__objectsRemoved.indexOf(e); - 1 !== t && this.__objectsRemoved.splice(t, 1)
        }
        for (this.dispatchEvent({
                type: "objectAdded",
                object: e
            }), e.dispatchEvent({
                type: "addedToScene",
                scene: this
            }), t = 0; t < e.children.length; t++) this.__addObject(e.children[t])
    }, THREE.Scene.prototype.__removeObject = function (e) {
        if (e instanceof THREE.Light) {
            var t = this.__lights.indexOf(e);
            if (-1 !== t && this.__lights.splice(t, 1), e.shadowCascadeArray)
                for (t = 0; t < e.shadowCascadeArray.length; t++) this.__removeObject(e.shadowCascadeArray[t])
        } else e instanceof THREE.Camera || (this.__objectsRemoved.push(e), -1 !== (t = this.__objectsAdded.indexOf(e)) && this.__objectsAdded.splice(t, 1));
        for (this.dispatchEvent({
                type: "objectRemoved",
                object: e
            }), e.dispatchEvent({
                type: "removedFromScene",
                scene: this
            }), t = 0; t < e.children.length; t++) this.__removeObject(e.children[t])
    }, THREE.Scene.prototype.clone = function (e) {
        return void 0 === e && (e = new THREE.Scene), THREE.Object3D.prototype.clone.call(this, e), null !== this.fog && (e.fog = this.fog.clone()), null !== this.overrideMaterial && (e.overrideMaterial = this.overrideMaterial.clone()), e.autoUpdate = this.autoUpdate, e.matrixAutoUpdate = this.matrixAutoUpdate, e
    }, THREE.Fog = function (e, t, i) {
        this.name = "", this.color = new THREE.Color(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3
    }, THREE.Fog.prototype.clone = function () {
        return new THREE.Fog(this.color.getHex(), this.near, this.far)
    }, THREE.FogExp2 = function (e, t) {
        this.name = "", this.color = new THREE.Color(e), this.density = void 0 !== t ? t : 25e-5
    }, THREE.FogExp2.prototype.clone = function () {
        return new THREE.FogExp2(this.color.getHex(), this.density)
    }, THREE.CanvasRenderer = function (e) {
        function g(e, t, i) {
            for (var n = 0, r = O.length; n < r; n++) {
                var o = O[n];
                if (be.copy(o.color), o instanceof THREE.DirectionalLight) {
                    var a = Ce.setFromMatrixPosition(o.matrixWorld).normalize(),
                        s = t.dot(a);
                    s <= 0 || (s *= o.intensity, i.add(be.multiplyScalar(s)))
                } else o instanceof THREE.PointLight && (a = Ce.setFromMatrixPosition(o.matrixWorld), (s = t.dot(Ce.subVectors(a, e).normalize())) <= 0 || 0 != (s *= 0 == o.distance ? 1 : 1 - Math.min(e.distanceTo(a) / o.distance, 1)) && (s *= o.intensity, i.add(be.multiplyScalar(s))))
            }
        }

        function E(e, t, i, n) {
            S(t), M(i), C(n), A(e.getStyle()), G.stroke(), _e.expandByScalar(2 * t)
        }

        function v(e) {
            P(e.getStyle()), G.fill()
        }

        function y(e) {
            T(e.target)
        }

        function T(e) {
            var t = e.wrapS === THREE.RepeatWrapping,
                i = e.wrapT === THREE.RepeatWrapping,
                n = e.image,
                r = document.createElement("canvas");
            r.width = n.width, r.height = n.height;
            var o = r.getContext("2d");
            o.setTransform(1, 0, 0, -1, 0, n.height), o.drawImage(n, 0, 0), xe[e.id] = G.createPattern(r, !0 === t && !0 === i ? "repeat" : !0 === t && !1 === i ? "repeat-x" : !1 === t && !0 === i ? "repeat-y" : "no-repeat")
        }

        function b(e, t, i, n, r, o, a, s, l, c, h, u, f) {
            if (!(f instanceof THREE.DataTexture))
                if (!1 === f.hasEventListener("update", y) && (void 0 !== f.image && 0 < f.image.width && T(f), f.addEventListener("update", y)), void 0 !== (d = xe[f.id])) {
                    P(d);
                    var d = f.offset.x / f.repeat.x,
                        p = f.offset.y / f.repeat.y,
                        m = f.image.width * f.repeat.x;
                    i -= e, n -= t, r -= e, o -= t, 0 !== (f = (l = (l + d) * m - (a = (a + d) * m)) * (u = (u + p) * (f = f.image.height * f.repeat.y) - (s = (s + p) * f)) - (h = (h + d) * m - a) * (c = (c + p) * f - s)) && (e = e - (f = (u * i - c * r) * (d = 1 / f)) * a - (i = (l * r - h * i) * d) * s, t = t - (c = (u * n - c * o) * d) * a - (n = (l * o - h * n) * d) * s, G.save(), G.transform(f, c, i, n, e, t), G.fill(), G.restore())
                } else P("rgba(0,0,0,1)"), G.fill()
        }

        function x(e, t, i, n, r, o, a, s, l, c, h, u, f) {
            var d, p;
            d = f.width - 1, e = e - (d = ((u = u * (p = f.height - 1) - (s *= p)) * (i -= e) - (c = c * p - s) * (r -= e)) * (p = 1 / ((l = l * d - (a *= d)) * u - (h = h * d - a) * c))) * a - (i = (l * r - h * i) * p) * s, t = t - (c = (u * (n -= t) - c * (o -= t)) * p) * a - (n = (l * o - h * n) * p) * s, G.save(), G.transform(d, c, i, n, e, t), G.clip(), G.drawImage(f, 0, 0), G.restore()
        }

        function R(e, t, i, n) {
            return ue[0] = 255 * e.r | 0, ue[1] = 255 * e.g | 0, ue[2] = 255 * e.b | 0, ue[4] = 255 * t.r | 0, ue[5] = 255 * t.g | 0, ue[6] = 255 * t.b | 0, ue[8] = 255 * i.r | 0, ue[9] = 255 * i.g | 0, ue[10] = 255 * i.b | 0, ue[12] = 255 * n.r | 0, ue[13] = 255 * n.g | 0, ue[14] = 255 * n.b | 0, ce.putImageData(he, 0, 0), de.drawImage(le, 0, 0), fe
        }

        function w(e, t, i) {
            var n = t.x - e.x,
                r = t.y - e.y,
                o = n * n + r * r;
            0 !== o && (n *= i /= Math.sqrt(o), r *= i, t.x += n, t.y += r, e.x -= n, e.y -= r)
        }

        function _(e) {
            s !== e && (s = G.globalAlpha = e)
        }

        function H(e) {
            l !== e && (e === THREE.NormalBlending ? G.globalCompositeOperation = "source-over" : e === THREE.AdditiveBlending ? G.globalCompositeOperation = "lighter" : e === THREE.SubtractiveBlending && (G.globalCompositeOperation = "darker"), l = e)
        }

        function S(e) {
            u !== e && (u = G.lineWidth = e)
        }

        function M(e) {
            f !== e && (f = G.lineCap = e)
        }

        function C(e) {
            d !== e && (d = G.lineJoin = e)
        }

        function A(e) {
            c !== e && (c = G.strokeStyle = e)
        }

        function P(e) {
            h !== e && (h = G.fillStyle = e)
        }

        function L(e, t) {
            p === e && m === t || (G.setLineDash([e, t]), p = e, m = t)
        }
        console.log("THREE.CanvasRenderer", THREE.REVISION);
        var D = THREE.Math.smoothstep;
        e = e || {};
        var z, k, O, F, j, U, V, N = this,
            B = new THREE.Projector,
            n = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
            r = n.width,
            o = n.height,
            I = Math.floor(r / 2),
            $ = Math.floor(o / 2),
            G = n.getContext("2d", {
                alpha: !0 === e.alpha
            }),
            i = new THREE.Color(0),
            a = 0,
            s = 1,
            l = 0,
            c = null,
            h = null,
            u = null,
            f = null,
            d = null,
            p = null,
            m = 0;
        new THREE.RenderableVertex, new THREE.RenderableVertex;
        var W, q, X, Y, K, Q, Z, J, ee, te, ie, ne, re, oe, ae, se, le, ce, he, ue, fe, de, pe = new THREE.Color,
            me = new THREE.Color,
            ge = new THREE.Color,
            Ee = new THREE.Color,
            ve = new THREE.Color,
            ye = new THREE.Color,
            Te = new THREE.Color,
            be = new THREE.Color,
            xe = {},
            Re = new THREE.Box2,
            we = new THREE.Box2,
            _e = new THREE.Box2,
            He = new THREE.Color,
            Se = new THREE.Color,
            Me = new THREE.Color,
            Ce = new THREE.Vector3,
            Ae = new THREE.Vector3,
            Pe = new THREE.Matrix3,
            t = 16;
        (le = document.createElement("canvas")).width = le.height = 2, (ce = le.getContext("2d")).fillStyle = "rgba(0,0,0,1)", ce.fillRect(0, 0, 2, 2), he = ce.getImageData(0, 0, 2, 2), ue = he.data, (fe = document.createElement("canvas")).width = fe.height = t, (de = fe.getContext("2d")).translate(-t / 2, -t / 2), de.scale(t, t), t--, void 0 === G.setLineDash && (G.setLineDash = void 0 !== G.mozDash ? function (e) {
            G.mozDash = null !== e[0] ? e : null
        } : function () {}), this.domElement = n, this.devicePixelRatio = void 0 !== e.devicePixelRatio ? e.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.sortElements = this.sortObjects = this.autoClear = !0, this.info = {
            render: {
                vertices: 0,
                faces: 0
            }
        }, this.supportsVertexTextures = function () {}, this.setFaceCulling = function () {}, this.setSize = function (e, t, i) {
            r = e * this.devicePixelRatio, o = t * this.devicePixelRatio, I = Math.floor(r / 2), $ = Math.floor(o / 2), n.width = r, n.height = o, 1 !== this.devicePixelRatio && !1 !== i && (n.style.width = e + "px", n.style.height = t + "px"), Re.min.set(-I, -$), Re.max.set(I, $), we.min.set(-I, -$), we.max.set(I, $), s = 1, l = 0, d = f = u = h = c = null
        }, this.setClearColor = function (e, t) {
            i.set(e), a = void 0 !== t ? t : 1, we.min.set(-I, -$), we.max.set(I, $)
        }, this.setClearColorHex = function (e, t) {
            console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t)
        }, this.getMaxAnisotropy = function () {
            return 0
        }, this.clear = function () {
            G.setTransform(1, 0, 0, -1, I, $), !1 === we.empty() && (we.intersect(Re), we.expandByScalar(2), a < 1 && G.clearRect(0 | we.min.x, 0 | we.min.y, we.max.x - we.min.x | 0, we.max.y - we.min.y | 0), 0 < a && (H(THREE.NormalBlending), _(1), P("rgba(" + Math.floor(255 * i.r) + "," + Math.floor(255 * i.g) + "," + Math.floor(255 * i.b) + "," + a + ")"), G.fillRect(0 | we.min.x, 0 | we.min.y, we.max.x - we.min.x | 0, we.max.y - we.min.y | 0)), we.makeEmpty())
        }, this.clearColor = function () {}, this.clearDepth = function () {}, this.clearStencil = function () {}, this.render = function (e, t) {
            if (!1 == t instanceof THREE.Camera) console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
            else {
                !0 === this.autoClear && this.clear(), G.setTransform(1, 0, 0, -1, I, $), N.info.render.vertices = 0, N.info.render.faces = 0, z = B.projectScene(e, t, this.sortObjects, this.sortElements), k = z.elements, O = z.lights, F = t, Pe.getNormalMatrix(t.matrixWorldInverse), He.setRGB(0, 0, 0), Se.setRGB(0, 0, 0), Me.setRGB(0, 0, 0);
                for (var i = 0, n = O.length; i < n; i++) {
                    var r = O[i],
                        o = r.color;
                    r instanceof THREE.AmbientLight ? He.add(o) : r instanceof THREE.DirectionalLight ? Se.add(o) : r instanceof THREE.PointLight && Me.add(o)
                }
                for (i = 0, n = k.length; i < n; i++) {
                    if (void 0 !== (l = (s = k[i]).material) && !1 !== l.visible) {
                        if (_e.makeEmpty(), s instanceof THREE.RenderableSprite) {
                            (j = s).x *= I, j.y *= $, r = j, _((o = l).opacity), H(o.blending);
                            var a = s.scale.x * I,
                                s = s.scale.y * $,
                                l = .5 * Math.sqrt(a * a + s * s);
                            if (_e.min.set(r.x - l, r.y - l), _e.max.set(r.x + l, r.y + l), o instanceof THREE.SpriteMaterial || o instanceof THREE.ParticleSystemMaterial) {
                                if (null !== (u = o.map)) {
                                    !1 === u.hasEventListener("update", y) && (void 0 !== u.image && 0 < u.image.width && T(u), u.addEventListener("update", y)), P(void 0 !== (l = xe[u.id]) ? l : "rgba( 0, 0, 0, 1 )");
                                    l = (f = u.image).width * u.offset.x;
                                    var c = f.height * u.offset.y,
                                        h = f.width * u.repeat.x,
                                        u = f.height * u.repeat.y,
                                        f = a / h,
                                        d = s / u;
                                    G.save(), G.translate(r.x, r.y), 0 !== o.rotation && G.rotate(o.rotation), G.translate(-a / 2, -s / 2), G.scale(f, d), G.translate(-l, -c), G.fillRect(l, c, h, u)
                                } else P(o.color.getStyle()), G.save(), G.translate(r.x, r.y), 0 !== o.rotation && G.rotate(o.rotation), G.scale(a, -s), G.fillRect(-.5, -.5, 1, 1);
                                G.restore()
                            } else o instanceof THREE.SpriteCanvasMaterial && (A(o.color.getStyle()), P(o.color.getStyle()), G.save(), G.translate(r.x, r.y), 0 !== o.rotation && G.rotate(o.rotation), G.scale(a, s), o.program(G), G.restore())
                        } else if (s instanceof THREE.RenderableLine) {
                            if (j = s.v1, U = s.v2, j.positionScreen.x *= I, j.positionScreen.y *= $, U.positionScreen.x *= I, U.positionScreen.y *= $, _e.setFromPoints([j.positionScreen, U.positionScreen]), !0 === Re.isIntersectionBox(_e))
                                if (r = j, o = U, a = s, _((s = l).opacity), H(s.blending), G.beginPath(), G.moveTo(r.positionScreen.x, r.positionScreen.y), G.lineTo(o.positionScreen.x, o.positionScreen.y), s instanceof THREE.LineBasicMaterial) {
                                    if (S(s.linewidth), M(s.linecap), C(s.linejoin), s.vertexColors !== THREE.VertexColors) A(s.color.getStyle());
                                    else if ((l = a.vertexColors[0].getStyle()) === (a = a.vertexColors[1].getStyle())) A(l);
                                    else {
                                        try {
                                            var p = G.createLinearGradient(r.positionScreen.x, r.positionScreen.y, o.positionScreen.x, o.positionScreen.y);
                                            p.addColorStop(0, l), p.addColorStop(1, a)
                                        } catch (e) {
                                            p = l
                                        }
                                        A(p)
                                    }
                                    G.stroke(), _e.expandByScalar(2 * s.linewidth)
                                } else s instanceof THREE.LineDashedMaterial && (S(s.linewidth), M(s.linecap), C(s.linejoin), A(s.color.getStyle()), L(s.dashSize, s.gapSize), G.stroke(), _e.expandByScalar(2 * s.linewidth), L(null, null))
                        } else if (s instanceof THREE.RenderableFace) {
                            if (j = s.v1, U = s.v2, V = s.v3, j.positionScreen.z < -1 || 1 < j.positionScreen.z) continue;
                            if (U.positionScreen.z < -1 || 1 < U.positionScreen.z) continue;
                            if (V.positionScreen.z < -1 || 1 < V.positionScreen.z) continue;
                            if (j.positionScreen.x *= I, j.positionScreen.y *= $, U.positionScreen.x *= I, U.positionScreen.y *= $, V.positionScreen.x *= I, V.positionScreen.y *= $, 0 < l.overdraw && (w(j.positionScreen, U.positionScreen, l.overdraw), w(U.positionScreen, V.positionScreen, l.overdraw), w(V.positionScreen, j.positionScreen, l.overdraw)), _e.setFromPoints([j.positionScreen, U.positionScreen, V.positionScreen]), !0 === Re.isIntersectionBox(_e)) {
                                r = j, o = U, a = V, N.info.render.vertices += 3, N.info.render.faces++, _(l.opacity), H(l.blending), W = r.positionScreen.x, q = r.positionScreen.y, X = o.positionScreen.x, Y = o.positionScreen.y, K = a.positionScreen.x, Q = a.positionScreen.y;
                                c = W, h = q, u = X, f = Y, d = K;
                                var m = Q;
                                G.beginPath(), G.moveTo(c, h), G.lineTo(u, f), G.lineTo(d, m), G.closePath(), (l instanceof THREE.MeshLambertMaterial || l instanceof THREE.MeshPhongMaterial) && null === l.map ? (ye.copy(l.color), Te.copy(l.emissive), l.vertexColors === THREE.FaceColors && ye.multiply(s.color), !1 === l.wireframe && l.shading === THREE.SmoothShading && 3 === s.vertexNormalsLength ? (me.copy(He), ge.copy(He), Ee.copy(He), g(s.v1.positionWorld, s.vertexNormalsModel[0], me), g(s.v2.positionWorld, s.vertexNormalsModel[1], ge), g(s.v3.positionWorld, s.vertexNormalsModel[2], Ee), me.multiply(ye).add(Te), ge.multiply(ye).add(Te), Ee.multiply(ye).add(Te), ve.addColors(ge, Ee).multiplyScalar(.5), ee = R(me, ge, Ee, ve), x(W, q, X, Y, K, Q, 0, 0, 1, 0, 0, 1, ee)) : (pe.copy(He), g(s.centroidModel, s.normalModel, pe), pe.multiply(ye).add(Te), !0 === l.wireframe ? E(pe, l.wireframeLinewidth, l.wireframeLinecap, l.wireframeLinejoin) : v(pe))) : l instanceof THREE.MeshBasicMaterial || l instanceof THREE.MeshLambertMaterial || l instanceof THREE.MeshPhongMaterial ? null !== l.map ? l.map.mapping instanceof THREE.UVMapping && (te = s.uvs[0], b(W, q, X, Y, K, Q, te[0].x, te[0].y, te[1].x, te[1].y, te[2].x, te[2].y, l.map)) : null !== l.envMap ? l.envMap.mapping instanceof THREE.SphericalReflectionMapping && (Ae.copy(s.vertexNormalsModel[0]).applyMatrix3(Pe), ie = .5 * Ae.x + .5, ne = .5 * Ae.y + .5, Ae.copy(s.vertexNormalsModel[1]).applyMatrix3(Pe), re = .5 * Ae.x + .5, oe = .5 * Ae.y + .5, Ae.copy(s.vertexNormalsModel[2]).applyMatrix3(Pe), ae = .5 * Ae.x + .5, se = .5 * Ae.y + .5, b(W, q, X, Y, K, Q, ie, ne, re, oe, ae, se, l.envMap)) : (pe.copy(l.color), l.vertexColors === THREE.FaceColors && pe.multiply(s.color), !0 === l.wireframe ? E(pe, l.wireframeLinewidth, l.wireframeLinecap, l.wireframeLinejoin) : v(pe)) : l instanceof THREE.MeshDepthMaterial ? (Z = F.near, J = F.far, me.r = me.g = me.b = 1 - D(r.positionScreen.z * r.positionScreen.w, Z, J), ge.r = ge.g = ge.b = 1 - D(o.positionScreen.z * o.positionScreen.w, Z, J), Ee.r = Ee.g = Ee.b = 1 - D(a.positionScreen.z * a.positionScreen.w, Z, J), ve.addColors(ge, Ee).multiplyScalar(.5), ee = R(me, ge, Ee, ve), x(W, q, X, Y, K, Q, 0, 0, 1, 0, 0, 1, ee)) : l instanceof THREE.MeshNormalMaterial && (l.shading === THREE.FlatShading ? (Ae.copy(s.normalModel).applyMatrix3(Pe), pe.setRGB(Ae.x, Ae.y, Ae.z).multiplyScalar(.5).addScalar(.5), !0 === l.wireframe ? E(pe, l.wireframeLinewidth, l.wireframeLinecap, l.wireframeLinejoin) : v(pe)) : l.shading === THREE.SmoothShading && (Ae.copy(s.vertexNormalsModel[0]).applyMatrix3(Pe), me.setRGB(Ae.x, Ae.y, Ae.z).multiplyScalar(.5).addScalar(.5), Ae.copy(s.vertexNormalsModel[1]).applyMatrix3(Pe), ge.setRGB(Ae.x, Ae.y, Ae.z).multiplyScalar(.5).addScalar(.5), Ae.copy(s.vertexNormalsModel[2]).applyMatrix3(Pe), Ee.setRGB(Ae.x, Ae.y, Ae.z).multiplyScalar(.5).addScalar(.5), ve.addColors(ge, Ee).multiplyScalar(.5), ee = R(me, ge, Ee, ve), x(W, q, X, Y, K, Q, 0, 0, 1, 0, 0, 1, ee)))
                            }
                        }
                        we.union(_e)
                    }
                }
                G.setTransform(1, 0, 0, 1, 0, 0)
            }
        }
    }, THREE.ShaderChunk = {
        fog_pars_fragment: "#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",
        fog_fragment: "#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\nuniform float reflectivity;\nuniform samplerCube envMap;\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
        envmap_fragment: "#ifdef USE_ENVMAP\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = vReflect;\n#endif\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n} else if ( combine == 2 ) {\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n} else {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n}\n#endif",
        envmap_pars_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 worldPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif",
        envmap_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, worldNormal );\n}\n#endif",
        map_particle_pars_fragment: "#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
        map_particle_fragment: "#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif",
        map_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif",
        map_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
        map_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
        map_fragment: "#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif",
        lightmap_pars_vertex: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif",
        lightmap_vertex: "#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",
        lights_lambert_pars_vertex: "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif",
        lights_lambert_vertex: "vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif",
        lights_phong_pars_vertex: "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif",
        lights_phong_vertex: "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvWorldPosition = worldPosition.xyz;\n#endif",
        lights_phong_pars_fragment: "uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",
        lights_phong_fragment: "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
        color_fragment: "#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nuniform int boneTextureWidth;\nuniform int boneTextureHeight;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, float( boneTextureWidth ) );\nfloat y = floor( j / float( boneTextureWidth ) );\nfloat dx = 1.0 / float( boneTextureWidth );\nfloat dy = 1.0 / float( boneTextureHeight );\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif",
        skinbase_vertex: "#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\nmat4 boneMatZ = getBoneMatrix( skinIndex.z );\nmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\nskinned      += boneMatZ * skinVertex * skinWeight.z;\nskinned      += boneMatW * skinVertex * skinWeight.w;\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif",
        default_vertex: "vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix \t+= skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif",
        defaultnormal_vertex: "vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif",
        shadowmap_fragment: "#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif",
        linear_to_gamma_fragment: "#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif"
    }, THREE.UniformsUtils = {
        merge: function (e) {
            var t, i, n, r = {};
            for (t = 0; t < e.length; t++)
                for (i in n = this.clone(e[t])) r[i] = n[i];
            return r
        },
        clone: function (e) {
            var t, i, n, r = {};
            for (t in e)
                for (i in r[t] = {}, e[t]) n = e[t][i], r[t][i] = n instanceof THREE.Color || n instanceof THREE.Vector2 || n instanceof THREE.Vector3 || n instanceof THREE.Vector4 || n instanceof THREE.Matrix4 || n instanceof THREE.Texture ? n.clone() : n instanceof Array ? n.slice() : n;
            return r
        }
    }, THREE.UniformsLib = {
        common: {
            diffuse: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            offsetRepeat: {
                type: "v4",
                value: new THREE.Vector4(0, 0, 1, 1)
            },
            lightMap: {
                type: "t",
                value: null
            },
            specularMap: {
                type: "t",
                value: null
            },
            envMap: {
                type: "t",
                value: null
            },
            flipEnvMap: {
                type: "f",
                value: -1
            },
            useRefract: {
                type: "i",
                value: 0
            },
            reflectivity: {
                type: "f",
                value: 1
            },
            refractionRatio: {
                type: "f",
                value: .98
            },
            combine: {
                type: "i",
                value: 0
            },
            morphTargetInfluences: {
                type: "f",
                value: 0
            }
        },
        bump: {
            bumpMap: {
                type: "t",
                value: null
            },
            bumpScale: {
                type: "f",
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                type: "t",
                value: null
            },
            normalScale: {
                type: "v2",
                value: new THREE.Vector2(1, 1)
            }
        },
        fog: {
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new THREE.Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                type: "fv",
                value: []
            },
            directionalLightDirection: {
                type: "fv",
                value: []
            },
            directionalLightColor: {
                type: "fv",
                value: []
            },
            hemisphereLightDirection: {
                type: "fv",
                value: []
            },
            hemisphereLightSkyColor: {
                type: "fv",
                value: []
            },
            hemisphereLightGroundColor: {
                type: "fv",
                value: []
            },
            pointLightColor: {
                type: "fv",
                value: []
            },
            pointLightPosition: {
                type: "fv",
                value: []
            },
            pointLightDistance: {
                type: "fv1",
                value: []
            },
            spotLightColor: {
                type: "fv",
                value: []
            },
            spotLightPosition: {
                type: "fv",
                value: []
            },
            spotLightDirection: {
                type: "fv",
                value: []
            },
            spotLightDistance: {
                type: "fv1",
                value: []
            },
            spotLightAngleCos: {
                type: "fv1",
                value: []
            },
            spotLightExponent: {
                type: "fv1",
                value: []
            }
        },
        particle: {
            psColor: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            size: {
                type: "f",
                value: 1
            },
            scale: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new THREE.Color(16777215)
            }
        },
        shadowmap: {
            shadowMap: {
                type: "tv",
                value: []
            },
            shadowMapSize: {
                type: "v2v",
                value: []
            },
            shadowBias: {
                type: "fv1",
                value: []
            },
            shadowDarkness: {
                type: "fv1",
                value: []
            },
            shadowMatrix: {
                type: "m4v",
                value: []
            }
        }
    }, THREE.ShaderLib = {
        basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
            vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        lambert: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                ambient: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            }]),
            vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        phong: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                ambient: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            }]),
            vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "vNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        particle_basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
            vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, "void main() {\ngl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        dashed: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
                scale: {
                    type: "f",
                    value: 1
                },
                dashSize: {
                    type: "f",
                    value: 1
                },
                totalSize: {
                    type: "f",
                    value: 2
                }
            }]),
            vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        depth: {
            uniforms: {
                mNear: {
                    type: "f",
                    value: 1
                },
                mFar: {
                    type: "f",
                    value: 2e3
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            fragmentShader: "uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}"
        },
        normal: {
            uniforms: {
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, "void main() {\nvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
            fragmentShader: "uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}"
        },
        normalmap: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                enableAO: {
                    type: "i",
                    value: 0
                },
                enableDiffuse: {
                    type: "i",
                    value: 0
                },
                enableSpecular: {
                    type: "i",
                    value: 0
                },
                enableReflection: {
                    type: "i",
                    value: 0
                },
                enableDisplacement: {
                    type: "i",
                    value: 0
                },
                tDisplacement: {
                    type: "t",
                    value: null
                },
                tDiffuse: {
                    type: "t",
                    value: null
                },
                tCube: {
                    type: "t",
                    value: null
                },
                tNormal: {
                    type: "t",
                    value: null
                },
                tSpecular: {
                    type: "t",
                    value: null
                },
                tAO: {
                    type: "t",
                    value: null
                },
                uNormalScale: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                uDisplacementBias: {
                    type: "f",
                    value: 0
                },
                uDisplacementScale: {
                    type: "f",
                    value: 1
                },
                diffuse: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                ambient: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                useRefract: {
                    type: "i",
                    value: 0
                },
                refractionRatio: {
                    type: "f",
                    value: .98
                },
                reflectivity: {
                    type: "f",
                    value: .5
                },
                uOffset: {
                    type: "v2",
                    value: new THREE.Vector2(0, 0)
                },
                uRepeat: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            }]),
            fragmentShader: ["uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n}", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n"),
            vertexShader: ["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, "#ifdef USE_SKINNING\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n#else\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\n#endif\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif\n}"].join("\n")
        },
        cube: {
            uniforms: {
                tCube: {
                    type: "t",
                    value: null
                },
                tFlip: {
                    type: "f",
                    value: -1
                }
            },
            vertexShader: "varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            fragmentShader: "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}"
        },
        depthRGBA: {
            uniforms: {},
            vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
            fragmentShader: "vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}"
        }
    }, THREE.WebGLRenderer = function (e) {
        function l(e, t) {
            var i = e.vertices.length,
                n = t.material;
            if (n.attributes)
                for (var r in void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []), n.attributes) {
                    var o = n.attributes[r];
                    if (!o.__webglInitialized || o.createUniqueBuffers) {
                        o.__webglInitialized = !0;
                        var a = 1;
                        "v2" === o.type ? a = 2 : "v3" === o.type ? a = 3 : "v4" === o.type ? a = 4 : "c" === o.type && (a = 3), o.size = a, o.array = new Float32Array(i * a), o.buffer = oi.createBuffer(), o.buffer.belongsToAttribute = r, o.needsUpdate = !0
                    }
                    e.__webglCustomAttributesList.push(o)
                }
        }

        function Kt(e, t) {
            var i, n = t.geometry,
                r = 3 * (i = e.faces3).length,
                o = 1 * i.length,
                a = 3 * i.length,
                s = Jt(i = Qt(t, e)),
                l = Zt(i),
                c = !!i.vertexColors && i.vertexColors;
            if (e.__vertexArray = new Float32Array(3 * r), l && (e.__normalArray = new Float32Array(3 * r)), n.hasTangents && (e.__tangentArray = new Float32Array(4 * r)), c && (e.__colorArray = new Float32Array(3 * r)), s && (0 < n.faceVertexUvs.length && (e.__uvArray = new Float32Array(2 * r)), 1 < n.faceVertexUvs.length && (e.__uv2Array = new Float32Array(2 * r))), t.geometry.skinWeights.length && t.geometry.skinIndices.length && (e.__skinIndexArray = new Float32Array(4 * r), e.__skinWeightArray = new Float32Array(4 * r)), e.__faceArray = new Uint16Array(3 * o), e.__lineArray = new Uint16Array(2 * a), e.numMorphTargets)
                for (e.__morphTargetsArrays = [], n = 0, s = e.numMorphTargets; n < s; n++) e.__morphTargetsArrays.push(new Float32Array(3 * r));
            if (e.numMorphNormals)
                for (e.__morphNormalsArrays = [], n = 0, s = e.numMorphNormals; n < s; n++) e.__morphNormalsArrays.push(new Float32Array(3 * r));
            if (e.__webglFaceCount = 3 * o, e.__webglLineCount = 2 * a, i.attributes)
                for (var h in void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []), i.attributes) {
                    var u;
                    o = i.attributes[h], a = {};
                    for (u in o) a[u] = o[u];
                    a.__webglInitialized && !a.createUniqueBuffers || (a.__webglInitialized = !0, n = 1, "v2" === a.type ? n = 2 : "v3" === a.type ? n = 3 : "v4" === a.type ? n = 4 : "c" === a.type && (n = 3), a.size = n, a.array = new Float32Array(r * n), a.buffer = oi.createBuffer(), a.buffer.belongsToAttribute = h, o.needsUpdate = !0, a.__original = o), e.__webglCustomAttributesList.push(a)
                }
            e.__inittedArrays = !0
        }

        function Qt(e, t) {
            return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[t.materialIndex] : e.material
        }

        function Zt(e) {
            return !(e instanceof THREE.MeshBasicMaterial && !e.envMap || e instanceof THREE.MeshDepthMaterial) && (e && void 0 !== e.shading && e.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading)
        }

        function Jt(e) {
            return !!(e.map || e.lightMap || e.bumpMap || e.normalMap || e.specularMap || e instanceof THREE.ShaderMaterial)
        }

        function d(e, t, i, n) {
            var r, o, a, s;
            for (o in t) a = t[o], r = i[o], 0 <= a && (r ? (s = r.itemSize, oi.bindBuffer(oi.ARRAY_BUFFER, r.buffer), p(a), oi.vertexAttribPointer(a, s, oi.FLOAT, !1, 0, n * s * 4)) : e.defaultAttributeValues && (2 === e.defaultAttributeValues[o].length ? oi.vertexAttrib2fv(a, e.defaultAttributeValues[o]) : 3 === e.defaultAttributeValues[o].length && oi.vertexAttrib3fv(a, e.defaultAttributeValues[o])))
        }

        function p(e) {
            0 === he[e] && (oi.enableVertexAttribArray(e), he[e] = 1)
        }

        function m() {
            for (var e in he) 1 === he[e] && (oi.disableVertexAttribArray(e), he[e] = 0)
        }

        function g(e, t) {
            return e.z !== t.z ? t.z - e.z : e.id - t.id
        }

        function ei(e, t) {
            return t[0] - e[0]
        }

        function E(e, t, i) {
            if (e.length)
                for (var n = 0, r = e.length; n < r; n++) K = X = null, Y = z = O = k = J = Z = F = -1, de = !0, e[n].render(t, i, le, ce), K = X = null, Y = z = O = k = J = Z = F = -1, de = !0
        }

        function v(e, t, i, n, r, o, a, s) {
            var l, c, h, u;
            u = t ? (c = e.length - 1, t = -1) : (c = 0, t = e.length, 1);
            for (var f = c; f !== t; f += u)
                if ((l = e[f]).render) {
                    if (c = l.object, h = l.buffer, s) l = s;
                    else {
                        if (!(l = l[i])) continue;
                        a && q.setBlending(l.blending, l.blendEquation, l.blendSrc, l.blendDst), q.setDepthTest(l.depthTest), q.setDepthWrite(l.depthWrite), x(l.polygonOffset, l.polygonOffsetFactor, l.polygonOffsetUnits)
                    }
                    q.setMaterialFaces(l), h instanceof THREE.BufferGeometry ? q.renderBufferDirect(n, r, o, l, h, c) : q.renderBuffer(n, r, o, l, h, c)
                }
        }

        function y(e, t, i, n, r, o, a) {
            for (var s, l, c = 0, h = e.length; c < h; c++)
                if ((l = (s = e[c]).object).visible) {
                    if (a) s = a;
                    else {
                        if (!(s = s[t])) continue;
                        o && q.setBlending(s.blending, s.blendEquation, s.blendSrc, s.blendDst), q.setDepthTest(s.depthTest), q.setDepthWrite(s.depthWrite), x(s.polygonOffset, s.polygonOffsetFactor, s.polygonOffsetUnits)
                    }
                    q.renderImmediateObject(i, n, r, s, l)
                }
        }

        function ti(e, t) {
            var i, n, r;
            if (void 0 === e.__webglInit && (e.__webglInit = !0, e._modelViewMatrix = new THREE.Matrix4, e._normalMatrix = new THREE.Matrix3, void 0 !== e.geometry && void 0 === e.geometry.__webglInit && (e.geometry.__webglInit = !0, e.geometry.addEventListener("dispose", Se)), void 0 !== (n = e.geometry)))
                if (n instanceof THREE.BufferGeometry) {
                    var o, a;
                    for (r in n.attributes) a = "index" === r ? oi.ELEMENT_ARRAY_BUFFER : oi.ARRAY_BUFFER, (o = n.attributes[r]).buffer = oi.createBuffer(), oi.bindBuffer(a, o.buffer), oi.bufferData(a, o.array, oi.STATIC_DRAW)
                } else if (e instanceof THREE.Mesh) {
                for (i in r = e.material, void 0 === n.geometryGroups && n.makeGroups(r instanceof THREE.MeshFaceMaterial), n.geometryGroups)
                    if (!(r = n.geometryGroups[i]).__webglVertexBuffer) {
                        (o = r).__webglVertexBuffer = oi.createBuffer(), o.__webglNormalBuffer = oi.createBuffer(), o.__webglTangentBuffer = oi.createBuffer(), o.__webglColorBuffer = oi.createBuffer(), o.__webglUVBuffer = oi.createBuffer(), o.__webglUV2Buffer = oi.createBuffer(), o.__webglSkinIndicesBuffer = oi.createBuffer(), o.__webglSkinWeightsBuffer = oi.createBuffer(), o.__webglFaceBuffer = oi.createBuffer(), o.__webglLineBuffer = oi.createBuffer();
                        var s = a = void 0;
                        if (o.numMorphTargets)
                            for (o.__webglMorphTargetsBuffers = [], a = 0, s = o.numMorphTargets; a < s; a++) o.__webglMorphTargetsBuffers.push(oi.createBuffer());
                        if (o.numMorphNormals)
                            for (o.__webglMorphNormalsBuffers = [], a = 0, s = o.numMorphNormals; a < s; a++) o.__webglMorphNormalsBuffers.push(oi.createBuffer());
                        q.info.memory.geometries++, Kt(r, e), n.verticesNeedUpdate = !0, n.morphTargetsNeedUpdate = !0, n.elementsNeedUpdate = !0, n.uvsNeedUpdate = !0, n.normalsNeedUpdate = !0, n.tangentsNeedUpdate = !0, n.colorsNeedUpdate = !0
                    }
            } else e instanceof THREE.Line ? n.__webglVertexBuffer || ((r = n).__webglVertexBuffer = oi.createBuffer(), r.__webglColorBuffer = oi.createBuffer(), r.__webglLineDistanceBuffer = oi.createBuffer(), q.info.memory.geometries++, o = (r = n).vertices.length, r.__vertexArray = new Float32Array(3 * o), r.__colorArray = new Float32Array(3 * o), r.__lineDistanceArray = new Float32Array(1 * o), r.__webglLineCount = o, l(r, e), n.verticesNeedUpdate = !0, n.colorsNeedUpdate = !0, n.lineDistancesNeedUpdate = !0) : e instanceof THREE.ParticleSystem && !n.__webglVertexBuffer && ((r = n).__webglVertexBuffer = oi.createBuffer(), r.__webglColorBuffer = oi.createBuffer(), q.info.memory.geometries++, o = (r = n).vertices.length, r.__vertexArray = new Float32Array(3 * o), r.__colorArray = new Float32Array(3 * o), r.__sortArray = [], r.__webglParticleCount = o, l(r, e), n.verticesNeedUpdate = !0, n.colorsNeedUpdate = !0);
            if (void 0 === e.__webglActive) {
                if (e instanceof THREE.Mesh) {
                    if ((n = e.geometry) instanceof THREE.BufferGeometry) c(t.__webglObjects, n, e);
                    else if (n instanceof THREE.Geometry)
                        for (i in n.geometryGroups) r = n.geometryGroups[i], c(t.__webglObjects, r, e)
                } else e instanceof THREE.Line || e instanceof THREE.ParticleSystem ? (n = e.geometry, c(t.__webglObjects, n, e)) : e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback ? t.__webglObjectsImmediate.push({
                    id: null,
                    object: e,
                    opaque: null,
                    transparent: null,
                    z: 0
                }) : e instanceof THREE.Sprite ? t.__webglSprites.push(e) : e instanceof THREE.LensFlare && t.__webglFlares.push(e);
                e.__webglActive = !0
            }
        }

        function c(e, t, i) {
            e.push({
                id: null,
                buffer: t,
                object: i,
                opaque: null,
                transparent: null,
                z: 0
            })
        }

        function ii(e) {
            for (var t in e.attributes)
                if (e.attributes[t].needsUpdate) return !0;
            return !1
        }

        function ni(e) {
            for (var t in e.attributes) e.attributes[t].needsUpdate = !1
        }

        function ri(e, t) {
            e instanceof THREE.Mesh || e instanceof THREE.ParticleSystem || e instanceof THREE.Line ? i(t.__webglObjects, e) : e instanceof THREE.Sprite ? n(t.__webglSprites, e) : e instanceof THREE.LensFlare ? n(t.__webglFlares, e) : (e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback) && i(t.__webglObjectsImmediate, e), delete e.__webglActive
        }

        function i(e, t) {
            for (var i = e.length - 1; 0 <= i; i--) e[i].object === t && e.splice(i, 1)
        }

        function n(e, t) {
            for (var i = e.length - 1; 0 <= i; i--) e[i] === t && e.splice(i, 1)
        }

        function T(e, t, i, n, r) {
            Q = 0, n.needsUpdate && (n.program && Le(n), q.initMaterial(n, t, i, r), n.needsUpdate = !1), n.morphTargets && !r.__webglMorphTargetInfluences && (r.__webglMorphTargetInfluences = new Float32Array(q.maxMorphTargets));
            var o = !1,
                a = n.program,
                s = a.uniforms,
                l = n.uniforms;
            if (a !== X && (oi.useProgram(a), X = a, o = !0), n.id !== Y && (Y = n.id, o = !0), (o || e !== K) && (oi.uniformMatrix4fv(s.projectionMatrix, !1, e.projectionMatrix.elements), e !== K && (K = e)), n.skinning)
                if (Te && r.useVertexTexture) {
                    if (null !== s.boneTexture) {
                        var c = N();
                        oi.uniform1i(s.boneTexture, c), q.setTexture(r.boneTexture, c)
                    }
                    null !== s.boneTextureWidth && oi.uniform1i(s.boneTextureWidth, r.boneTextureWidth), null !== s.boneTextureHeight && oi.uniform1i(s.boneTextureHeight, r.boneTextureHeight)
                } else null !== s.boneGlobalMatrices && oi.uniformMatrix4fv(s.boneGlobalMatrices, !1, r.boneMatrices);
            if (o) {
                if (i && n.fog && (l.fogColor.value = i.color, i instanceof THREE.Fog ? (l.fogNear.value = i.near, l.fogFar.value = i.far) : i instanceof THREE.FogExp2 && (l.fogDensity.value = i.density)), n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshLambertMaterial || n.lights) {
                    if (de) {
                        var h, u, f, d, p = c = 0,
                            m = 0,
                            g = pe,
                            E = g.directional.colors,
                            v = g.directional.positions,
                            y = g.point.colors,
                            T = g.point.positions,
                            b = g.point.distances,
                            x = g.spot.colors,
                            R = g.spot.positions,
                            w = g.spot.distances,
                            _ = g.spot.directions,
                            H = g.spot.anglesCos,
                            S = g.spot.exponents,
                            M = g.hemi.skyColors,
                            C = g.hemi.groundColors,
                            A = g.hemi.positions,
                            P = 0,
                            L = 0,
                            D = 0,
                            z = 0,
                            k = 0,
                            O = 0,
                            F = 0,
                            j = 0,
                            U = h = 0;
                        for (i = d = U = 0, o = t.length; i < o; i++)(h = t[i]).onlyShadow || (u = h.color, f = h.intensity, d = h.distance, h instanceof THREE.AmbientLight ? h.visible && (q.gammaInput ? (c += u.r * u.r, p += u.g * u.g, m += u.b * u.b) : (c += u.r, p += u.g, m += u.b)) : h instanceof THREE.DirectionalLight ? (k += 1, h.visible && (fe.setFromMatrixPosition(h.matrixWorld), li.setFromMatrixPosition(h.target.matrixWorld), fe.sub(li), fe.normalize(), 0 !== fe.x || 0 !== fe.y || 0 !== fe.z) && (v[h = 3 * P] = fe.x, v[h + 1] = fe.y, v[h + 2] = fe.z, q.gammaInput ? B(E, h, u, f * f) : I(E, h, u, f), P += 1)) : h instanceof THREE.PointLight ? (O += 1, h.visible && (U = 3 * L, q.gammaInput ? B(y, U, u, f * f) : I(y, U, u, f), li.setFromMatrixPosition(h.matrixWorld), T[U] = li.x, T[U + 1] = li.y, T[U + 2] = li.z, b[L] = d, L += 1)) : h instanceof THREE.SpotLight ? (F += 1, h.visible && (U = 3 * D, q.gammaInput ? B(x, U, u, f * f) : I(x, U, u, f), li.setFromMatrixPosition(h.matrixWorld), R[U] = li.x, R[U + 1] = li.y, R[U + 2] = li.z, w[D] = d, fe.copy(li), li.setFromMatrixPosition(h.target.matrixWorld), fe.sub(li), fe.normalize(), _[U] = fe.x, _[U + 1] = fe.y, _[U + 2] = fe.z, H[D] = Math.cos(h.angle), S[D] = h.exponent, D += 1)) : h instanceof THREE.HemisphereLight && (j += 1, h.visible && (fe.setFromMatrixPosition(h.matrixWorld), fe.normalize(), 0 !== fe.x || 0 !== fe.y || 0 !== fe.z)) && (A[d = 3 * z] = fe.x, A[d + 1] = fe.y, A[d + 2] = fe.z, u = h.color, h = h.groundColor, q.gammaInput ? (B(M, d, u, f *= f), B(C, d, h, f)) : (I(M, d, u, f), I(C, d, h, f)), z += 1));
                        for (i = 3 * P, o = Math.max(E.length, 3 * k); i < o; i++) E[i] = 0;
                        for (i = 3 * L, o = Math.max(y.length, 3 * O); i < o; i++) y[i] = 0;
                        for (i = 3 * D, o = Math.max(x.length, 3 * F); i < o; i++) x[i] = 0;
                        for (i = 3 * z, o = Math.max(M.length, 3 * j); i < o; i++) M[i] = 0;
                        for (i = 3 * z, o = Math.max(C.length, 3 * j); i < o; i++) C[i] = 0;
                        g.directional.length = P, g.point.length = L, g.spot.length = D, g.hemi.length = z, g.ambient[0] = c, g.ambient[1] = p, g.ambient[2] = m, de = !1
                    }
                    i = pe, l.ambientLightColor.value = i.ambient, l.directionalLightColor.value = i.directional.colors, l.directionalLightDirection.value = i.directional.positions, l.pointLightColor.value = i.point.colors, l.pointLightPosition.value = i.point.positions, l.pointLightDistance.value = i.point.distances, l.spotLightColor.value = i.spot.colors, l.spotLightPosition.value = i.spot.positions, l.spotLightDistance.value = i.spot.distances, l.spotLightDirection.value = i.spot.directions, l.spotLightAngleCos.value = i.spot.anglesCos, l.spotLightExponent.value = i.spot.exponents, l.hemisphereLightSkyColor.value = i.hemi.skyColors, l.hemisphereLightGroundColor.value = i.hemi.groundColors, l.hemisphereLightDirection.value = i.hemi.positions
                }
                var V;
                if (n instanceof THREE.MeshBasicMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.MeshPhongMaterial) l.opacity.value = n.opacity, q.gammaInput ? l.diffuse.value.copyGammaToLinear(n.color) : l.diffuse.value = n.color, l.map.value = n.map, l.lightMap.value = n.lightMap, l.specularMap.value = n.specularMap, n.bumpMap && (l.bumpMap.value = n.bumpMap, l.bumpScale.value = n.bumpScale), n.normalMap && (l.normalMap.value = n.normalMap, l.normalScale.value.copy(n.normalScale)), n.map ? V = n.map : n.specularMap ? V = n.specularMap : n.normalMap ? V = n.normalMap : n.bumpMap && (V = n.bumpMap), void 0 !== V && (i = V.offset, V = V.repeat, l.offsetRepeat.value.set(i.x, i.y, V.x, V.y)), l.envMap.value = n.envMap, l.flipEnvMap.value = n.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, l.reflectivity.value = n.reflectivity, l.refractionRatio.value = n.refractionRatio, l.combine.value = n.combine, l.useRefract.value = n.envMap && n.envMap.mapping instanceof THREE.CubeRefractionMapping;
                if (n instanceof THREE.LineBasicMaterial ? (l.diffuse.value = n.color, l.opacity.value = n.opacity) : n instanceof THREE.LineDashedMaterial ? (l.diffuse.value = n.color, l.opacity.value = n.opacity, l.dashSize.value = n.dashSize, l.totalSize.value = n.dashSize + n.gapSize, l.scale.value = n.scale) : n instanceof THREE.ParticleSystemMaterial ? (l.psColor.value = n.color, l.opacity.value = n.opacity, l.size.value = n.size, l.scale.value = W.height / 2, l.map.value = n.map) : n instanceof THREE.MeshPhongMaterial ? (l.shininess.value = n.shininess, q.gammaInput ? (l.ambient.value.copyGammaToLinear(n.ambient), l.emissive.value.copyGammaToLinear(n.emissive), l.specular.value.copyGammaToLinear(n.specular)) : (l.ambient.value = n.ambient, l.emissive.value = n.emissive, l.specular.value = n.specular), n.wrapAround && l.wrapRGB.value.copy(n.wrapRGB)) : n instanceof THREE.MeshLambertMaterial ? (q.gammaInput ? (l.ambient.value.copyGammaToLinear(n.ambient), l.emissive.value.copyGammaToLinear(n.emissive)) : (l.ambient.value = n.ambient, l.emissive.value = n.emissive), n.wrapAround && l.wrapRGB.value.copy(n.wrapRGB)) : n instanceof THREE.MeshDepthMaterial ? (l.mNear.value = e.near, l.mFar.value = e.far, l.opacity.value = n.opacity) : n instanceof THREE.MeshNormalMaterial && (l.opacity.value = n.opacity), r.receiveShadow && !n._shadowPass && l.shadowMatrix)
                    for (i = V = 0, o = t.length; i < o; i++)(c = t[i]).castShadow && (c instanceof THREE.SpotLight || c instanceof THREE.DirectionalLight && !c.shadowCascade) && (l.shadowMap.value[V] = c.shadowMap, l.shadowMapSize.value[V] = c.shadowMapSize, l.shadowMatrix.value[V] = c.shadowMatrix, l.shadowDarkness.value[V] = c.shadowDarkness, l.shadowBias.value[V] = c.shadowBias, V++);
                for (l = 0, V = (t = n.uniformsList).length; l < V; l++)
                    if (o = a.uniforms[t[l][1]])
                        if (p = (i = t[l][0]).type, c = i.value, "i" === p) oi.uniform1i(o, c);
                        else if ("f" === p) oi.uniform1f(o, c);
                else if ("v2" === p) oi.uniform2f(o, c.x, c.y);
                else if ("v3" === p) oi.uniform3f(o, c.x, c.y, c.z);
                else if ("v4" === p) oi.uniform4f(o, c.x, c.y, c.z, c.w);
                else if ("c" === p) oi.uniform3f(o, c.r, c.g, c.b);
                else if ("iv1" === p) oi.uniform1iv(o, c);
                else if ("iv" === p) oi.uniform3iv(o, c);
                else if ("fv1" === p) oi.uniform1fv(o, c);
                else if ("fv" === p) oi.uniform3fv(o, c);
                else if ("v2v" === p) {
                    for (void 0 === i._array && (i._array = new Float32Array(2 * c.length)), p = 0, m = c.length; p < m; p++) g = 2 * p, i._array[g] = c[p].x, i._array[g + 1] = c[p].y;
                    oi.uniform2fv(o, i._array)
                } else if ("v3v" === p) {
                    for (void 0 === i._array && (i._array = new Float32Array(3 * c.length)), p = 0, m = c.length; p < m; p++) g = 3 * p, i._array[g] = c[p].x, i._array[g + 1] = c[p].y, i._array[g + 2] = c[p].z;
                    oi.uniform3fv(o, i._array)
                } else if ("v4v" === p) {
                    for (void 0 === i._array && (i._array = new Float32Array(4 * c.length)), p = 0, m = c.length; p < m; p++) g = 4 * p, i._array[g] = c[p].x, i._array[g + 1] = c[p].y, i._array[g + 2] = c[p].z, i._array[g + 3] = c[p].w;
                    oi.uniform4fv(o, i._array)
                } else if ("m4" === p) void 0 === i._array && (i._array = new Float32Array(16)), c.flattenToArray(i._array), oi.uniformMatrix4fv(o, !1, i._array);
                else if ("m4v" === p) {
                    for (void 0 === i._array && (i._array = new Float32Array(16 * c.length)), p = 0, m = c.length; p < m; p++) c[p].flattenToArrayOffset(i._array, 16 * p);
                    oi.uniformMatrix4fv(o, !1, i._array)
                } else if ("t" === p) {
                    if (g = c, c = N(), oi.uniform1i(o, c), g)
                        if (g.image instanceof Array && 6 === g.image.length) {
                            if (o = c, 6 === (i = g).image.length)
                                if (i.needsUpdate) {
                                    for (i.image.__webglTextureCube || (i.addEventListener("dispose", Me), i.image.__webglTextureCube = oi.createTexture(), q.info.memory.textures++), oi.activeTexture(oi.TEXTURE0 + o), oi.bindTexture(oi.TEXTURE_CUBE_MAP, i.image.__webglTextureCube), oi.pixelStorei(oi.UNPACK_FLIP_Y_WEBGL, i.flipY), o = i instanceof THREE.CompressedTexture, c = [], p = 0; p < 6; p++) q.autoScaleCubemaps && !o ? (m = c, g = p, E = i.image[p], y = Ee, E.width <= y && E.height <= y || (T = Math.max(E.width, E.height), v = Math.floor(E.width * y / T), y = Math.floor(E.height * y / T), (T = document.createElement("canvas")).width = v, T.height = y, T.getContext("2d").drawImage(E, 0, 0, E.width, E.height, 0, 0, v, y), E = T), m[g] = E) : c[p] = i.image[p];
                                    for (p = c[0], m = THREE.Math.isPowerOfTwo(p.width) && THREE.Math.isPowerOfTwo(p.height), g = G(i.format), E = G(i.type), $(oi.TEXTURE_CUBE_MAP, i, m), p = 0; p < 6; p++)
                                        if (o)
                                            for (T = 0, b = (y = c[p].mipmaps).length; T < b; T++) v = y[T], i.format !== THREE.RGBAFormat ? oi.compressedTexImage2D(oi.TEXTURE_CUBE_MAP_POSITIVE_X + p, T, g, v.width, v.height, 0, v.data) : oi.texImage2D(oi.TEXTURE_CUBE_MAP_POSITIVE_X + p, T, g, v.width, v.height, 0, g, E, v.data);
                                        else oi.texImage2D(oi.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, g, g, E, c[p]);
                                    i.generateMipmaps && m && oi.generateMipmap(oi.TEXTURE_CUBE_MAP), i.needsUpdate = !1, i.onUpdate && i.onUpdate()
                                } else oi.activeTexture(oi.TEXTURE0 + o), oi.bindTexture(oi.TEXTURE_CUBE_MAP, i.image.__webglTextureCube)
                        } else g instanceof THREE.WebGLRenderTargetCube ? (i = g, oi.activeTexture(oi.TEXTURE0 + c), oi.bindTexture(oi.TEXTURE_CUBE_MAP, i.__webglTexture)) : q.setTexture(g, c)
                } else if ("tv" === p) {
                    for (void 0 === i._array && (i._array = []), p = 0, m = i.value.length; p < m; p++) i._array[p] = N();
                    for (oi.uniform1iv(o, i._array), p = 0, m = i.value.length; p < m; p++) g = i.value[p], c = i._array[p], g && q.setTexture(g, c)
                } else console.warn("THREE.WebGLRenderer: Unknown uniform type: " + p);
                (n instanceof THREE.ShaderMaterial || n instanceof THREE.MeshPhongMaterial || n.envMap) && null !== s.cameraPosition && (li.setFromMatrixPosition(e.matrixWorld), oi.uniform3f(s.cameraPosition, li.x, li.y, li.z)), (n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.ShaderMaterial || n.skinning) && null !== s.viewMatrix && oi.uniformMatrix4fv(s.viewMatrix, !1, e.matrixWorldInverse.elements)
            }
            return oi.uniformMatrix4fv(s.modelViewMatrix, !1, r._modelViewMatrix.elements), s.normalMatrix && oi.uniformMatrix3fv(s.normalMatrix, !1, r._normalMatrix.elements), null !== s.modelMatrix && oi.uniformMatrix4fv(s.modelMatrix, !1, r.matrixWorld.elements), a
        }

        function N() {
            var e = Q;
            return me <= e && console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + me), Q += 1, e
        }

        function B(e, t, i, n) {
            e[t] = i.r * i.r * n, e[t + 1] = i.g * i.g * n, e[t + 2] = i.b * i.b * n
        }

        function I(e, t, i, n) {
            e[t] = i.r * n, e[t + 1] = i.g * n, e[t + 2] = i.b * n
        }

        function b(e) {
            e !== ne && (oi.lineWidth(e), ne = e)
        }

        function x(e, t, i) {
            ee !== e && (e ? oi.enable(oi.POLYGON_OFFSET_FILL) : oi.disable(oi.POLYGON_OFFSET_FILL), ee = e), !e || te === t && ie === i || (oi.polygonOffset(t, i), te = t, ie = i)
        }

        function R(e, t) {
            var i;
            return "fragment" === e ? i = oi.createShader(oi.FRAGMENT_SHADER) : "vertex" === e && (i = oi.createShader(oi.VERTEX_SHADER)), oi.shaderSource(i, t), oi.compileShader(i), oi.getShaderParameter(i, oi.COMPILE_STATUS) ? i : (console.error(oi.getShaderInfoLog(i)), console.error(function (e) {
                for (var t = 0, i = (e = e.split("\n")).length; t < i; t++) e[t] = t + 1 + ": " + e[t];
                return e.join("\n")
            }(t)), null)
        }

        function $(e, t, i) {
            i ? (oi.texParameteri(e, oi.TEXTURE_WRAP_S, G(t.wrapS)), oi.texParameteri(e, oi.TEXTURE_WRAP_T, G(t.wrapT)), oi.texParameteri(e, oi.TEXTURE_MAG_FILTER, G(t.magFilter)), oi.texParameteri(e, oi.TEXTURE_MIN_FILTER, G(t.minFilter))) : (oi.texParameteri(e, oi.TEXTURE_WRAP_S, oi.CLAMP_TO_EDGE), oi.texParameteri(e, oi.TEXTURE_WRAP_T, oi.CLAMP_TO_EDGE), oi.texParameteri(e, oi.TEXTURE_MAG_FILTER, r(t.magFilter)), oi.texParameteri(e, oi.TEXTURE_MIN_FILTER, r(t.minFilter))), C && t.type !== THREE.FloatType && (1 < t.anisotropy || t.__oldAnisotropy) && (oi.texParameterf(e, C.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, ve)), t.__oldAnisotropy = t.anisotropy)
        }

        function h(e, t) {
            oi.bindRenderbuffer(oi.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer ? (oi.renderbufferStorage(oi.RENDERBUFFER, oi.DEPTH_COMPONENT16, t.width, t.height), oi.framebufferRenderbuffer(oi.FRAMEBUFFER, oi.DEPTH_ATTACHMENT, oi.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (oi.renderbufferStorage(oi.RENDERBUFFER, oi.DEPTH_STENCIL, t.width, t.height), oi.framebufferRenderbuffer(oi.FRAMEBUFFER, oi.DEPTH_STENCIL_ATTACHMENT, oi.RENDERBUFFER, e)) : oi.renderbufferStorage(oi.RENDERBUFFER, oi.RGBA4, t.width, t.height)
        }

        function r(e) {
            return e === THREE.NearestFilter || e === THREE.NearestMipMapNearestFilter || e === THREE.NearestMipMapLinearFilter ? oi.NEAREST : oi.LINEAR
        }

        function G(e) {
            if (e === THREE.RepeatWrapping) return oi.REPEAT;
            if (e === THREE.ClampToEdgeWrapping) return oi.CLAMP_TO_EDGE;
            if (e === THREE.MirroredRepeatWrapping) return oi.MIRRORED_REPEAT;
            if (e === THREE.NearestFilter) return oi.NEAREST;
            if (e === THREE.NearestMipMapNearestFilter) return oi.NEAREST_MIPMAP_NEAREST;
            if (e === THREE.NearestMipMapLinearFilter) return oi.NEAREST_MIPMAP_LINEAR;
            if (e === THREE.LinearFilter) return oi.LINEAR;
            if (e === THREE.LinearMipMapNearestFilter) return oi.LINEAR_MIPMAP_NEAREST;
            if (e === THREE.LinearMipMapLinearFilter) return oi.LINEAR_MIPMAP_LINEAR;
            if (e === THREE.UnsignedByteType) return oi.UNSIGNED_BYTE;
            if (e === THREE.UnsignedShort4444Type) return oi.UNSIGNED_SHORT_4_4_4_4;
            if (e === THREE.UnsignedShort5551Type) return oi.UNSIGNED_SHORT_5_5_5_1;
            if (e === THREE.UnsignedShort565Type) return oi.UNSIGNED_SHORT_5_6_5;
            if (e === THREE.ByteType) return oi.BYTE;
            if (e === THREE.ShortType) return oi.SHORT;
            if (e === THREE.UnsignedShortType) return oi.UNSIGNED_SHORT;
            if (e === THREE.IntType) return oi.INT;
            if (e === THREE.UnsignedIntType) return oi.UNSIGNED_INT;
            if (e === THREE.FloatType) return oi.FLOAT;
            if (e === THREE.AlphaFormat) return oi.ALPHA;
            if (e === THREE.RGBFormat) return oi.RGB;
            if (e === THREE.RGBAFormat) return oi.RGBA;
            if (e === THREE.LuminanceFormat) return oi.LUMINANCE;
            if (e === THREE.LuminanceAlphaFormat) return oi.LUMINANCE_ALPHA;
            if (e === THREE.AddEquation) return oi.FUNC_ADD;
            if (e === THREE.SubtractEquation) return oi.FUNC_SUBTRACT;
            if (e === THREE.ReverseSubtractEquation) return oi.FUNC_REVERSE_SUBTRACT;
            if (e === THREE.ZeroFactor) return oi.ZERO;
            if (e === THREE.OneFactor) return oi.ONE;
            if (e === THREE.SrcColorFactor) return oi.SRC_COLOR;
            if (e === THREE.OneMinusSrcColorFactor) return oi.ONE_MINUS_SRC_COLOR;
            if (e === THREE.SrcAlphaFactor) return oi.SRC_ALPHA;
            if (e === THREE.OneMinusSrcAlphaFactor) return oi.ONE_MINUS_SRC_ALPHA;
            if (e === THREE.DstAlphaFactor) return oi.DST_ALPHA;
            if (e === THREE.OneMinusDstAlphaFactor) return oi.ONE_MINUS_DST_ALPHA;
            if (e === THREE.DstColorFactor) return oi.DST_COLOR;
            if (e === THREE.OneMinusDstColorFactor) return oi.ONE_MINUS_DST_COLOR;
            if (e === THREE.SrcAlphaSaturateFactor) return oi.SRC_ALPHA_SATURATE;
            if (void 0 !== A) {
                if (e === THREE.RGB_S3TC_DXT1_Format) return A.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (e === THREE.RGBA_S3TC_DXT1_Format) return A.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (e === THREE.RGBA_S3TC_DXT3_Format) return A.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (e === THREE.RGBA_S3TC_DXT5_Format) return A.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            return 0
        }
        console.log("THREE.WebGLRenderer", THREE.REVISION);
        var W = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElement("canvas"),
            t = void 0 !== e.context ? e.context : null,
            w = void 0 !== e.precision ? e.precision : "highp",
            o = void 0 !== e.alpha && e.alpha,
            a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            s = void 0 !== e.antialias && e.antialias,
            u = void 0 === e.stencil || e.stencil,
            f = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            _ = new THREE.Color(0),
            H = 0;
        this.domElement = W, this.context = null, this.devicePixelRatio = void 0 !== e.devicePixelRatio ? e.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.autoUpdateObjects = this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1, this.shadowMapAutoUpdate = !0, this.shadowMapType = THREE.PCFShadowMap, this.shadowMapCullFace = THREE.CullFaceFront, this.shadowMapCascade = this.shadowMapDebug = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0, this.renderPluginsPre = [], this.renderPluginsPost = [], this.info = {
            memory: {
                programs: 0,
                geometries: 0,
                textures: 0
            },
            render: {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            }
        };
        var oi, S, M, C, A, q = this,
            P = [],
            L = 0,
            X = null,
            D = null,
            Y = -1,
            z = null,
            K = null,
            Q = 0,
            k = -1,
            O = -1,
            F = -1,
            j = -1,
            U = -1,
            V = -1,
            Z = -1,
            J = -1,
            ee = null,
            te = null,
            ie = null,
            ne = null,
            re = 0,
            oe = 0,
            ae = W.width,
            se = W.height,
            le = 0,
            ce = 0,
            he = new Uint8Array(16),
            ue = new THREE.Frustum,
            ai = new THREE.Matrix4,
            si = new THREE.Matrix4,
            li = new THREE.Vector3,
            fe = new THREE.Vector3,
            de = !0,
            pe = {
                ambient: [0, 0, 0],
                directional: {
                    length: 0,
                    colors: [],
                    positions: []
                },
                point: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: []
                },
                spot: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: [],
                    directions: [],
                    anglesCos: [],
                    exponents: []
                },
                hemi: {
                    length: 0,
                    skyColors: [],
                    groundColors: [],
                    positions: []
                }
            };
        ! function () {
            try {
                var e = {
                    alpha: o,
                    premultipliedAlpha: a,
                    antialias: s,
                    stencil: u,
                    preserveDrawingBuffer: f
                };
                if (null === (oi = t || W.getContext("webgl", e) || W.getContext("experimental-webgl", e))) throw "Error creating WebGL context."
            } catch (e) {
                console.error(e)
            }
            S = oi.getExtension("OES_texture_float"), oi.getExtension("OES_texture_float_linear"), M = oi.getExtension("OES_standard_derivatives"), C = oi.getExtension("EXT_texture_filter_anisotropic") || oi.getExtension("MOZ_EXT_texture_filter_anisotropic") || oi.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), A = oi.getExtension("WEBGL_compressed_texture_s3tc") || oi.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || oi.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"), S || console.log("THREE.WebGLRenderer: Float textures not supported."), M || console.log("THREE.WebGLRenderer: Standard derivatives not supported."), C || console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported."), A || console.log("THREE.WebGLRenderer: S3TC compressed textures not supported."), void 0 === oi.getShaderPrecisionFormat && (oi.getShaderPrecisionFormat = function () {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        }(), oi.clearColor(0, 0, 0, 1), oi.clearDepth(1), oi.clearStencil(0), oi.enable(oi.DEPTH_TEST), oi.depthFunc(oi.LEQUAL), oi.frontFace(oi.CCW), oi.cullFace(oi.BACK), oi.enable(oi.CULL_FACE), oi.enable(oi.BLEND), oi.blendEquation(oi.FUNC_ADD), oi.blendFunc(oi.SRC_ALPHA, oi.ONE_MINUS_SRC_ALPHA), oi.viewport(re, oe, ae, se), oi.clearColor(_.r, _.g, _.b, H);
        var me = (this.context = oi).getParameter(oi.MAX_TEXTURE_IMAGE_UNITS),
            ge = oi.getParameter(oi.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        oi.getParameter(oi.MAX_TEXTURE_SIZE);
        var Ee = oi.getParameter(oi.MAX_CUBE_MAP_TEXTURE_SIZE),
            ve = C ? oi.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
            ye = 0 < ge,
            Te = ye && S;
        A && oi.getParameter(oi.COMPRESSED_TEXTURE_FORMATS);
        var be = oi.getShaderPrecisionFormat(oi.VERTEX_SHADER, oi.HIGH_FLOAT),
            xe = oi.getShaderPrecisionFormat(oi.VERTEX_SHADER, oi.MEDIUM_FLOAT);
        oi.getShaderPrecisionFormat(oi.VERTEX_SHADER, oi.LOW_FLOAT);
        var Re = oi.getShaderPrecisionFormat(oi.FRAGMENT_SHADER, oi.HIGH_FLOAT),
            we = oi.getShaderPrecisionFormat(oi.FRAGMENT_SHADER, oi.MEDIUM_FLOAT);
        oi.getShaderPrecisionFormat(oi.FRAGMENT_SHADER, oi.LOW_FLOAT), oi.getShaderPrecisionFormat(oi.VERTEX_SHADER, oi.HIGH_INT), oi.getShaderPrecisionFormat(oi.VERTEX_SHADER, oi.MEDIUM_INT), oi.getShaderPrecisionFormat(oi.VERTEX_SHADER, oi.LOW_INT), oi.getShaderPrecisionFormat(oi.FRAGMENT_SHADER, oi.HIGH_INT), oi.getShaderPrecisionFormat(oi.FRAGMENT_SHADER, oi.MEDIUM_INT), oi.getShaderPrecisionFormat(oi.FRAGMENT_SHADER, oi.LOW_INT);
        var _e = 0 < be.precision && 0 < Re.precision,
            He = 0 < xe.precision && 0 < we.precision;
        "highp" !== w || _e || (He ? (w = "mediump", console.warn("WebGLRenderer: highp not supported, using mediump")) : (w = "lowp", console.warn("WebGLRenderer: highp and mediump not supported, using lowp"))), "mediump" !== w || He || (w = "lowp", console.warn("WebGLRenderer: mediump not supported, using lowp")), this.getContext = function () {
            return oi
        }, this.supportsVertexTextures = function () {
            return ye
        }, this.supportsFloatTextures = function () {
            return S
        }, this.supportsStandardDerivatives = function () {
            return M
        }, this.supportsCompressedTextureS3TC = function () {
            return A
        }, this.getMaxAnisotropy = function () {
            return ve
        }, this.getPrecision = function () {
            return w
        }, this.setSize = function (e, t, i) {
            W.width = e * this.devicePixelRatio, W.height = t * this.devicePixelRatio, 1 !== this.devicePixelRatio && !1 !== i && (W.style.width = e + "px", W.style.height = t + "px"), this.setViewport(0, 0, e, t)
        }, this.setViewport = function (e, t, i, n) {
            re = e * this.devicePixelRatio, oe = t * this.devicePixelRatio, ae = i * this.devicePixelRatio, se = n * this.devicePixelRatio, oi.viewport(re, oe, ae, se)
        }, this.setScissor = function (e, t, i, n) {
            oi.scissor(e * this.devicePixelRatio, t * this.devicePixelRatio, i * this.devicePixelRatio, n * this.devicePixelRatio)
        }, this.enableScissorTest = function (e) {
            e ? oi.enable(oi.SCISSOR_TEST) : oi.disable(oi.SCISSOR_TEST)
        }, this.setClearColor = function (e, t) {
            _.set(e), H = void 0 !== t ? t : 1, oi.clearColor(_.r, _.g, _.b, H)
        }, this.setClearColorHex = function (e, t) {
            console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t)
        }, this.getClearColor = function () {
            return _
        }, this.getClearAlpha = function () {
            return H
        }, this.clear = function (e, t, i) {
            var n = 0;
            (void 0 === e || e) && (n |= oi.COLOR_BUFFER_BIT), (void 0 === t || t) && (n |= oi.DEPTH_BUFFER_BIT), (void 0 === i || i) && (n |= oi.STENCIL_BUFFER_BIT), oi.clear(n)
        }, this.clearColor = function () {
            oi.clear(oi.COLOR_BUFFER_BIT)
        }, this.clearDepth = function () {
            oi.clear(oi.DEPTH_BUFFER_BIT)
        }, this.clearStencil = function () {
            oi.clear(oi.STENCIL_BUFFER_BIT)
        }, this.clearTarget = function (e, t, i, n) {
            this.setRenderTarget(e), this.clear(t, i, n)
        }, this.addPostPlugin = function (e) {
            e.init(this), this.renderPluginsPost.push(e)
        }, this.addPrePlugin = function (e) {
            e.init(this), this.renderPluginsPre.push(e)
        }, this.updateShadowMap = function (e, t) {
            Y = z = J = Z = F = -1, de = !(X = null), O = k = -1, this.shadowMapPlugin.update(e, t)
        };
        var Se = function (e) {
                if ((e = e.target).removeEventListener("dispose", Se), e.__webglInit = void 0, e instanceof THREE.BufferGeometry) {
                    var t, i = e.attributes;
                    for (t in i) void 0 !== i[t].buffer && oi.deleteBuffer(i[t].buffer);
                    q.info.memory.geometries--
                } else if (void 0 !== e.geometryGroups)
                    for (i in e.geometryGroups) {
                        if (void 0 !== (t = e.geometryGroups[i]).numMorphTargets)
                            for (var n = 0, r = t.numMorphTargets; n < r; n++) oi.deleteBuffer(t.__webglMorphTargetsBuffers[n]);
                        if (void 0 !== t.numMorphNormals)
                            for (n = 0, r = t.numMorphNormals; n < r; n++) oi.deleteBuffer(t.__webglMorphNormalsBuffers[n]);
                        Pe(t)
                    } else Pe(e)
            },
            Me = function (e) {
                (e = e.target).removeEventListener("dispose", Me), e.image && e.image.__webglTextureCube ? oi.deleteTexture(e.image.__webglTextureCube) : e.__webglInit && (e.__webglInit = !1, oi.deleteTexture(e.__webglTexture)), q.info.memory.textures--
            },
            Ce = function (e) {
                if ((e = e.target).removeEventListener("dispose", Ce), e && e.__webglTexture)
                    if (oi.deleteTexture(e.__webglTexture), e instanceof THREE.WebGLRenderTargetCube)
                        for (var t = 0; t < 6; t++) oi.deleteFramebuffer(e.__webglFramebuffer[t]), oi.deleteRenderbuffer(e.__webglRenderbuffer[t]);
                    else oi.deleteFramebuffer(e.__webglFramebuffer), oi.deleteRenderbuffer(e.__webglRenderbuffer);
                q.info.memory.textures--
            },
            Ae = function (e) {
                (e = e.target).removeEventListener("dispose", Ae), Le(e)
            },
            Pe = function (e) {
                if (void 0 !== e.__webglVertexBuffer && oi.deleteBuffer(e.__webglVertexBuffer), void 0 !== e.__webglNormalBuffer && oi.deleteBuffer(e.__webglNormalBuffer), void 0 !== e.__webglTangentBuffer && oi.deleteBuffer(e.__webglTangentBuffer), void 0 !== e.__webglColorBuffer && oi.deleteBuffer(e.__webglColorBuffer), void 0 !== e.__webglUVBuffer && oi.deleteBuffer(e.__webglUVBuffer), void 0 !== e.__webglUV2Buffer && oi.deleteBuffer(e.__webglUV2Buffer), void 0 !== e.__webglSkinIndicesBuffer && oi.deleteBuffer(e.__webglSkinIndicesBuffer), void 0 !== e.__webglSkinWeightsBuffer && oi.deleteBuffer(e.__webglSkinWeightsBuffer), void 0 !== e.__webglFaceBuffer && oi.deleteBuffer(e.__webglFaceBuffer), void 0 !== e.__webglLineBuffer && oi.deleteBuffer(e.__webglLineBuffer), void 0 !== e.__webglLineDistanceBuffer && oi.deleteBuffer(e.__webglLineDistanceBuffer), void 0 !== e.__webglCustomAttributesList)
                    for (var t in e.__webglCustomAttributesList) oi.deleteBuffer(e.__webglCustomAttributesList[t].buffer);
                q.info.memory.geometries--
            },
            Le = function (e) {
                var t = e.program;
                if (void 0 !== t) {
                    e.program = void 0;
                    var i, n, r = !1;
                    for (e = 0, i = P.length; e < i; e++)
                        if ((n = P[e]).program === t) {
                            n.usedTimes--, 0 === n.usedTimes && (r = !0);
                            break
                        } if (!0 === r) {
                        for (r = [], e = 0, i = P.length; e < i; e++)(n = P[e]).program !== t && r.push(n);
                        P = r, oi.deleteProgram(t), q.info.memory.programs--
                    }
                }
            };
        this.renderBufferImmediate = function (e, t, i) {
            if (e.hasPositions && !e.__webglVertexBuffer && (e.__webglVertexBuffer = oi.createBuffer()), e.hasNormals && !e.__webglNormalBuffer && (e.__webglNormalBuffer = oi.createBuffer()), e.hasUvs && !e.__webglUvBuffer && (e.__webglUvBuffer = oi.createBuffer()), e.hasColors && !e.__webglColorBuffer && (e.__webglColorBuffer = oi.createBuffer()), e.hasPositions && (oi.bindBuffer(oi.ARRAY_BUFFER, e.__webglVertexBuffer), oi.bufferData(oi.ARRAY_BUFFER, e.positionArray, oi.DYNAMIC_DRAW), oi.enableVertexAttribArray(t.attributes.position), oi.vertexAttribPointer(t.attributes.position, 3, oi.FLOAT, !1, 0, 0)), e.hasNormals) {
                if (oi.bindBuffer(oi.ARRAY_BUFFER, e.__webglNormalBuffer), i.shading === THREE.FlatShading) {
                    var n, r, o, a, s, l, c, h, u = 3 * e.count;
                    for (h = 0; h < u; h += 9) n = (c = e.normalArray)[h], r = c[h + 1], o = c[h + 2], a = c[h + 3], s = c[h + 4], l = c[h + 5], n = (n + a + c[h + 6]) / 3, r = (r + s + c[h + 7]) / 3, o = (o + l + c[h + 8]) / 3, c[h] = n, c[h + 1] = r, c[h + 2] = o, c[h + 3] = n, c[h + 4] = r, c[h + 5] = o, c[h + 6] = n, c[h + 7] = r, c[h + 8] = o
                }
                oi.bufferData(oi.ARRAY_BUFFER, e.normalArray, oi.DYNAMIC_DRAW), oi.enableVertexAttribArray(t.attributes.normal), oi.vertexAttribPointer(t.attributes.normal, 3, oi.FLOAT, !1, 0, 0)
            }
            e.hasUvs && i.map && (oi.bindBuffer(oi.ARRAY_BUFFER, e.__webglUvBuffer), oi.bufferData(oi.ARRAY_BUFFER, e.uvArray, oi.DYNAMIC_DRAW), oi.enableVertexAttribArray(t.attributes.uv), oi.vertexAttribPointer(t.attributes.uv, 2, oi.FLOAT, !1, 0, 0)), e.hasColors && i.vertexColors !== THREE.NoColors && (oi.bindBuffer(oi.ARRAY_BUFFER, e.__webglColorBuffer), oi.bufferData(oi.ARRAY_BUFFER, e.colorArray, oi.DYNAMIC_DRAW), oi.enableVertexAttribArray(t.attributes.color), oi.vertexAttribPointer(t.attributes.color, 3, oi.FLOAT, !1, 0, 0)), oi.drawArrays(oi.TRIANGLES, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function (e, t, i, n, r, o) {
            var a, s, l, c;
            if (!1 !== n.visible)
                if (e = (a = T(e, t, i, n, o)).attributes, t = r.attributes, i = !1, (a = 16777215 * r.id + 2 * a.id + (n.wireframe ? 1 : 0)) !== z && (z = a, i = !0), i && m(), o instanceof THREE.Mesh)
                    if (o = t.index) {
                        1 < (r = r.offsets).length && (i = !0);
                        for (var h = 0, u = r.length; h < u; h++) {
                            var f = r[h].index;
                            if (i) {
                                for (s in e) l = e[s], a = t[s], 0 <= l && (a ? (c = a.itemSize, oi.bindBuffer(oi.ARRAY_BUFFER, a.buffer), p(l), oi.vertexAttribPointer(l, c, oi.FLOAT, !1, 0, f * c * 4)) : n.defaultAttributeValues && (2 === n.defaultAttributeValues[s].length ? oi.vertexAttrib2fv(l, n.defaultAttributeValues[s]) : 3 === n.defaultAttributeValues[s].length && oi.vertexAttrib3fv(l, n.defaultAttributeValues[s])));
                                oi.bindBuffer(oi.ELEMENT_ARRAY_BUFFER, o.buffer)
                            }
                            oi.drawElements(oi.TRIANGLES, r[h].count, oi.UNSIGNED_SHORT, 2 * r[h].start), q.info.render.calls++, q.info.render.vertices += r[h].count, q.info.render.faces += r[h].count / 3
                        }
                    } else {
                        if (i)
                            for (s in e) "index" !== s && (l = e[s], a = t[s], 0 <= l && (a ? (c = a.itemSize, oi.bindBuffer(oi.ARRAY_BUFFER, a.buffer), p(l), oi.vertexAttribPointer(l, c, oi.FLOAT, !1, 0, 0)) : n.defaultAttributeValues && n.defaultAttributeValues[s] && (2 === n.defaultAttributeValues[s].length ? oi.vertexAttrib2fv(l, n.defaultAttributeValues[s]) : 3 === n.defaultAttributeValues[s].length && oi.vertexAttrib3fv(l, n.defaultAttributeValues[s]))));
                        n = r.attributes.position, oi.drawArrays(oi.TRIANGLES, 0, n.array.length / 3), q.info.render.calls++, q.info.render.vertices += n.array.length / 3, q.info.render.faces += n.array.length / 3 / 3
                    }
            else if (o instanceof THREE.ParticleSystem) {
                if (i)
                    for (s in e) l = e[s], a = t[s], 0 <= l && (a ? (c = a.itemSize, oi.bindBuffer(oi.ARRAY_BUFFER, a.buffer), p(l), oi.vertexAttribPointer(l, c, oi.FLOAT, !1, 0, 0)) : n.defaultAttributeValues && n.defaultAttributeValues[s] && (2 === n.defaultAttributeValues[s].length ? oi.vertexAttrib2fv(l, n.defaultAttributeValues[s]) : 3 === n.defaultAttributeValues[s].length && oi.vertexAttrib3fv(l, n.defaultAttributeValues[s])));
                n = t.position, oi.drawArrays(oi.POINTS, 0, n.array.length / 3), q.info.render.calls++, q.info.render.points += n.array.length / 3
            } else if (o instanceof THREE.Line)
                if (s = o.type === THREE.LineStrip ? oi.LINE_STRIP : oi.LINES, b(n.linewidth), o = t.index)
                    for (1 < (r = r.offsets).length && (i = !0), h = 0, u = r.length; h < u; h++) f = r[h].index, i && (d(n, e, t, f), oi.bindBuffer(oi.ELEMENT_ARRAY_BUFFER, o.buffer)), oi.drawElements(oi.LINES, r[h].count, oi.UNSIGNED_SHORT, 2 * r[h].start), q.info.render.calls++, q.info.render.vertices += r[h].count;
                else i && d(n, e, t, 0), n = t.position, oi.drawArrays(s, 0, n.array.length / 3), q.info.render.calls++, q.info.render.points += n.array.length
        }, this.renderBuffer = function (e, t, i, n, r, o) {
            if (!1 !== n.visible) {
                var a, s;
                if (e = (i = T(e, t, i, n, o)).attributes, t = !1, (i = 16777215 * r.id + 2 * i.id + (n.wireframe ? 1 : 0)) !== z && (z = i, t = !0), t && m(), !n.morphTargets && 0 <= e.position) t && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglVertexBuffer), p(e.position), oi.vertexAttribPointer(e.position, 3, oi.FLOAT, !1, 0, 0));
                else if (o.morphTargetBase) {
                    if (i = n.program.attributes, -1 !== o.morphTargetBase && 0 <= i.position ? (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglMorphTargetsBuffers[o.morphTargetBase]), p(i.position), oi.vertexAttribPointer(i.position, 3, oi.FLOAT, !1, 0, 0)) : 0 <= i.position && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglVertexBuffer), p(i.position), oi.vertexAttribPointer(i.position, 3, oi.FLOAT, !1, 0, 0)), o.morphTargetForcedOrder.length) {
                        var l = 0;
                        for (s = o.morphTargetForcedOrder, a = o.morphTargetInfluences; l < n.numSupportedMorphTargets && l < s.length;) 0 <= i["morphTarget" + l] && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglMorphTargetsBuffers[s[l]]), p(i["morphTarget" + l]), oi.vertexAttribPointer(i["morphTarget" + l], 3, oi.FLOAT, !1, 0, 0)), 0 <= i["morphNormal" + l] && n.morphNormals && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglMorphNormalsBuffers[s[l]]), p(i["morphNormal" + l]), oi.vertexAttribPointer(i["morphNormal" + l], 3, oi.FLOAT, !1, 0, 0)), o.__webglMorphTargetInfluences[l] = a[s[l]], l++
                    } else {
                        s = [];
                        var c, h = (a = o.morphTargetInfluences).length;
                        for (c = 0; c < h; c++) 0 < (l = a[c]) && s.push([l, c]);
                        for (s.length > n.numSupportedMorphTargets ? (s.sort(ei), s.length = n.numSupportedMorphTargets) : s.length > n.numSupportedMorphNormals ? s.sort(ei) : 0 === s.length && s.push([0, 0]), l = 0; l < n.numSupportedMorphTargets;) s[l] ? (c = s[l][1], 0 <= i["morphTarget" + l] && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglMorphTargetsBuffers[c]), p(i["morphTarget" + l]), oi.vertexAttribPointer(i["morphTarget" + l], 3, oi.FLOAT, !1, 0, 0)), 0 <= i["morphNormal" + l] && n.morphNormals && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglMorphNormalsBuffers[c]), p(i["morphNormal" + l]), oi.vertexAttribPointer(i["morphNormal" + l], 3, oi.FLOAT, !1, 0, 0)), o.__webglMorphTargetInfluences[l] = a[c]) : o.__webglMorphTargetInfluences[l] = 0, l++
                    }
                    null !== n.program.uniforms.morphTargetInfluences && oi.uniform1fv(n.program.uniforms.morphTargetInfluences, o.__webglMorphTargetInfluences)
                }
                if (t) {
                    if (r.__webglCustomAttributesList)
                        for (a = 0, s = r.__webglCustomAttributesList.length; a < s; a++) 0 <= e[(i = r.__webglCustomAttributesList[a]).buffer.belongsToAttribute] && (oi.bindBuffer(oi.ARRAY_BUFFER, i.buffer), p(e[i.buffer.belongsToAttribute]), oi.vertexAttribPointer(e[i.buffer.belongsToAttribute], i.size, oi.FLOAT, !1, 0, 0));
                    0 <= e.color && (0 < o.geometry.colors.length || 0 < o.geometry.faces.length ? (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglColorBuffer), p(e.color), oi.vertexAttribPointer(e.color, 3, oi.FLOAT, !1, 0, 0)) : n.defaultAttributeValues && oi.vertexAttrib3fv(e.color, n.defaultAttributeValues.color)), 0 <= e.normal && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglNormalBuffer), p(e.normal), oi.vertexAttribPointer(e.normal, 3, oi.FLOAT, !1, 0, 0)), 0 <= e.tangent && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglTangentBuffer), p(e.tangent), oi.vertexAttribPointer(e.tangent, 4, oi.FLOAT, !1, 0, 0)), 0 <= e.uv && (o.geometry.faceVertexUvs[0] ? (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglUVBuffer), p(e.uv), oi.vertexAttribPointer(e.uv, 2, oi.FLOAT, !1, 0, 0)) : n.defaultAttributeValues && oi.vertexAttrib2fv(e.uv, n.defaultAttributeValues.uv)), 0 <= e.uv2 && (o.geometry.faceVertexUvs[1] ? (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglUV2Buffer), p(e.uv2), oi.vertexAttribPointer(e.uv2, 2, oi.FLOAT, !1, 0, 0)) : n.defaultAttributeValues && oi.vertexAttrib2fv(e.uv2, n.defaultAttributeValues.uv2)), n.skinning && 0 <= e.skinIndex && 0 <= e.skinWeight && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglSkinIndicesBuffer), p(e.skinIndex), oi.vertexAttribPointer(e.skinIndex, 4, oi.FLOAT, !1, 0, 0), oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglSkinWeightsBuffer), p(e.skinWeight), oi.vertexAttribPointer(e.skinWeight, 4, oi.FLOAT, !1, 0, 0)), 0 <= e.lineDistance && (oi.bindBuffer(oi.ARRAY_BUFFER, r.__webglLineDistanceBuffer), p(e.lineDistance), oi.vertexAttribPointer(e.lineDistance, 1, oi.FLOAT, !1, 0, 0))
                }
                o instanceof THREE.Mesh ? (n.wireframe ? (b(n.wireframeLinewidth), t && oi.bindBuffer(oi.ELEMENT_ARRAY_BUFFER, r.__webglLineBuffer), oi.drawElements(oi.LINES, r.__webglLineCount, oi.UNSIGNED_SHORT, 0)) : (t && oi.bindBuffer(oi.ELEMENT_ARRAY_BUFFER, r.__webglFaceBuffer), oi.drawElements(oi.TRIANGLES, r.__webglFaceCount, oi.UNSIGNED_SHORT, 0)), q.info.render.calls++, q.info.render.vertices += r.__webglFaceCount, q.info.render.faces += r.__webglFaceCount / 3) : o instanceof THREE.Line ? (o = o.type === THREE.LineStrip ? oi.LINE_STRIP : oi.LINES, b(n.linewidth), oi.drawArrays(o, 0, r.__webglLineCount), q.info.render.calls++) : o instanceof THREE.ParticleSystem && (oi.drawArrays(oi.POINTS, 0, r.__webglParticleCount), q.info.render.calls++, q.info.render.points += r.__webglParticleCount)
            }
        }, this.render = function (e, t, i, n) {
            if (!1 == t instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            else {
                var r, o, a, s, l = e.__lights,
                    c = e.fog;
                for (Y = -1, (de = !0) === e.autoUpdate && e.updateMatrixWorld(), void 0 === t.parent && t.updateMatrixWorld(), t.matrixWorldInverse.getInverse(t.matrixWorld), ai.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), ue.setFromMatrix(ai), this.autoUpdateObjects && this.initWebGLObjects(e), E(this.renderPluginsPre, e, t), q.info.render.calls = 0, q.info.render.vertices = 0, q.info.render.faces = 0, q.info.render.points = 0, this.setRenderTarget(i), (this.autoClear || n) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), n = 0, r = (s = e.__webglObjects).length; n < r; n++)
                    if (a = (o = s[n]).object, o.id = n, o.render = !1, a.visible && (!(a instanceof THREE.Mesh || a instanceof THREE.ParticleSystem) || !a.frustumCulled || ue.intersectsObject(a))) {
                        (h = a)._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, h.matrixWorld), h._normalMatrix.getNormalMatrix(h._modelViewMatrix);
                        var h, u = (h = o).object,
                            f = h.buffer,
                            d = u.geometry;
                        (u = u.material) instanceof THREE.MeshFaceMaterial ? (u = u.materials[d instanceof THREE.BufferGeometry ? 0 : f.materialIndex]).transparent ? (h.transparent = u, h.opaque = null) : (h.opaque = u, h.transparent = null) : u && (u.transparent ? (h.transparent = u, h.opaque = null) : (h.opaque = u, h.transparent = null)), (o.render = !0) === this.sortObjects && (null !== a.renderDepth ? o.z = a.renderDepth : (li.setFromMatrixPosition(a.matrixWorld), li.applyProjection(ai), o.z = li.z))
                    } for (this.sortObjects && s.sort(g), n = 0, r = (s = e.__webglObjectsImmediate).length; n < r; n++)(a = (o = s[n]).object).visible && (a._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, a.matrixWorld), a._normalMatrix.getNormalMatrix(a._modelViewMatrix), (a = o.object.material).transparent ? (o.transparent = a, o.opaque = null) : (o.opaque = a, o.transparent = null));
                e.overrideMaterial ? (n = e.overrideMaterial, this.setBlending(n.blending, n.blendEquation, n.blendSrc, n.blendDst), this.setDepthTest(n.depthTest), this.setDepthWrite(n.depthWrite), x(n.polygonOffset, n.polygonOffsetFactor, n.polygonOffsetUnits), v(e.__webglObjects, !1, "", t, l, c, !0, n), y(e.__webglObjectsImmediate, "", t, l, c, !1, n)) : (n = null, this.setBlending(THREE.NoBlending), v(e.__webglObjects, !0, "opaque", t, l, c, !1, n), y(e.__webglObjectsImmediate, "opaque", t, l, c, !1, n), v(e.__webglObjects, !1, "transparent", t, l, c, !0, n), y(e.__webglObjectsImmediate, "transparent", t, l, c, !0, n)), E(this.renderPluginsPost, e, t), i && i.generateMipmaps && i.minFilter !== THREE.NearestFilter && i.minFilter !== THREE.LinearFilter && (i instanceof THREE.WebGLRenderTargetCube ? (oi.bindTexture(oi.TEXTURE_CUBE_MAP, i.__webglTexture), oi.generateMipmap(oi.TEXTURE_CUBE_MAP), oi.bindTexture(oi.TEXTURE_CUBE_MAP, null)) : (oi.bindTexture(oi.TEXTURE_2D, i.__webglTexture), oi.generateMipmap(oi.TEXTURE_2D), oi.bindTexture(oi.TEXTURE_2D, null))), this.setDepthTest(!0), this.setDepthWrite(!0)
            }
        }, this.renderImmediateObject = function (e, t, i, n, r) {
            var o = T(e, t, i, n, r);
            z = -1, q.setMaterialFaces(n), r.immediateRenderCallback ? r.immediateRenderCallback(o, oi, ue) : r.render(function (e) {
                q.renderBufferImmediate(e, o, n)
            })
        }, this.initWebGLObjects = function (e) {
            for (e.__webglObjects || (e.__webglObjects = [], e.__webglObjectsImmediate = [], e.__webglSprites = [], e.__webglFlares = []); e.__objectsAdded.length;) ti(e.__objectsAdded[0], e), e.__objectsAdded.splice(0, 1);
            for (; e.__objectsRemoved.length;) ri(e.__objectsRemoved[0], e), e.__objectsRemoved.splice(0, 1);
            for (var t = 0, i = e.__webglObjects.length; t < i; t++) {
                var n = e.__webglObjects[t].object;
                void 0 === n.__webglInit && (void 0 !== n.__webglActive && ri(n, e), ti(n, e));
                var r = n,
                    o = r.geometry,
                    a = void 0,
                    s = void 0,
                    l = void 0;
                if (o instanceof THREE.BufferGeometry) {
                    var c = oi.DYNAMIC_DRAW,
                        h = o.attributes,
                        u = void 0,
                        f = void 0;
                    for (u in h)(f = h[u]).needsUpdate && ("index" === u ? (oi.bindBuffer(oi.ELEMENT_ARRAY_BUFFER, f.buffer), oi.bufferData(oi.ELEMENT_ARRAY_BUFFER, f.array, c)) : (oi.bindBuffer(oi.ARRAY_BUFFER, f.buffer), oi.bufferData(oi.ARRAY_BUFFER, f.array, c)), f.needsUpdate = !1)
                } else if (r instanceof THREE.Mesh) {
                    for (var d = 0, p = o.geometryGroupsList.length; d < p; d++)
                        if (l = Qt(r, a = o.geometryGroupsList[d]), o.buffersNeedUpdate && Kt(a, r), s = l.attributes && ii(l), o.verticesNeedUpdate || o.morphTargetsNeedUpdate || o.elementsNeedUpdate || o.uvsNeedUpdate || o.normalsNeedUpdate || o.colorsNeedUpdate || o.tangentsNeedUpdate || s) {
                            var m = a,
                                g = r,
                                E = oi.DYNAMIC_DRAW,
                                v = !o.dynamic,
                                y = l;
                            if (m.__inittedArrays) {
                                var T = Zt(y),
                                    b = !!y.vertexColors && y.vertexColors,
                                    x = Jt(y),
                                    R = T === THREE.SmoothShading,
                                    w = void 0,
                                    _ = void 0,
                                    H = void 0,
                                    S = void 0,
                                    M = void 0,
                                    C = void 0,
                                    A = void 0,
                                    P = void 0,
                                    L = void 0,
                                    D = void 0,
                                    z = void 0,
                                    k = void 0,
                                    O = void 0,
                                    F = void 0,
                                    j = void 0,
                                    U = void 0,
                                    V = void 0,
                                    N = void 0,
                                    B = void 0,
                                    I = void 0,
                                    $ = void 0,
                                    G = void 0,
                                    W = void 0,
                                    q = void 0,
                                    X = void 0,
                                    Y = void 0,
                                    K = void 0,
                                    Q = void 0,
                                    Z = void 0,
                                    J = void 0,
                                    ee = void 0,
                                    te = void 0,
                                    ie = void 0,
                                    ne = void 0,
                                    re = void 0,
                                    oe = void 0,
                                    ae = void 0,
                                    se = void 0,
                                    le = void 0,
                                    ce = 0,
                                    he = 0,
                                    ue = 0,
                                    fe = 0,
                                    de = 0,
                                    pe = 0,
                                    me = 0,
                                    ge = 0,
                                    Ee = 0,
                                    ve = 0,
                                    ye = 0,
                                    Te = 0,
                                    be = void 0,
                                    xe = m.__vertexArray,
                                    Re = m.__uvArray,
                                    we = m.__uv2Array,
                                    _e = m.__normalArray,
                                    He = m.__tangentArray,
                                    Se = m.__colorArray,
                                    Me = m.__skinIndexArray,
                                    Ce = m.__skinWeightArray,
                                    Ae = m.__morphTargetsArrays,
                                    Pe = m.__morphNormalsArrays,
                                    Le = m.__webglCustomAttributesList,
                                    De = void 0,
                                    ze = m.__faceArray,
                                    ke = m.__lineArray,
                                    Oe = g.geometry,
                                    Fe = Oe.elementsNeedUpdate,
                                    je = Oe.uvsNeedUpdate,
                                    Ue = Oe.normalsNeedUpdate,
                                    Ve = Oe.tangentsNeedUpdate,
                                    Ne = Oe.colorsNeedUpdate,
                                    Be = Oe.morphTargetsNeedUpdate,
                                    Ie = Oe.vertices,
                                    $e = m.faces3,
                                    Ge = Oe.faces,
                                    We = Oe.faceVertexUvs[0],
                                    qe = Oe.faceVertexUvs[1],
                                    Xe = Oe.skinIndices,
                                    Ye = Oe.skinWeights,
                                    Ke = Oe.morphTargets,
                                    Qe = Oe.morphNormals;
                                if (Oe.verticesNeedUpdate) {
                                    for (w = 0, _ = $e.length; w < _; w++) z = Ie[(H = Ge[$e[w]]).a], k = Ie[H.b], O = Ie[H.c], xe[he] = z.x, xe[he + 1] = z.y, xe[he + 2] = z.z, xe[he + 3] = k.x, xe[he + 4] = k.y, xe[he + 5] = k.z, xe[he + 6] = O.x, xe[he + 7] = O.y, xe[he + 8] = O.z, he += 9;
                                    oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglVertexBuffer), oi.bufferData(oi.ARRAY_BUFFER, xe, E)
                                }
                                if (Be)
                                    for (ne = 0, re = Ke.length; ne < re; ne++) {
                                        for (w = ye = 0, _ = $e.length; w < _; w++) H = Ge[se = $e[w]], z = Ke[ne].vertices[H.a], k = Ke[ne].vertices[H.b], O = Ke[ne].vertices[H.c], (oe = Ae[ne])[ye] = z.x, oe[ye + 1] = z.y, oe[ye + 2] = z.z, oe[ye + 3] = k.x, oe[ye + 4] = k.y, oe[ye + 5] = k.z, oe[ye + 6] = O.x, oe[ye + 7] = O.y, oe[ye + 8] = O.z, y.morphNormals && (B = R ? (V = (le = Qe[ne].vertexNormals[se]).a, N = le.b, le.c) : N = V = Qe[ne].faceNormals[se], (ae = Pe[ne])[ye] = V.x, ae[ye + 1] = V.y, ae[ye + 2] = V.z, ae[ye + 3] = N.x, ae[ye + 4] = N.y, ae[ye + 5] = N.z, ae[ye + 6] = B.x, ae[ye + 7] = B.y, ae[ye + 8] = B.z), ye += 9;
                                        oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglMorphTargetsBuffers[ne]), oi.bufferData(oi.ARRAY_BUFFER, Ae[ne], E), y.morphNormals && (oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglMorphNormalsBuffers[ne]), oi.bufferData(oi.ARRAY_BUFFER, Pe[ne], E))
                                    }
                                if (Ye.length) {
                                    for (w = 0, _ = $e.length; w < _; w++) W = Ye[(H = Ge[$e[w]]).a], q = Ye[H.b], X = Ye[H.c], Ce[ve] = W.x, Ce[ve + 1] = W.y, Ce[ve + 2] = W.z, Ce[ve + 3] = W.w, Ce[ve + 4] = q.x, Ce[ve + 5] = q.y, Ce[ve + 6] = q.z, Ce[ve + 7] = q.w, Ce[ve + 8] = X.x, Ce[ve + 9] = X.y, Ce[ve + 10] = X.z, Ce[ve + 11] = X.w, Y = Xe[H.a], K = Xe[H.b], Q = Xe[H.c], Me[ve] = Y.x, Me[ve + 1] = Y.y, Me[ve + 2] = Y.z, Me[ve + 3] = Y.w, Me[ve + 4] = K.x, Me[ve + 5] = K.y, Me[ve + 6] = K.z, Me[ve + 7] = K.w, Me[ve + 8] = Q.x, Me[ve + 9] = Q.y, Me[ve + 10] = Q.z, Me[ve + 11] = Q.w, ve += 12;
                                    0 < ve && (oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglSkinIndicesBuffer), oi.bufferData(oi.ARRAY_BUFFER, Me, E), oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglSkinWeightsBuffer), oi.bufferData(oi.ARRAY_BUFFER, Ce, E))
                                }
                                if (Ne && b) {
                                    for (w = 0, _ = $e.length; w < _; w++) C = (H = Ge[$e[w]]).vertexColors, A = H.color, G = 3 === C.length && b === THREE.VertexColors ? (I = C[0], $ = C[1], C[2]) : $ = I = A, Se[Ee] = I.r, Se[Ee + 1] = I.g, Se[Ee + 2] = I.b, Se[Ee + 3] = $.r, Se[Ee + 4] = $.g, Se[Ee + 5] = $.b, Se[Ee + 6] = G.r, Se[Ee + 7] = G.g, Se[Ee + 8] = G.b, Ee += 9;
                                    0 < Ee && (oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglColorBuffer), oi.bufferData(oi.ARRAY_BUFFER, Se, E))
                                }
                                if (Ve && Oe.hasTangents) {
                                    for (w = 0, _ = $e.length; w < _; w++) F = (P = (H = Ge[$e[w]]).vertexTangents)[0], j = P[1], U = P[2], He[me] = F.x, He[me + 1] = F.y, He[me + 2] = F.z, He[me + 3] = F.w, He[me + 4] = j.x, He[me + 5] = j.y, He[me + 6] = j.z, He[me + 7] = j.w, He[me + 8] = U.x, He[me + 9] = U.y, He[me + 10] = U.z, He[me + 11] = U.w, me += 12;
                                    oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglTangentBuffer), oi.bufferData(oi.ARRAY_BUFFER, He, E)
                                }
                                if (Ue && T) {
                                    for (w = 0, _ = $e.length; w < _; w++)
                                        if (S = (H = Ge[$e[w]]).vertexNormals, M = H.normal, 3 === S.length && R)
                                            for (Z = 0; Z < 3; Z++) ee = S[Z], _e[pe] = ee.x, _e[pe + 1] = ee.y, _e[pe + 2] = ee.z, pe += 3;
                                        else
                                            for (Z = 0; Z < 3; Z++) _e[pe] = M.x, _e[pe + 1] = M.y, _e[pe + 2] = M.z, pe += 3;
                                    oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglNormalBuffer), oi.bufferData(oi.ARRAY_BUFFER, _e, E)
                                }
                                if (je && We && x) {
                                    for (w = 0, _ = $e.length; w < _; w++)
                                        if (void 0 !== (L = We[$e[w]]))
                                            for (Z = 0; Z < 3; Z++) te = L[Z], Re[ue] = te.x, Re[ue + 1] = te.y, ue += 2;
                                    0 < ue && (oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglUVBuffer), oi.bufferData(oi.ARRAY_BUFFER, Re, E))
                                }
                                if (je && qe && x) {
                                    for (w = 0, _ = $e.length; w < _; w++)
                                        if (void 0 !== (D = qe[$e[w]]))
                                            for (Z = 0; Z < 3; Z++) ie = D[Z], we[fe] = ie.x, we[fe + 1] = ie.y, fe += 2;
                                    0 < fe && (oi.bindBuffer(oi.ARRAY_BUFFER, m.__webglUV2Buffer), oi.bufferData(oi.ARRAY_BUFFER, we, E))
                                }
                                if (Fe) {
                                    for (w = 0, _ = $e.length; w < _; w++) ze[de] = ce, ze[de + 1] = ce + 1, ze[de + 2] = ce + 2, de += 3, ke[ge] = ce, ke[ge + 1] = ce + 1, ke[ge + 2] = ce, ke[ge + 3] = ce + 2, ke[ge + 4] = ce + 1, ke[ge + 5] = ce + 2, ge += 6, ce += 3;
                                    oi.bindBuffer(oi.ELEMENT_ARRAY_BUFFER, m.__webglFaceBuffer), oi.bufferData(oi.ELEMENT_ARRAY_BUFFER, ze, E), oi.bindBuffer(oi.ELEMENT_ARRAY_BUFFER, m.__webglLineBuffer), oi.bufferData(oi.ELEMENT_ARRAY_BUFFER, ke, E)
                                }
                                if (Le)
                                    for (Z = 0, J = Le.length; Z < J; Z++)
                                        if ((De = Le[Z]).__original.needsUpdate) {
                                            if (Te = 0, 1 === De.size) {
                                                if (void 0 === De.boundTo || "vertices" === De.boundTo)
                                                    for (w = 0, _ = $e.length; w < _; w++) H = Ge[$e[w]], De.array[Te] = De.value[H.a], De.array[Te + 1] = De.value[H.b], De.array[Te + 2] = De.value[H.c], Te += 3;
                                                else if ("faces" === De.boundTo)
                                                    for (w = 0, _ = $e.length; w < _; w++) be = De.value[$e[w]], De.array[Te] = be, De.array[Te + 1] = be, De.array[Te + 2] = be, Te += 3
                                            } else if (2 === De.size) {
                                                if (void 0 === De.boundTo || "vertices" === De.boundTo)
                                                    for (w = 0, _ = $e.length; w < _; w++) H = Ge[$e[w]], z = De.value[H.a], k = De.value[H.b], O = De.value[H.c], De.array[Te] = z.x, De.array[Te + 1] = z.y, De.array[Te + 2] = k.x, De.array[Te + 3] = k.y, De.array[Te + 4] = O.x, De.array[Te + 5] = O.y, Te += 6;
                                                else if ("faces" === De.boundTo)
                                                    for (w = 0, _ = $e.length; w < _; w++) O = k = z = be = De.value[$e[w]], De.array[Te] = z.x, De.array[Te + 1] = z.y, De.array[Te + 2] = k.x, De.array[Te + 3] = k.y, De.array[Te + 4] = O.x, De.array[Te + 5] = O.y, Te += 6
                                            } else if (3 === De.size) {
                                                var Ze;
                                                if (Ze = "c" === De.type ? ["r", "g", "b"] : ["x", "y", "z"], void 0 === De.boundTo || "vertices" === De.boundTo)
                                                    for (w = 0, _ = $e.length; w < _; w++) H = Ge[$e[w]], z = De.value[H.a], k = De.value[H.b], O = De.value[H.c], De.array[Te] = z[Ze[0]], De.array[Te + 1] = z[Ze[1]], De.array[Te + 2] = z[Ze[2]], De.array[Te + 3] = k[Ze[0]], De.array[Te + 4] = k[Ze[1]], De.array[Te + 5] = k[Ze[2]], De.array[Te + 6] = O[Ze[0]], De.array[Te + 7] = O[Ze[1]], De.array[Te + 8] = O[Ze[2]], Te += 9;
                                                else if ("faces" === De.boundTo)
                                                    for (w = 0, _ = $e.length; w < _; w++) O = k = z = be = De.value[$e[w]], De.array[Te] = z[Ze[0]], De.array[Te + 1] = z[Ze[1]], De.array[Te + 2] = z[Ze[2]], De.array[Te + 3] = k[Ze[0]], De.array[Te + 4] = k[Ze[1]], De.array[Te + 5] = k[Ze[2]], De.array[Te + 6] = O[Ze[0]], De.array[Te + 7] = O[Ze[1]], De.array[Te + 8] = O[Ze[2]], Te += 9;
                                                else if ("faceVertices" === De.boundTo)
                                                    for (w = 0, _ = $e.length; w < _; w++) z = (be = De.value[$e[w]])[0], k = be[1], O = be[2], De.array[Te] = z[Ze[0]], De.array[Te + 1] = z[Ze[1]], De.array[Te + 2] = z[Ze[2]], De.array[Te + 3] = k[Ze[0]], De.array[Te + 4] = k[Ze[1]], De.array[Te + 5] = k[Ze[2]], De.array[Te + 6] = O[Ze[0]], De.array[Te + 7] = O[Ze[1]], De.array[Te + 8] = O[Ze[2]], Te += 9
                                            } else if (4 === De.size)
                                                if (void 0 === De.boundTo || "vertices" === De.boundTo)
                                                    for (w = 0, _ = $e.length; w < _; w++) H = Ge[$e[w]], z = De.value[H.a], k = De.value[H.b], O = De.value[H.c], De.array[Te] = z.x, De.array[Te + 1] = z.y, De.array[Te + 2] = z.z, De.array[Te + 3] = z.w, De.array[Te + 4] = k.x, De.array[Te + 5] = k.y, De.array[Te + 6] = k.z, De.array[Te + 7] = k.w, De.array[Te + 8] = O.x, De.array[Te + 9] = O.y, De.array[Te + 10] = O.z, De.array[Te + 11] = O.w, Te += 12;
                                                else if ("faces" === De.boundTo)
                                                for (w = 0, _ = $e.length; w < _; w++) O = k = z = be = De.value[$e[w]], De.array[Te] = z.x, De.array[Te + 1] = z.y, De.array[Te + 2] = z.z, De.array[Te + 3] = z.w, De.array[Te + 4] = k.x, De.array[Te + 5] = k.y, De.array[Te + 6] = k.z, De.array[Te + 7] = k.w, De.array[Te + 8] = O.x, De.array[Te + 9] = O.y, De.array[Te + 10] = O.z, De.array[Te + 11] = O.w, Te += 12;
                                            else if ("faceVertices" === De.boundTo)
                                                for (w = 0, _ = $e.length; w < _; w++) z = (be = De.value[$e[w]])[0], k = be[1], O = be[2], De.array[Te] = z.x, De.array[Te + 1] = z.y, De.array[Te + 2] = z.z, De.array[Te + 3] = z.w, De.array[Te + 4] = k.x, De.array[Te + 5] = k.y, De.array[Te + 6] = k.z, De.array[Te + 7] = k.w, De.array[Te + 8] = O.x, De.array[Te + 9] = O.y, De.array[Te + 10] = O.z, De.array[Te + 11] = O.w, Te += 12;
                                            oi.bindBuffer(oi.ARRAY_BUFFER, De.buffer), oi.bufferData(oi.ARRAY_BUFFER, De.array, E)
                                        } v && (delete m.__inittedArrays, delete m.__colorArray, delete m.__normalArray, delete m.__tangentArray, delete m.__uvArray, delete m.__uv2Array, delete m.__faceArray, delete m.__vertexArray, delete m.__lineArray, delete m.__skinIndexArray, delete m.__skinWeightArray)
                            }
                        } o.verticesNeedUpdate = !1, o.morphTargetsNeedUpdate = !1, o.elementsNeedUpdate = !1, o.uvsNeedUpdate = !1, o.normalsNeedUpdate = !1, o.colorsNeedUpdate = !1, o.tangentsNeedUpdate = !1, o.buffersNeedUpdate = !1, l.attributes && ni(l)
                } else if (r instanceof THREE.Line) {
                    if (s = (l = Qt(r, o)).attributes && ii(l), o.verticesNeedUpdate || o.colorsNeedUpdate || o.lineDistancesNeedUpdate || s) {
                        var Je = o,
                            et = oi.DYNAMIC_DRAW,
                            tt = void 0,
                            it = void 0,
                            nt = void 0,
                            rt = void 0,
                            ot = void 0,
                            at = void 0,
                            st = Je.vertices,
                            lt = Je.colors,
                            ct = Je.lineDistances,
                            ht = st.length,
                            ut = lt.length,
                            ft = ct.length,
                            dt = Je.__vertexArray,
                            pt = Je.__colorArray,
                            mt = Je.__lineDistanceArray,
                            gt = Je.colorsNeedUpdate,
                            Et = Je.lineDistancesNeedUpdate,
                            vt = Je.__webglCustomAttributesList,
                            yt = void 0,
                            Tt = void 0,
                            bt = void 0,
                            xt = void 0,
                            Rt = void 0,
                            wt = void 0;
                        if (Je.verticesNeedUpdate) {
                            for (tt = 0; tt < ht; tt++) rt = st[tt], dt[ot = 3 * tt] = rt.x, dt[ot + 1] = rt.y, dt[ot + 2] = rt.z;
                            oi.bindBuffer(oi.ARRAY_BUFFER, Je.__webglVertexBuffer), oi.bufferData(oi.ARRAY_BUFFER, dt, et)
                        }
                        if (gt) {
                            for (it = 0; it < ut; it++) at = lt[it], pt[ot = 3 * it] = at.r, pt[ot + 1] = at.g, pt[ot + 2] = at.b;
                            oi.bindBuffer(oi.ARRAY_BUFFER, Je.__webglColorBuffer), oi.bufferData(oi.ARRAY_BUFFER, pt, et)
                        }
                        if (Et) {
                            for (nt = 0; nt < ft; nt++) mt[nt] = ct[nt];
                            oi.bindBuffer(oi.ARRAY_BUFFER, Je.__webglLineDistanceBuffer), oi.bufferData(oi.ARRAY_BUFFER, mt, et)
                        }
                        if (vt)
                            for (yt = 0, Tt = vt.length; yt < Tt; yt++)
                                if ((wt = vt[yt]).needsUpdate && (void 0 === wt.boundTo || "vertices" === wt.boundTo)) {
                                    if (ot = 0, xt = wt.value.length, 1 === wt.size)
                                        for (bt = 0; bt < xt; bt++) wt.array[bt] = wt.value[bt];
                                    else if (2 === wt.size)
                                        for (bt = 0; bt < xt; bt++) Rt = wt.value[bt], wt.array[ot] = Rt.x, wt.array[ot + 1] = Rt.y, ot += 2;
                                    else if (3 === wt.size)
                                        if ("c" === wt.type)
                                            for (bt = 0; bt < xt; bt++) Rt = wt.value[bt], wt.array[ot] = Rt.r, wt.array[ot + 1] = Rt.g, wt.array[ot + 2] = Rt.b, ot += 3;
                                        else
                                            for (bt = 0; bt < xt; bt++) Rt = wt.value[bt], wt.array[ot] = Rt.x, wt.array[ot + 1] = Rt.y, wt.array[ot + 2] = Rt.z, ot += 3;
                                    else if (4 === wt.size)
                                        for (bt = 0; bt < xt; bt++) Rt = wt.value[bt], wt.array[ot] = Rt.x, wt.array[ot + 1] = Rt.y, wt.array[ot + 2] = Rt.z, wt.array[ot + 3] = Rt.w, ot += 4;
                                    oi.bindBuffer(oi.ARRAY_BUFFER, wt.buffer), oi.bufferData(oi.ARRAY_BUFFER, wt.array, et)
                                }
                    }
                    o.verticesNeedUpdate = !1, o.colorsNeedUpdate = !1, o.lineDistancesNeedUpdate = !1, l.attributes && ni(l)
                } else if (r instanceof THREE.ParticleSystem) {
                    if (s = (l = Qt(r, o)).attributes && ii(l), o.verticesNeedUpdate || o.colorsNeedUpdate || r.sortParticles || s) {
                        var _t = o,
                            Ht = oi.DYNAMIC_DRAW,
                            St = r,
                            Mt = void 0,
                            Ct = void 0,
                            At = void 0,
                            Pt = void 0,
                            Lt = void 0,
                            Dt = void 0,
                            zt = _t.vertices,
                            kt = zt.length,
                            Ot = _t.colors,
                            Ft = Ot.length,
                            jt = _t.__vertexArray,
                            Ut = _t.__colorArray,
                            Vt = _t.__sortArray,
                            Nt = _t.verticesNeedUpdate,
                            Bt = _t.colorsNeedUpdate,
                            It = _t.__webglCustomAttributesList,
                            $t = void 0,
                            Gt = void 0,
                            Wt = void 0,
                            qt = void 0,
                            Xt = void 0,
                            Yt = void 0;
                        if (St.sortParticles) {
                            for (si.copy(ai), si.multiply(St.matrixWorld), Mt = 0; Mt < kt; Mt++) At = zt[Mt], li.copy(At), li.applyProjection(si), Vt[Mt] = [li.z, Mt];
                            for (Vt.sort(ei), Mt = 0; Mt < kt; Mt++) At = zt[Vt[Mt][1]], jt[Pt = 3 * Mt] = At.x, jt[Pt + 1] = At.y, jt[Pt + 2] = At.z;
                            for (Ct = 0; Ct < Ft; Ct++) Pt = 3 * Ct, Dt = Ot[Vt[Ct][1]], Ut[Pt] = Dt.r, Ut[Pt + 1] = Dt.g, Ut[Pt + 2] = Dt.b;
                            if (It)
                                for ($t = 0, Gt = It.length; $t < Gt; $t++)
                                    if (void 0 === (Yt = It[$t]).boundTo || "vertices" === Yt.boundTo)
                                        if (Pt = 0, qt = Yt.value.length, 1 === Yt.size)
                                            for (Wt = 0; Wt < qt; Wt++) Lt = Vt[Wt][1], Yt.array[Wt] = Yt.value[Lt];
                                        else if (2 === Yt.size)
                                for (Wt = 0; Wt < qt; Wt++) Lt = Vt[Wt][1], Xt = Yt.value[Lt], Yt.array[Pt] = Xt.x, Yt.array[Pt + 1] = Xt.y, Pt += 2;
                            else if (3 === Yt.size)
                                if ("c" === Yt.type)
                                    for (Wt = 0; Wt < qt; Wt++) Lt = Vt[Wt][1], Xt = Yt.value[Lt], Yt.array[Pt] = Xt.r, Yt.array[Pt + 1] = Xt.g, Yt.array[Pt + 2] = Xt.b, Pt += 3;
                                else
                                    for (Wt = 0; Wt < qt; Wt++) Lt = Vt[Wt][1], Xt = Yt.value[Lt], Yt.array[Pt] = Xt.x, Yt.array[Pt + 1] = Xt.y, Yt.array[Pt + 2] = Xt.z, Pt += 3;
                            else if (4 === Yt.size)
                                for (Wt = 0; Wt < qt; Wt++) Lt = Vt[Wt][1], Xt = Yt.value[Lt], Yt.array[Pt] = Xt.x, Yt.array[Pt + 1] = Xt.y, Yt.array[Pt + 2] = Xt.z, Yt.array[Pt + 3] = Xt.w, Pt += 4
                        } else {
                            if (Nt)
                                for (Mt = 0; Mt < kt; Mt++) At = zt[Mt], jt[Pt = 3 * Mt] = At.x, jt[Pt + 1] = At.y, jt[Pt + 2] = At.z;
                            if (Bt)
                                for (Ct = 0; Ct < Ft; Ct++) Dt = Ot[Ct], Ut[Pt = 3 * Ct] = Dt.r, Ut[Pt + 1] = Dt.g, Ut[Pt + 2] = Dt.b;
                            if (It)
                                for ($t = 0, Gt = It.length; $t < Gt; $t++)
                                    if ((Yt = It[$t]).needsUpdate && (void 0 === Yt.boundTo || "vertices" === Yt.boundTo))
                                        if (qt = Yt.value.length, Pt = 0, 1 === Yt.size)
                                            for (Wt = 0; Wt < qt; Wt++) Yt.array[Wt] = Yt.value[Wt];
                                        else if (2 === Yt.size)
                                for (Wt = 0; Wt < qt; Wt++) Xt = Yt.value[Wt], Yt.array[Pt] = Xt.x, Yt.array[Pt + 1] = Xt.y, Pt += 2;
                            else if (3 === Yt.size)
                                if ("c" === Yt.type)
                                    for (Wt = 0; Wt < qt; Wt++) Xt = Yt.value[Wt], Yt.array[Pt] = Xt.r, Yt.array[Pt + 1] = Xt.g, Yt.array[Pt + 2] = Xt.b, Pt += 3;
                                else
                                    for (Wt = 0; Wt < qt; Wt++) Xt = Yt.value[Wt], Yt.array[Pt] = Xt.x, Yt.array[Pt + 1] = Xt.y, Yt.array[Pt + 2] = Xt.z, Pt += 3;
                            else if (4 === Yt.size)
                                for (Wt = 0; Wt < qt; Wt++) Xt = Yt.value[Wt], Yt.array[Pt] = Xt.x, Yt.array[Pt + 1] = Xt.y, Yt.array[Pt + 2] = Xt.z, Yt.array[Pt + 3] = Xt.w, Pt += 4
                        }
                        if ((Nt || St.sortParticles) && (oi.bindBuffer(oi.ARRAY_BUFFER, _t.__webglVertexBuffer), oi.bufferData(oi.ARRAY_BUFFER, jt, Ht)), (Bt || St.sortParticles) && (oi.bindBuffer(oi.ARRAY_BUFFER, _t.__webglColorBuffer), oi.bufferData(oi.ARRAY_BUFFER, Ut, Ht)), It)
                            for ($t = 0, Gt = It.length; $t < Gt; $t++)((Yt = It[$t]).needsUpdate || St.sortParticles) && (oi.bindBuffer(oi.ARRAY_BUFFER, Yt.buffer), oi.bufferData(oi.ARRAY_BUFFER, Yt.array, Ht))
                    }
                    o.verticesNeedUpdate = !1, o.colorsNeedUpdate = !1, l.attributes && ni(l)
                }
            }
        }, this.initMaterial = function (e, t, i, n) {
            var r, o, a, s, l, c, h, u, f;
            if (e.addEventListener("dispose", Ae), e instanceof THREE.MeshDepthMaterial ? f = "depth" : e instanceof THREE.MeshNormalMaterial ? f = "normal" : e instanceof THREE.MeshBasicMaterial ? f = "basic" : e instanceof THREE.MeshLambertMaterial ? f = "lambert" : e instanceof THREE.MeshPhongMaterial ? f = "phong" : e instanceof THREE.LineBasicMaterial ? f = "basic" : e instanceof THREE.LineDashedMaterial ? f = "dashed" : e instanceof THREE.ParticleSystemMaterial && (f = "particle_basic"), f) {
                var d = THREE.ShaderLib[f];
                e.uniforms = THREE.UniformsUtils.clone(d.uniforms), e.vertexShader = d.vertexShader, e.fragmentShader = d.fragmentShader
            }
            var p = r = 0,
                m = 0,
                g = d = 0;
            for (o = t.length; g < o; g++)(a = t[g]).onlyShadow || !1 === a.visible || (a instanceof THREE.DirectionalLight && r++, a instanceof THREE.PointLight && p++, a instanceof THREE.SpotLight && m++, a instanceof THREE.HemisphereLight && d++);
            for (o = p, a = m, s = d, m = d = 0, p = t.length; m < p; m++)(g = t[m]).castShadow && (g instanceof THREE.SpotLight && d++, g instanceof THREE.DirectionalLight && !g.shadowCascade && d++);
            u = d, h = Te && n && n.useVertexTexture ? 1024 : (t = oi.getParameter(oi.MAX_VERTEX_UNIFORM_VECTORS), t = Math.floor((t - 20) / 4), void 0 !== n && n instanceof THREE.SkinnedMesh && ((t = Math.min(n.bones.length, t)) < n.bones.length && console.warn("WebGLRenderer: too many bones - " + n.bones.length + ", this GPU supports just " + t + " (try OpenGL instead of ANGLE)")), t);
            e: {
                var E, v, y, T;
                for (v in m = e.fragmentShader, p = e.vertexShader, d = e.uniforms, t = e.attributes, g = e.defines, i = {
                        map: !!e.map,
                        envMap: !!e.envMap,
                        lightMap: !!e.lightMap,
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        specularMap: !!e.specularMap,
                        vertexColors: e.vertexColors,
                        fog: i,
                        useFog: e.fog,
                        fogExp: i instanceof THREE.FogExp2,
                        sizeAttenuation: e.sizeAttenuation,
                        skinning: e.skinning,
                        maxBones: h,
                        useVertexTexture: Te && n && n.useVertexTexture,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: this.maxMorphTargets,
                        maxMorphNormals: this.maxMorphNormals,
                        maxDirLights: r,
                        maxPointLights: o,
                        maxSpotLights: a,
                        maxHemiLights: s,
                        maxShadows: u,
                        shadowMapEnabled: this.shadowMapEnabled && n.receiveShadow && 0 < u,
                        shadowMapType: this.shadowMapType,
                        shadowMapDebug: this.shadowMapDebug,
                        shadowMapCascade: this.shadowMapCascade,
                        alphaTest: e.alphaTest,
                        metal: e.metal,
                        wrapAround: e.wrapAround,
                        doubleSided: e.side === THREE.DoubleSide,
                        flipSided: e.side === THREE.BackSide
                    }, n = e.index0AttributeName, r = [], f ? r.push(f) : (r.push(m), r.push(p)), g) r.push(v),
                r.push(g[v]);
                for (E in i) r.push(E),
                r.push(i[E]);
                for (f = r.join(), E = 0, v = P.length; E < v; E++)
                    if ((r = P[E]).code === f) {
                        r.usedTimes++, c = r.program;
                        break e
                    } for (y in E = "SHADOWMAP_TYPE_BASIC", i.shadowMapType === THREE.PCFShadowMap ? E = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === THREE.PCFSoftShadowMap && (E = "SHADOWMAP_TYPE_PCF_SOFT"), v = [], g) !1 !== (r = g[y]) && (r = "#define " + y + " " + r, v.push(r));
                for (T in r = v.join("\n"), y = oi.createProgram(), v = ["precision " + w + " float;", "precision " + w + " int;", r, ye ? "#define VERTEX_TEXTURES" : "", q.gammaInput ? "#define GAMMA_INPUT" : "", q.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define MAX_DIR_LIGHTS " + i.maxDirLights, "#define MAX_POINT_LIGHTS " + i.maxPointLights, "#define MAX_SPOT_LIGHTS " + i.maxSpotLights, "#define MAX_HEMI_LIGHTS " + i.maxHemiLights, "#define MAX_SHADOWS " + i.maxShadows, "#define MAX_BONES " + i.maxBones, i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals ? "#define USE_MORPHNORMALS" : "", i.wrapAround ? "#define WRAP_AROUND" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + E : "", i.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", i.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n"].join("\n"), E = ["precision " + w + " float;", "precision " + w + " int;", i.bumpMap || i.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", r, "#define MAX_DIR_LIGHTS " + i.maxDirLights, "#define MAX_POINT_LIGHTS " + i.maxPointLights, "#define MAX_SPOT_LIGHTS " + i.maxSpotLights, "#define MAX_HEMI_LIGHTS " + i.maxHemiLights, "#define MAX_SHADOWS " + i.maxShadows, i.alphaTest ? "#define ALPHATEST " + i.alphaTest : "", q.gammaInput ? "#define GAMMA_INPUT" : "", q.gammaOutput ? "#define GAMMA_OUTPUT" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.metal ? "#define METAL" : "", i.wrapAround ? "#define WRAP_AROUND" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + E : "", i.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", i.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n"), v = R("vertex", v + p), E = R("fragment", E + m), oi.attachShader(y, v), oi.attachShader(y, E), void 0 !== n && oi.bindAttribLocation(y, 0, n), oi.linkProgram(y), !1 === oi.getProgramParameter(y, oi.LINK_STATUS) && (console.error("Could not initialise shader"), console.error("gl.VALIDATE_STATUS", oi.getProgramParameter(y, oi.VALIDATE_STATUS)), console.error("gl.getError()", oi.getError())), "" !== oi.getProgramInfoLog(y) && console.error("gl.getProgramInfoLog()", oi.getProgramInfoLog(y)), oi.deleteShader(E), oi.deleteShader(v), y.uniforms = {}, y.attributes = {}, E = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences".split(" "), i.useVertexTexture ? (E.push("boneTexture"), E.push("boneTextureWidth"), E.push("boneTextureHeight")) : E.push("boneGlobalMatrices"), d) E.push(T);
                for (T = E, E = 0, v = T.length; E < v; E++) d = T[E],
                y.uniforms[d] = oi.getUniformLocation(y, d);
                for (E = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" "), T = 0; T < i.maxMorphTargets; T++) E.push("morphTarget" + T);
                for (T = 0; T < i.maxMorphNormals; T++) E.push("morphNormal" + T);
                for (c in t) E.push(c);
                for (T = 0, t = (c = E).length; T < t; T++) E = c[T],
                y.attributes[E] = oi.getAttribLocation(y, E);y.id = L++,
                P.push({
                    program: y,
                    code: f,
                    usedTimes: 1
                }),
                q.info.memory.programs = P.length,
                c = y
            }
            if (e.program = c, T = e.program.attributes, e.morphTargets)
                for (t = "morphTarget", c = e.numSupportedMorphTargets = 0; c < this.maxMorphTargets; c++) 0 <= T[y = t + c] && e.numSupportedMorphTargets++;
            if (e.morphNormals)
                for (t = "morphNormal", c = e.numSupportedMorphNormals = 0; c < this.maxMorphNormals; c++) 0 <= T[y = t + c] && e.numSupportedMorphNormals++;
            for (l in e.uniformsList = [], e.uniforms) e.uniformsList.push([e.uniforms[l], l])
        }, this.setFaceCulling = function (e, t) {
            e === THREE.CullFaceNone ? oi.disable(oi.CULL_FACE) : (t === THREE.FrontFaceDirectionCW ? oi.frontFace(oi.CW) : oi.frontFace(oi.CCW), e === THREE.CullFaceBack ? oi.cullFace(oi.BACK) : e === THREE.CullFaceFront ? oi.cullFace(oi.FRONT) : oi.cullFace(oi.FRONT_AND_BACK), oi.enable(oi.CULL_FACE))
        }, this.setMaterialFaces = function (e) {
            var t = e.side === THREE.DoubleSide;
            e = e.side === THREE.BackSide, k !== t && (t ? oi.disable(oi.CULL_FACE) : oi.enable(oi.CULL_FACE), k = t), O !== e && (e ? oi.frontFace(oi.CW) : oi.frontFace(oi.CCW), O = e)
        }, this.setDepthTest = function (e) {
            Z !== e && (e ? oi.enable(oi.DEPTH_TEST) : oi.disable(oi.DEPTH_TEST), Z = e)
        }, this.setDepthWrite = function (e) {
            J !== e && (oi.depthMask(e), J = e)
        }, this.setBlending = function (e, t, i, n) {
            e !== F && (e === THREE.NoBlending ? oi.disable(oi.BLEND) : e === THREE.AdditiveBlending ? (oi.enable(oi.BLEND), oi.blendEquation(oi.FUNC_ADD), oi.blendFunc(oi.SRC_ALPHA, oi.ONE)) : e === THREE.SubtractiveBlending ? (oi.enable(oi.BLEND), oi.blendEquation(oi.FUNC_ADD), oi.blendFunc(oi.ZERO, oi.ONE_MINUS_SRC_COLOR)) : e === THREE.MultiplyBlending ? (oi.enable(oi.BLEND), oi.blendEquation(oi.FUNC_ADD), oi.blendFunc(oi.ZERO, oi.SRC_COLOR)) : e === THREE.CustomBlending ? oi.enable(oi.BLEND) : (oi.enable(oi.BLEND), oi.blendEquationSeparate(oi.FUNC_ADD, oi.FUNC_ADD), oi.blendFuncSeparate(oi.SRC_ALPHA, oi.ONE_MINUS_SRC_ALPHA, oi.ONE, oi.ONE_MINUS_SRC_ALPHA)), F = e), e === THREE.CustomBlending ? (t !== j && (oi.blendEquation(G(t)), j = t), (i !== U || n !== V) && (oi.blendFunc(G(i), G(n)), U = i, V = n)) : V = U = j = null
        }, this.setTexture = function (e, t) {
            if (e.needsUpdate) {
                e.__webglInit || (e.__webglInit = !0, e.addEventListener("dispose", Me), e.__webglTexture = oi.createTexture(), q.info.memory.textures++), oi.activeTexture(oi.TEXTURE0 + t), oi.bindTexture(oi.TEXTURE_2D, e.__webglTexture), oi.pixelStorei(oi.UNPACK_FLIP_Y_WEBGL, e.flipY), oi.pixelStorei(oi.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), oi.pixelStorei(oi.UNPACK_ALIGNMENT, e.unpackAlignment);
                var i = e.image,
                    n = THREE.Math.isPowerOfTwo(i.width) && THREE.Math.isPowerOfTwo(i.height),
                    r = G(e.format),
                    o = G(e.type);
                $(oi.TEXTURE_2D, e, n);
                var a = e.mipmaps;
                if (e instanceof THREE.DataTexture)
                    if (0 < a.length && n) {
                        for (var s = 0, l = a.length; s < l; s++) i = a[s], oi.texImage2D(oi.TEXTURE_2D, s, r, i.width, i.height, 0, r, o, i.data);
                        e.generateMipmaps = !1
                    } else oi.texImage2D(oi.TEXTURE_2D, 0, r, i.width, i.height, 0, r, o, i.data);
                else if (e instanceof THREE.CompressedTexture)
                    for (s = 0, l = a.length; s < l; s++) i = a[s], e.format !== THREE.RGBAFormat ? oi.compressedTexImage2D(oi.TEXTURE_2D, s, r, i.width, i.height, 0, i.data) : oi.texImage2D(oi.TEXTURE_2D, s, r, i.width, i.height, 0, r, o, i.data);
                else if (0 < a.length && n) {
                    for (s = 0, l = a.length; s < l; s++) i = a[s], oi.texImage2D(oi.TEXTURE_2D, s, r, r, o, i);
                    e.generateMipmaps = !1
                } else oi.texImage2D(oi.TEXTURE_2D, 0, r, r, o, e.image);
                e.generateMipmaps && n && oi.generateMipmap(oi.TEXTURE_2D), e.needsUpdate = !1, e.onUpdate && e.onUpdate()
            } else oi.activeTexture(oi.TEXTURE0 + t), oi.bindTexture(oi.TEXTURE_2D, e.__webglTexture)
        }, this.setRenderTarget = function (e) {
            var t = e instanceof THREE.WebGLRenderTargetCube;
            if (e && !e.__webglFramebuffer) {
                void 0 === e.depthBuffer && (e.depthBuffer = !0), void 0 === e.stencilBuffer && (e.stencilBuffer = !0), e.addEventListener("dispose", Ce), e.__webglTexture = oi.createTexture(), q.info.memory.textures++;
                var i = THREE.Math.isPowerOfTwo(e.width) && THREE.Math.isPowerOfTwo(e.height),
                    n = G(e.format),
                    r = G(e.type);
                if (t) {
                    e.__webglFramebuffer = [], e.__webglRenderbuffer = [], oi.bindTexture(oi.TEXTURE_CUBE_MAP, e.__webglTexture), $(oi.TEXTURE_CUBE_MAP, e, i);
                    for (var o = 0; o < 6; o++) {
                        e.__webglFramebuffer[o] = oi.createFramebuffer(), e.__webglRenderbuffer[o] = oi.createRenderbuffer(), oi.texImage2D(oi.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, n, e.width, e.height, 0, n, r, null);
                        var a = e,
                            s = oi.TEXTURE_CUBE_MAP_POSITIVE_X + o;
                        oi.bindFramebuffer(oi.FRAMEBUFFER, e.__webglFramebuffer[o]), oi.framebufferTexture2D(oi.FRAMEBUFFER, oi.COLOR_ATTACHMENT0, s, a.__webglTexture, 0), h(e.__webglRenderbuffer[o], e)
                    }
                    i && oi.generateMipmap(oi.TEXTURE_CUBE_MAP)
                } else e.__webglFramebuffer = oi.createFramebuffer(), e.__webglRenderbuffer = e.shareDepthFrom ? e.shareDepthFrom.__webglRenderbuffer : oi.createRenderbuffer(), oi.bindTexture(oi.TEXTURE_2D, e.__webglTexture), $(oi.TEXTURE_2D, e, i), oi.texImage2D(oi.TEXTURE_2D, 0, n, e.width, e.height, 0, n, r, null), n = oi.TEXTURE_2D, oi.bindFramebuffer(oi.FRAMEBUFFER, e.__webglFramebuffer), oi.framebufferTexture2D(oi.FRAMEBUFFER, oi.COLOR_ATTACHMENT0, n, e.__webglTexture, 0), e.shareDepthFrom ? e.depthBuffer && !e.stencilBuffer ? oi.framebufferRenderbuffer(oi.FRAMEBUFFER, oi.DEPTH_ATTACHMENT, oi.RENDERBUFFER, e.__webglRenderbuffer) : e.depthBuffer && e.stencilBuffer && oi.framebufferRenderbuffer(oi.FRAMEBUFFER, oi.DEPTH_STENCIL_ATTACHMENT, oi.RENDERBUFFER, e.__webglRenderbuffer) : h(e.__webglRenderbuffer, e), i && oi.generateMipmap(oi.TEXTURE_2D);
                t ? oi.bindTexture(oi.TEXTURE_CUBE_MAP, null) : oi.bindTexture(oi.TEXTURE_2D, null), oi.bindRenderbuffer(oi.RENDERBUFFER, null), oi.bindFramebuffer(oi.FRAMEBUFFER, null)
            }
            r = e ? (t = t ? e.__webglFramebuffer[e.activeCubeFace] : e.__webglFramebuffer, i = e.width, e = e.height, n = 0) : (t = null, i = ae, e = se, n = re, oe), t !== D && (oi.bindFramebuffer(oi.FRAMEBUFFER, t), oi.viewport(n, r, i, e), D = t), le = i, ce = e
        }, this.shadowMapPlugin = new THREE.ShadowMapPlugin, this.addPrePlugin(this.shadowMapPlugin), this.addPostPlugin(new THREE.SpritePlugin), this.addPostPlugin(new THREE.LensFlarePlugin)
    }, THREE.WebGLRenderTarget = function (e, t, i) {
        this.width = e, this.height = t, i = i || {}, this.wrapS = void 0 !== i.wrapS ? i.wrapS : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== i.wrapT ? i.wrapT : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== i.magFilter ? i.magFilter : THREE.LinearFilter, this.minFilter = void 0 !== i.minFilter ? i.minFilter : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.format = void 0 !== i.format ? i.format : THREE.RGBAFormat, this.type = void 0 !== i.type ? i.type : THREE.UnsignedByteType, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.generateMipmaps = !0, this.shareDepthFrom = null
    }, THREE.WebGLRenderTarget.prototype = {
        constructor: THREE.WebGLRenderTarget,
        clone: function () {
            var e = new THREE.WebGLRenderTarget(this.width, this.height);
            return e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.format = this.format, e.type = this.type, e.depthBuffer = this.depthBuffer, e.stencilBuffer = this.stencilBuffer, e.generateMipmaps = this.generateMipmaps, e.shareDepthFrom = this.shareDepthFrom, e
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function (e, t, i) {
        THREE.WebGLRenderTarget.call(this, e, t, i), this.activeCubeFace = 0
    }, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), THREE.RenderableVertex = function () {
        this.position = new THREE.Vector3, this.positionWorld = new THREE.Vector3, this.positionScreen = new THREE.Vector4, this.visible = !0
    }, THREE.RenderableVertex.prototype.copy = function (e) {
        this.positionWorld.copy(e.positionWorld), this.positionScreen.copy(e.positionScreen)
    }, THREE.RenderableFace = function () {
        this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.v3 = new THREE.RenderableVertex, this.centroidModel = new THREE.Vector3, this.normalModel = new THREE.Vector3, this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], this.vertexNormalsLength = 0, this.material = this.color = null, this.uvs = [
            []
        ], this.z = 0
    }, THREE.RenderableObject = function () {
        this.id = 0, this.object = null, this.z = 0
    }, THREE.RenderableSprite = function () {
        this.id = 0, this.object = null, this.rotation = this.z = this.y = this.x = 0, this.scale = new THREE.Vector2, this.material = null
    }, THREE.RenderableLine = function () {
        this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.vertexColors = [new THREE.Color, new THREE.Color], this.material = null, this.z = 0
    }, THREE.GeometryUtils = {
        merge: function (e, t, i) {
            var n, r, o = e.vertices.length,
                a = t instanceof THREE.Mesh ? t.geometry : t,
                s = e.vertices,
                l = a.vertices,
                c = e.faces,
                h = a.faces;
            e = e.faceVertexUvs[0], a = a.faceVertexUvs[0], void 0 === i && (i = 0), t instanceof THREE.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), n = t.matrix, r = (new THREE.Matrix3).getNormalMatrix(n)), t = 0;
            for (var u = l.length; t < u; t++) {
                var f = l[t].clone();
                n && f.applyMatrix4(n), s.push(f)
            }
            for (t = 0, u = h.length; t < u; t++) {
                var d, p, m = (f = h[t]).vertexNormals,
                    g = f.vertexColors;
                for ((d = new THREE.Face3(f.a + o, f.b + o, f.c + o)).normal.copy(f.normal), r && d.normal.applyMatrix3(r).normalize(), s = 0, l = m.length; s < l; s++) p = m[s].clone(), r && p.applyMatrix3(r).normalize(), d.vertexNormals.push(p);
                for (d.color.copy(f.color), s = 0, l = g.length; s < l; s++) p = g[s], d.vertexColors.push(p.clone());
                d.materialIndex = f.materialIndex + i, d.centroid.copy(f.centroid), n && d.centroid.applyMatrix4(n), c.push(d)
            }
            for (t = 0, u = a.length; t < u; t++) {
                for (n = [], s = 0, l = (i = a[t]).length; s < l; s++) n.push(new THREE.Vector2(i[s].x, i[s].y));
                e.push(n)
            }
        },
        randomPointInTriangle: function () {
            var s = new THREE.Vector3;
            return function (e, t, i) {
                var n = new THREE.Vector3,
                    r = THREE.Math.random16(),
                    o = THREE.Math.random16();
                1 < r + o && (r = 1 - r, o = 1 - o);
                var a = 1 - r - o;
                return n.copy(e), n.multiplyScalar(r), s.copy(t), s.multiplyScalar(o), n.add(s), s.copy(i), s.multiplyScalar(a), n.add(s), n
            }
        }(),
        randomPointInFace: function (e, t, i) {
            return THREE.GeometryUtils.randomPointInTriangle(t.vertices[e.a], t.vertices[e.b], t.vertices[e.c])
        },
        randomPointsInGeometry: function (e, t) {
            var i, n, r, o, a, s, l = e.faces,
                c = e.vertices,
                h = l.length,
                u = 0,
                f = [];
            for (n = 0; n < h; n++) r = c[(i = l[n]).a], o = c[i.b], a = c[i.c], i._area = THREE.GeometryUtils.triangleArea(r, o, a), u += i._area, f[n] = u;
            for (i = [], n = 0; n < t; n++) c = THREE.Math.random16() * u, s = c, c = function e(t, i) {
                if (i < t) return t;
                var n = t + Math.floor((i - t) / 2);
                return f[n] > s ? e(t, n - 1) : f[n] < s ? e(n + 1, i) : n
            }(0, f.length - 1), i[n] = THREE.GeometryUtils.randomPointInFace(l[c], e, !0);
            return i
        },
        triangleArea: function () {
            var n = new THREE.Vector3,
                r = new THREE.Vector3;
            return function (e, t, i) {
                return n.subVectors(t, e), r.subVectors(i, e), n.cross(r), .5 * n.length()
            }
        }(),
        center: function (e) {
            e.computeBoundingBox();
            var t = e.boundingBox,
                i = new THREE.Vector3;
            return i.addVectors(t.min, t.max), i.multiplyScalar(-.5), e.applyMatrix((new THREE.Matrix4).makeTranslation(i.x, i.y, i.z)), e.computeBoundingBox(), i
        },
        triangulateQuads: function (e) {
            var t, i, n, r, o = [],
                a = [];
            for (t = 0, i = e.faceVertexUvs.length; t < i; t++) a[t] = [];
            for (t = 0, i = e.faces.length; t < i; t++)
                for (o.push(e.faces[t]), n = 0, r = e.faceVertexUvs.length; n < r; n++) a[n].push(e.faceVertexUvs[n][t]);
            e.faces = o, e.faceVertexUvs = a, e.computeCentroids(), e.computeFaceNormals(), e.computeVertexNormals(), e.hasTangents && e.computeTangents()
        }
    }, THREE.ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function (e, t, i, n) {
            (n = new THREE.ImageLoader).crossOrigin = this.crossOrigin;
            var r = new THREE.Texture(void 0, t);
            return t = n.load(e, function () {
                r.needsUpdate = !0, i && i(r)
            }), r.image = t, r.sourceFile = e, r
        },
        loadCompressedTexture: function (e, t, i, n) {
            var r = new THREE.CompressedTexture;
            r.mapping = t;
            var o = new XMLHttpRequest;
            return o.onload = function () {
                var e = THREE.ImageUtils.parseDDS(o.response, !0);
                r.format = e.format, r.mipmaps = e.mipmaps, r.image.width = e.width, r.image.height = e.height, r.generateMipmaps = !1, r.needsUpdate = !0, i && i(r)
            }, o.onerror = n, o.open("GET", e, !0), o.responseType = "arraybuffer", o.send(null), r
        },
        loadTextureCube: function (e, t, i, n) {
            var r = [];
            r.loadCount = 0;
            var o = new THREE.Texture;
            o.image = r, void 0 !== t && (o.mapping = t), o.flipY = !1, t = 0;
            for (var a = e.length; t < a; ++t) {
                var s = new Image;
                (r[t] = s).onload = function () {
                    r.loadCount += 1, 6 === r.loadCount && (o.needsUpdate = !0, i && i(o))
                }, s.onerror = n, s.crossOrigin = this.crossOrigin, s.src = e[t]
            }
            return o
        },
        loadCompressedTextureCube: function (e, t, r, i) {
            var o = [];
            o.loadCount = 0;
            var a = new THREE.CompressedTexture;
            if (a.image = o, void 0 !== t && (a.mapping = t), a.flipY = !1, a.generateMipmaps = !1, t = function (t, i) {
                    return function () {
                        var e = THREE.ImageUtils.parseDDS(t.response, !0);
                        i.format = e.format, i.mipmaps = e.mipmaps, i.width = e.width, i.height = e.height, o.loadCount += 1, 6 === o.loadCount && (a.format = e.format, a.needsUpdate = !0, r && r(a))
                    }
                }, e instanceof Array)
                for (var n = 0, s = e.length; n < s; ++n) {
                    var l = {};
                    o[n] = l;
                    var c = new XMLHttpRequest;
                    c.onload = t(c, l), c.onerror = i, l = e[n], c.open("GET", l, !0), c.responseType = "arraybuffer", c.send(null)
                } else(c = new XMLHttpRequest).onload = function () {
                    var e = THREE.ImageUtils.parseDDS(c.response, !0);
                    if (e.isCubemap) {
                        for (var t = e.mipmaps.length / e.mipmapCount, i = 0; i < t; i++) {
                            o[i] = {
                                mipmaps: []
                            };
                            for (var n = 0; n < e.mipmapCount; n++) o[i].mipmaps.push(e.mipmaps[i * e.mipmapCount + n]), o[i].format = e.format, o[i].width = e.width, o[i].height = e.height
                        }
                        a.format = e.format, a.needsUpdate = !0, r && r(a)
                    }
                }, c.onerror = i, c.open("GET", e, !0), c.responseType = "arraybuffer", c.send(null);
            return a
        },
        loadDDSTexture: function (e, t, r, i) {
            var o = [];
            o.loadCount = 0;
            var a = new THREE.CompressedTexture;
            a.image = o, void 0 !== t && (a.mapping = t), a.flipY = !1, a.generateMipmaps = !1;
            var s = new XMLHttpRequest;
            return s.onload = function () {
                var e = THREE.ImageUtils.parseDDS(s.response, !0);
                if (e.isCubemap)
                    for (var t = e.mipmaps.length / e.mipmapCount, i = 0; i < t; i++) {
                        o[i] = {
                            mipmaps: []
                        };
                        for (var n = 0; n < e.mipmapCount; n++) o[i].mipmaps.push(e.mipmaps[i * e.mipmapCount + n]), o[i].format = e.format, o[i].width = e.width, o[i].height = e.height
                    } else a.image.width = e.width, a.image.height = e.height, a.mipmaps = e.mipmaps;
                a.format = e.format, a.needsUpdate = !0, r && r(a)
            }, s.onerror = i, s.open("GET", e, !0), s.responseType = "arraybuffer", s.send(null), a
        },
        parseDDS: function (e, t) {
            function i(e) {
                return e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24)
            }

            function n(e, t, i, n) {
                var r = i * n * 4;
                e = new Uint8Array(e, t, r);
                r = new Uint8Array(r);
                for (var o = t = 0, a = 0; a < n; a++)
                    for (var s = 0; s < i; s++) {
                        var l = e[o],
                            c = e[++o],
                            h = e[++o],
                            u = e[++o];
                        o++, r[t] = h, r[++t] = c, r[++t] = l, r[++t] = u, t++
                    }
                return r
            }
            var r = {
                    mipmaps: [],
                    width: 0,
                    height: 0,
                    format: null,
                    mipmapCount: 1
                },
                o = i("DXT1"),
                a = i("DXT3"),
                s = i("DXT5");
            if (542327876 !== (c = new Int32Array(e, 0, 31))[0]) return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"), r;
            if (4 & !c[20]) return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"), r;
            var l = !1;
            switch (h = c[21]) {
                case o:
                    o = 8, r.format = THREE.RGB_S3TC_DXT1_Format;
                    break;
                case a:
                    o = 16, r.format = THREE.RGBA_S3TC_DXT3_Format;
                    break;
                case s:
                    o = 16, r.format = THREE.RGBA_S3TC_DXT5_Format;
                    break;
                default:
                    if (!(32 == c[22] && 16711680 & c[23] && 65280 & c[24] && 255 & c[25] && 4278190080 & c[26])) return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ", String.fromCharCode(255 & h, h >> 8 & 255, h >> 16 & 255, h >> 24 & 255)), r;
                    l = !0, o = 64, r.format = THREE.RGBAFormat
            }
            r.mipmapCount = 1, 131072 & c[2] && !1 !== t && (r.mipmapCount = Math.max(1, c[7])), r.isCubemap = !!(512 & c[28]), r.width = c[4], r.height = c[3];
            for (var c = c[1] + 4, h = (a = r.width, s = r.height, r.isCubemap ? 6 : 1), u = 0; u < h; u++) {
                for (var f = 0; f < r.mipmapCount; f++) {
                    if (l) var d = n(e, c, a, s),
                        p = d.length;
                    else p = Math.max(4, a) / 4 * Math.max(4, s) / 4 * o, d = new Uint8Array(e, c, p);
                    r.mipmaps.push({
                        data: d,
                        width: a,
                        height: s
                    }), c += p, a = Math.max(.5 * a, 1), s = Math.max(.5 * s, 1)
                }
                a = r.width, s = r.height
            }
            return r
        },
        getNormalMap: function (e, t) {
            t |= 1;
            var i = e.width,
                n = e.height,
                r = document.createElement("canvas");
            r.width = i, r.height = n;
            var o, a, s = r.getContext("2d");
            s.drawImage(e, 0, 0);
            for (var l = s.getImageData(0, 0, i, n).data, c = s.createImageData(i, n), h = c.data, u = 0; u < i; u++)
                for (var f = 0; f < n; f++) {
                    var d = f - 1 < 0 ? 0 : f - 1,
                        p = n - 1 < f + 1 ? n - 1 : f + 1,
                        m = u - 1 < 0 ? 0 : u - 1,
                        g = i - 1 < u + 1 ? i - 1 : u + 1,
                        E = [],
                        v = [0, 0, l[4 * (f * i + u)] / 255 * t];
                    for (E.push([-1, 0, l[4 * (f * i + m)] / 255 * t]), E.push([-1, -1, l[4 * (d * i + m)] / 255 * t]), E.push([0, -1, l[4 * (d * i + u)] / 255 * t]), E.push([1, -1, l[4 * (d * i + g)] / 255 * t]), E.push([1, 0, l[4 * (f * i + g)] / 255 * t]), E.push([1, 1, l[4 * (p * i + g)] / 255 * t]), E.push([0, 1, l[4 * (p * i + u)] / 255 * t]), E.push([-1, 1, l[4 * (p * i + m)] / 255 * t]), d = [], m = E.length, p = 0; p < m; p++) {
                        g = E[p];
                        var y = E[(p + 1) % m];
                        g = [g[0] - v[0], g[1] - v[1], g[2] - v[2]], y = [y[0] - v[0], y[1] - v[1], y[2] - v[2]];
                        d.push((o = [g[1] * y[2] - g[2] * y[1], g[2] * y[0] - g[0] * y[2], g[0] * y[1] - g[1] * y[0]], void 0, a = Math.sqrt(o[0] * o[0] + o[1] * o[1] + o[2] * o[2]), [o[0] / a, o[1] / a, o[2] / a]))
                    }
                    for (E = [0, 0, 0], p = 0; p < d.length; p++) E[0] += d[p][0], E[1] += d[p][1], E[2] += d[p][2];
                    E[0] /= d.length, E[1] /= d.length, E[2] /= d.length, h[v = 4 * (f * i + u)] = (E[0] + 1) / 2 * 255 | 0, h[v + 1] = (E[1] + 1) / 2 * 255 | 0, h[v + 2] = 255 * E[2] | 0, h[v + 3] = 255
                }
            return s.putImageData(c, 0, 0), r
        },
        generateDataTexture: function (e, t, i) {
            var n = e * t,
                r = new Uint8Array(3 * n),
                o = Math.floor(255 * i.r),
                a = Math.floor(255 * i.g);
            i = Math.floor(255 * i.b);
            for (var s = 0; s < n; s++) r[3 * s] = o, r[3 * s + 1] = a, r[3 * s + 2] = i;
            return (e = new THREE.DataTexture(r, e, t, THREE.RGBFormat)).needsUpdate = !0, e
        }
    }, THREE.SceneUtils = {
        createMultiMaterialObject: function (e, t) {
            for (var i = new THREE.Object3D, n = 0, r = t.length; n < r; n++) i.add(new THREE.Mesh(e, t[n]));
            return i
        },
        detach: function (e, t, i) {
            e.applyMatrix(t.matrixWorld), t.remove(e), i.add(e)
        },
        attach: function (e, t, i) {
            var n = new THREE.Matrix4;
            n.getInverse(i.matrixWorld), e.applyMatrix(n), t.remove(e), i.add(e)
        }
    }, THREE.FontUtils = {
        faces: {},
        face: "helvetiker",
        weight: "normal",
        style: "normal",
        size: 150,
        divisions: 10,
        getFace: function () {
            return this.faces[this.face][this.weight][this.style]
        },
        loadFace: function (e) {
            var t = e.familyName.toLowerCase();
            return this.faces[t] = this.faces[t] || {}, this.faces[t][e.cssFontWeight] = this.faces[t][e.cssFontWeight] || {}, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e
        },
        drawText: function (e) {
            var t = this.getFace(),
                i = this.size / t.resolution,
                n = 0,
                r = String(e).split(""),
                o = r.length,
                a = [];
            for (e = 0; e < o; e++) {
                var s = new THREE.Path;
                n = n + (s = this.extractGlyphPoints(r[e], t, i, n, s)).offset;
                a.push(s.path)
            }
            return {
                paths: a,
                offset: n / 2
            }
        },
        extractGlyphPoints: function (e, t, i, n, r) {
            var o, a, s, l, c, h, u, f, d, p, m, g = [],
                E = t.glyphs[e] || t.glyphs["?"];
            if (E) {
                if (E.o)
                    for (l = (t = E._cachedOutline || (E._cachedOutline = E.o.split(" "))).length, e = 0; e < l;) switch (s = t[e++], s) {
                        case "m":
                            s = t[e++] * i + n, c = t[e++] * i, r.moveTo(s, c);
                            break;
                        case "l":
                            s = t[e++] * i + n, c = t[e++] * i, r.lineTo(s, c);
                            break;
                        case "q":
                            if (s = t[e++] * i + n, c = t[e++] * i, f = t[e++] * i + n, d = t[e++] * i, r.quadraticCurveTo(f, d, s, c), o = g[g.length - 1])
                                for (h = o.x, u = o.y, o = 1, a = this.divisions; o <= a; o++) {
                                    var v = o / a;
                                    THREE.Shape.Utils.b2(v, h, f, s), THREE.Shape.Utils.b2(v, u, d, c)
                                }
                            break;
                        case "b":
                            if (s = t[e++] * i + n, c = t[e++] * i, f = t[e++] * i + n, d = t[e++] * -i, p = t[e++] * i + n, m = t[e++] * -i, r.bezierCurveTo(s, c, f, d, p, m), o = g[g.length - 1])
                                for (h = o.x, u = o.y, o = 1, a = this.divisions; o <= a; o++) v = o / a, THREE.Shape.Utils.b3(v, h, f, p, s), THREE.Shape.Utils.b3(v, u, d, m, c)
                    }
                return {
                    offset: E.ha * i,
                    path: r
                }
            }
        }
    }, THREE.FontUtils.generateShapes = function (e, t) {
        var i = void 0 !== (t = t || {}).curveSegments ? t.curveSegments : 4,
            n = void 0 !== t.font ? t.font : "helvetiker",
            r = void 0 !== t.weight ? t.weight : "normal",
            o = void 0 !== t.style ? t.style : "normal";
        for (THREE.FontUtils.size = void 0 !== t.size ? t.size : 100, THREE.FontUtils.divisions = i, THREE.FontUtils.face = n, THREE.FontUtils.weight = r, THREE.FontUtils.style = o, n = [], r = 0, o = (i = THREE.FontUtils.drawText(e).paths).length; r < o; r++) Array.prototype.push.apply(n, i[r].toShapes());
        return n
    },
    function (e) {
        var C = function (e) {
            for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
            return .5 * i
        };
        e.Triangulate = function (e, t) {
            var i = e.length;
            if (i < 3) return null;
            var n, r, o, a = [],
                s = [],
                l = [];
            if (0 < C(e))
                for (r = 0; r < i; r++) s[r] = r;
            else
                for (r = 0; r < i; r++) s[r] = i - 1 - r;
            var c = 2 * i;
            for (r = i - 1; 2 < i;) {
                if (c-- <= 0) {
                    console.log("Warning, unable to triangulate polygon!");
                    break
                }
                var h;
                i <= (n = r) && (n = 0), i <= (r = n + 1) && (r = 0), i <= (o = r + 1) && (o = 0);
                e: {
                    var u = h = void 0,
                        f = void 0,
                        d = void 0,
                        p = void 0,
                        m = (u = e[s[n]].x, e[s[n]].y),
                        g = e[s[r]].x,
                        E = e[s[r]].y,
                        v = e[s[o]].x;
                    if ((g - u) * ((f = e[s[o]].y) - m) - (E - m) * (v - u) < 1e-10) h = !1;
                    else {
                        var y = void 0,
                            T = void 0,
                            b = void 0,
                            x = void 0,
                            R = (b = T = y = p = d = void 0, v - g),
                            w = f - E,
                            _ = u - v,
                            H = m - f,
                            S = g - u,
                            M = E - m;
                        for (h = 0; h < i; h++)
                            if (d = e[s[h]].x, p = e[s[h]].y, !(d === u && p === m || d === g && p === E || d === v && p === f) && (b = d - g, x = p - E, y = S * (T = p - m) - M * (y = d - u), T = _ * (p -= f) - H * (d -= v), -1e-10 <= (b = R * x - w * b) && -1e-10 <= T && -1e-10 <= y)) {
                                h = !1;
                                break e
                            } h = !0
                    }
                }
                if (h) {
                    for (a.push([e[s[n]], e[s[r]], e[s[o]]]), l.push([s[n], s[r], s[o]]), o = (n = r) + 1; o < i; n++, o++) s[n] = s[o];
                    c = 2 * --i
                }
            }
            return t ? l : a
        }, e.Triangulate.area = C
    }(THREE.FontUtils), self._typeface_js = {
        faces: THREE.FontUtils.faces,
        loadFace: THREE.FontUtils.loadFace
    }, THREE.typeface_js = self._typeface_js, THREE.Curve = function () {}, THREE.Curve.prototype.getPoint = function (e) {
        return console.log("Warning, getPoint() not implemented!"), null
    }, THREE.Curve.prototype.getPointAt = function (e) {
        return e = this.getUtoTmapping(e), this.getPoint(e)
    }, THREE.Curve.prototype.getPoints = function (e) {
        e || (e = 5);
        var t, i = [];
        for (t = 0; t <= e; t++) i.push(this.getPoint(t / e));
        return i
    }, THREE.Curve.prototype.getSpacedPoints = function (e) {
        e || (e = 5);
        var t, i = [];
        for (t = 0; t <= e; t++) i.push(this.getPointAt(t / e));
        return i
    }, THREE.Curve.prototype.getLength = function () {
        var e = this.getLengths();
        return e[e.length - 1]
    }, THREE.Curve.prototype.getLengths = function (e) {
        if (e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length == e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        var t, i, n = [],
            r = this.getPoint(0),
            o = 0;
        for (n.push(0), i = 1; i <= e; i++) o += (t = this.getPoint(i / e)).distanceTo(r), n.push(o), r = t;
        return this.cacheArcLengths = n
    }, THREE.Curve.prototype.updateArcLengths = function () {
        this.needsUpdate = !0, this.getLengths()
    }, THREE.Curve.prototype.getUtoTmapping = function (e, t) {
        var i, n = this.getLengths(),
            r = 0,
            o = n.length;
        i = t || e * n[o - 1];
        for (var a, s = 0, l = o - 1; s <= l;)
            if ((a = n[r = Math.floor(s + (l - s) / 2)] - i) < 0) s = r + 1;
            else {
                if (!(0 < a)) {
                    l = r;
                    break
                }
                l = r - 1
            } return n[r = l] == i ? r / (o - 1) : (r + (i - (s = n[r])) / (n[r + 1] - s)) / (o - 1)
    }, THREE.Curve.prototype.getTangent = function (e) {
        var t = e - 1e-4;
        return t < 0 && (t = 0), 1 < (e += 1e-4) && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
    }, THREE.Curve.prototype.getTangentAt = function (e) {
        return e = this.getUtoTmapping(e), this.getTangent(e)
    }, THREE.Curve.Utils = {
        tangentQuadraticBezier: function (e, t, i, n) {
            return 2 * (1 - e) * (i - t) + 2 * e * (n - i)
        },
        tangentCubicBezier: function (e, t, i, n, r) {
            return -3 * t * (1 - e) * (1 - e) + 3 * i * (1 - e) * (1 - e) - 6 * e * i * (1 - e) + 6 * e * n * (1 - e) - 3 * e * e * n + 3 * e * e * r
        },
        tangentSpline: function (e, t, i, n, r) {
            return 6 * e * e - 6 * e + (3 * e * e - 4 * e + 1) + (-6 * e * e + 6 * e) + (3 * e * e - 2 * e)
        },
        interpolate: function (e, t, i, n, r) {
            var o = r * r;
            return (2 * t - 2 * i + (e = .5 * (i - e)) + (n = .5 * (n - t))) * r * o + (-3 * t + 3 * i - 2 * e - n) * o + e * r + t
        }
    }, THREE.Curve.create = function (e, t) {
        return e.prototype = Object.create(THREE.Curve.prototype), e.prototype.getPoint = t, e
    }, THREE.CurvePath = function () {
        this.curves = [], this.bends = [], this.autoClose = !1
    }, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.add = function (e) {
        this.curves.push(e)
    }, THREE.CurvePath.prototype.checkConnection = function () {}, THREE.CurvePath.prototype.closePath = function () {
        var e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new THREE.LineCurve(t, e))
    }, THREE.CurvePath.prototype.getPoint = function (e) {
        var t = e * this.getLength(),
            i = this.getCurveLengths();
        for (e = 0; e < i.length;) {
            if (i[e] >= t) return t = 1 - (t = i[e] - t) / (e = this.curves[e]).getLength(), e.getPointAt(t);
            e++
        }
        return null
    }, THREE.CurvePath.prototype.getLength = function () {
        var e = this.getCurveLengths();
        return e[e.length - 1]
    }, THREE.CurvePath.prototype.getCurveLengths = function () {
        if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
        var e, t = [],
            i = 0,
            n = this.curves.length;
        for (e = 0; e < n; e++) i += this.curves[e].getLength(), t.push(i);
        return this.cacheLengths = t
    }, THREE.CurvePath.prototype.getBoundingBox = function () {
        var e, t, i, n, r, o, a = this.getPoints();
        e = t = Number.NEGATIVE_INFINITY, n = r = Number.POSITIVE_INFINITY;
        var s, l, c, h, u = a[0] instanceof THREE.Vector3;
        for (h = u ? new THREE.Vector3 : new THREE.Vector2, l = 0, c = a.length; l < c; l++)(s = a[l]).x > e ? e = s.x : s.x < n && (n = s.x), s.y > t ? t = s.y : s.y < r && (r = s.y), u && (s.z > i ? i = s.z : s.z < o && (o = s.z)), h.add(s);
        return a = {
            minX: n,
            minY: r,
            maxX: e,
            maxY: t,
            centroid: h.divideScalar(c)
        }, u && (a.maxZ = i, a.minZ = o), a
    }, THREE.CurvePath.prototype.createPointsGeometry = function (e) {
        return e = this.getPoints(e, !0), this.createGeometry(e)
    }, THREE.CurvePath.prototype.createSpacedPointsGeometry = function (e) {
        return e = this.getSpacedPoints(e, !0), this.createGeometry(e)
    }, THREE.CurvePath.prototype.createGeometry = function (e) {
        for (var t = new THREE.Geometry, i = 0; i < e.length; i++) t.vertices.push(new THREE.Vector3(e[i].x, e[i].y, e[i].z || 0));
        return t
    }, THREE.CurvePath.prototype.addWrapPath = function (e) {
        this.bends.push(e)
    }, THREE.CurvePath.prototype.getTransformedPoints = function (e, t) {
        var i, n, r = this.getPoints(e);
        for (t || (t = this.bends), i = 0, n = t.length; i < n; i++) r = this.getWrapPoints(r, t[i]);
        return r
    }, THREE.CurvePath.prototype.getTransformedSpacedPoints = function (e, t) {
        var i, n, r = this.getSpacedPoints(e);
        for (t || (t = this.bends), i = 0, n = t.length; i < n; i++) r = this.getWrapPoints(r, t[i]);
        return r
    }, THREE.CurvePath.prototype.getWrapPoints = function (e, t) {
        var i, n, r, o, a, s, l = this.getBoundingBox();
        for (i = 0, n = e.length; i < n; i++) o = (r = e[i]).x, a = r.y, s = o / l.maxX, s = t.getUtoTmapping(s, o), o = t.getPoint(s), (s = t.getTangent(s)).set(-s.y, s.x).multiplyScalar(a), r.x = o.x + s.x, r.y = o.y + s.y;
        return e
    }, THREE.Gyroscope = function () {
        THREE.Object3D.call(this)
    }, THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype), THREE.Gyroscope.prototype.updateMatrixWorld = function (e) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), e = !(this.matrixWorldNeedsUpdate = !1));
        for (var t = 0, i = this.children.length; t < i; t++) this.children[t].updateMatrixWorld(e)
    }, THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3, THREE.Gyroscope.prototype.translationObject = new THREE.Vector3, THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion, THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion, THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3, THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3, THREE.Path = function (e) {
        THREE.CurvePath.call(this), this.actions = [], e && this.fromPoints(e)
    }, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.PathActions = {
        MOVE_TO: "moveTo",
        LINE_TO: "lineTo",
        QUADRATIC_CURVE_TO: "quadraticCurveTo",
        BEZIER_CURVE_TO: "bezierCurveTo",
        CSPLINE_THRU: "splineThru",
        ARC: "arc",
        ELLIPSE: "ellipse"
    }, THREE.Path.prototype.fromPoints = function (e) {
        this.moveTo(e[0].x, e[0].y);
        for (var t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y)
    }, THREE.Path.prototype.moveTo = function (e, t) {
        var i = Array.prototype.slice.call(arguments);
        this.actions.push({
            action: THREE.PathActions.MOVE_TO,
            args: i
        })
    }, THREE.Path.prototype.lineTo = function (e, t) {
        var i = Array.prototype.slice.call(arguments),
            n = this.actions[this.actions.length - 1].args;
        n = new THREE.LineCurve(new THREE.Vector2(n[n.length - 2], n[n.length - 1]), new THREE.Vector2(e, t));
        this.curves.push(n), this.actions.push({
            action: THREE.PathActions.LINE_TO,
            args: i
        })
    }, THREE.Path.prototype.quadraticCurveTo = function (e, t, i, n) {
        var r = Array.prototype.slice.call(arguments),
            o = this.actions[this.actions.length - 1].args;
        o = new THREE.QuadraticBezierCurve(new THREE.Vector2(o[o.length - 2], o[o.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(i, n));
        this.curves.push(o), this.actions.push({
            action: THREE.PathActions.QUADRATIC_CURVE_TO,
            args: r
        })
    }, THREE.Path.prototype.bezierCurveTo = function (e, t, i, n, r, o) {
        var a = Array.prototype.slice.call(arguments),
            s = this.actions[this.actions.length - 1].args;
        s = new THREE.CubicBezierCurve(new THREE.Vector2(s[s.length - 2], s[s.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(i, n), new THREE.Vector2(r, o));
        this.curves.push(s), this.actions.push({
            action: THREE.PathActions.BEZIER_CURVE_TO,
            args: a
        })
    }, THREE.Path.prototype.splineThru = function (e) {
        var t = Array.prototype.slice.call(arguments),
            i = this.actions[this.actions.length - 1].args;
        i = [new THREE.Vector2(i[i.length - 2], i[i.length - 1])];
        Array.prototype.push.apply(i, e), i = new THREE.SplineCurve(i), this.curves.push(i), this.actions.push({
            action: THREE.PathActions.CSPLINE_THRU,
            args: t
        })
    }, THREE.Path.prototype.arc = function (e, t, i, n, r, o) {
        var a = this.actions[this.actions.length - 1].args;
        this.absarc(e + a[a.length - 2], t + a[a.length - 1], i, n, r, o)
    }, THREE.Path.prototype.absarc = function (e, t, i, n, r, o) {
        this.absellipse(e, t, i, i, n, r, o)
    }, THREE.Path.prototype.ellipse = function (e, t, i, n, r, o, a) {
        var s = this.actions[this.actions.length - 1].args;
        this.absellipse(e + s[s.length - 2], t + s[s.length - 1], i, n, r, o, a)
    }, THREE.Path.prototype.absellipse = function (e, t, i, n, r, o, a) {
        var s = Array.prototype.slice.call(arguments),
            l = new THREE.EllipseCurve(e, t, i, n, r, o, a);
        this.curves.push(l), l = l.getPoint(1), s.push(l.x), s.push(l.y), this.actions.push({
            action: THREE.PathActions.ELLIPSE,
            args: s
        })
    }, THREE.Path.prototype.getSpacedPoints = function (e, t) {
        e || (e = 40);
        for (var i = [], n = 0; n < e; n++) i.push(this.getPoint(n / e));
        return i
    }, THREE.Path.prototype.getPoints = function (e, t) {
        if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(e, t);
        e = e || 12;
        var i, n, r, o, a, s, l, c, h, u, f, d, p, m = [];
        for (i = 0, n = this.actions.length; i < n; i++) switch (r = this.actions[i], o = r.action, r = r.args, o) {
            case THREE.PathActions.MOVE_TO:
            case THREE.PathActions.LINE_TO:
                m.push(new THREE.Vector2(r[0], r[1]));
                break;
            case THREE.PathActions.QUADRATIC_CURVE_TO:
                for (a = r[2], s = r[3], h = r[0], u = r[1], d = 0 < m.length ? (f = (o = m[m.length - 1]).x, o.y) : (f = (o = this.actions[i - 1].args)[o.length - 2], o[o.length - 1]), r = 1; r <= e; r++) p = r / e, o = THREE.Shape.Utils.b2(p, f, h, a), p = THREE.Shape.Utils.b2(p, d, u, s), m.push(new THREE.Vector2(o, p));
                break;
            case THREE.PathActions.BEZIER_CURVE_TO:
                for (a = r[4], s = r[5], h = r[0], u = r[1], l = r[2], c = r[3], d = 0 < m.length ? (f = (o = m[m.length - 1]).x, o.y) : (f = (o = this.actions[i - 1].args)[o.length - 2], o[o.length - 1]), r = 1; r <= e; r++) p = r / e, o = THREE.Shape.Utils.b3(p, f, h, l, a), p = THREE.Shape.Utils.b3(p, d, u, c, s), m.push(new THREE.Vector2(o, p));
                break;
            case THREE.PathActions.CSPLINE_THRU:
                for (o = this.actions[i - 1].args, p = [new THREE.Vector2(o[o.length - 2], o[o.length - 1])], o = e * r[0].length, p = p.concat(r[0]), p = new THREE.SplineCurve(p), r = 1; r <= o; r++) m.push(p.getPointAt(r / o));
                break;
            case THREE.PathActions.ARC:
                for (a = r[0], s = r[1], u = r[2], l = r[3], o = r[4], h = !!r[5], f = o - l, d = 2 * e, r = 1; r <= d; r++) p = r / d, h || (p = 1 - p), p = l + p * f, o = a + u * Math.cos(p), p = s + u * Math.sin(p), m.push(new THREE.Vector2(o, p));
                break;
            case THREE.PathActions.ELLIPSE:
                for (a = r[0], s = r[1], u = r[2], c = r[3], l = r[4], o = r[5], h = !!r[6], f = o - l, d = 2 * e, r = 1; r <= d; r++) p = r / d, h || (p = 1 - p), p = l + p * f, o = a + u * Math.cos(p), p = s + c * Math.sin(p), m.push(new THREE.Vector2(o, p))
        }
        return i = m[m.length - 1], Math.abs(i.x - m[0].x) < 1e-10 && Math.abs(i.y - m[0].y) < 1e-10 && m.splice(m.length - 1, 1), t && m.push(m[0]), m
    }, THREE.Path.prototype.toShapes = function (e) {
        function t(e, t) {
            for (var i = t.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                var a = t[r],
                    s = t[o],
                    l = s.x - a.x,
                    c = s.y - a.y;
                if (1e-10 < Math.abs(c)) {
                    if (c < 0 && (a = t[o], l = -l, s = t[r], c = -c), !(e.y < a.y || e.y > s.y))
                        if (e.y == a.y) {
                            if (e.x == a.x) return !0
                        } else {
                            if (0 == (r = c * (e.x - a.x) - l * (e.y - a.y))) return !0;
                            r < 0 || (n = !n)
                        }
                } else if (e.y == a.y && (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x)) return !0
            }
            return n
        }
        var i, n, r, o, a, s, l, c = [],
            h = new THREE.Path;
        for (i = 0, n = this.actions.length; i < n; i++) o = (r = this.actions[i]).args, (r = r.action) == THREE.PathActions.MOVE_TO && 0 != h.actions.length && (c.push(h), h = new THREE.Path), h[r].apply(h, o);
        if (0 != h.actions.length && c.push(h), 0 == c.length) return [];
        if (o = [], 1 == c.length) return s = c[0], (l = new THREE.Shape).actions = s.actions, l.curves = s.curves, o.push(l), o;
        var u = !THREE.Shape.Utils.isClockWise(c[0].getPoints());
        u = e ? !u : u;
        l = [], r = [];
        var f, d = 0;
        for ((h = [])[d] = void 0, r[d] = [], i = 0, n = c.length; i < n; i++) f = (s = c[i]).getPoints(), a = THREE.Shape.Utils.isClockWise(f), (a = e ? !a : a) ? (!u && h[d] && d++, h[d] = {
            s: new THREE.Shape,
            p: f
        }, h[d].s.actions = s.actions, h[d].s.curves = s.curves, u && d++, r[d] = []) : r[d].push({
            h: s,
            p: f[0]
        });
        if (1 < h.length) {
            for (i = !1, n = [], e = 0, c = h.length; e < c; e++) l[e] = [];
            for (e = 0, c = h.length; e < c; e++)
                for (s = r[e], a = 0; a < s.length; a++) {
                    for (u = s[a], d = !0, f = 0; f < h.length; f++) t(u.p, h[f].p) && (e != f && n.push({
                        froms: e,
                        tos: f,
                        hole: a
                    }), d ? (d = !1, l[f].push(u)) : i = !0);
                    d && l[e].push(u)
                }
            0 < n.length && (i || (r = l))
        }
        for (i = 0, n = h.length; i < n; i++)
            for (l = h[i].s, o.push(l), c = 0, s = (e = r[i]).length; c < s; c++) l.holes.push(e[c].h);
        return o
    }, THREE.Shape = function () {
        THREE.Path.apply(this, arguments), this.holes = []
    }, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.extrude = function (e) {
        return new THREE.ExtrudeGeometry(this, e)
    }, THREE.Shape.prototype.makeGeometry = function (e) {
        return new THREE.ShapeGeometry(this, e)
    }, THREE.Shape.prototype.getPointsHoles = function (e) {
        var t, i = this.holes.length,
            n = [];
        for (t = 0; t < i; t++) n[t] = this.holes[t].getTransformedPoints(e, this.bends);
        return n
    }, THREE.Shape.prototype.getSpacedPointsHoles = function (e) {
        var t, i = this.holes.length,
            n = [];
        for (t = 0; t < i; t++) n[t] = this.holes[t].getTransformedSpacedPoints(e, this.bends);
        return n
    }, THREE.Shape.prototype.extractAllPoints = function (e) {
        return {
            shape: this.getTransformedPoints(e),
            holes: this.getPointsHoles(e)
        }
    }, THREE.Shape.prototype.extractPoints = function (e) {
        return this.useSpacedPoints ? this.extractAllSpacedPoints(e) : this.extractAllPoints(e)
    }, THREE.Shape.prototype.extractAllSpacedPoints = function (e) {
        return {
            shape: this.getTransformedSpacedPoints(e),
            holes: this.getSpacedPointsHoles(e)
        }
    }, THREE.Shape.Utils = {
        triangulateShape: function (y, e) {
            function d(e, t, i) {
                return e.x != t.x ? e.x < t.x ? e.x <= i.x && i.x <= t.x : t.x <= i.x && i.x <= e.x : e.y < t.y ? e.y <= i.y && i.y <= t.y : t.y <= i.y && i.y <= e.y
            }

            function T(e, t, i, n, r) {
                var o = t.x - e.x,
                    a = t.y - e.y,
                    s = n.x - i.x,
                    l = n.y - i.y,
                    c = e.x - i.x,
                    h = e.y - i.y,
                    u = a * s - o * l,
                    f = a * c - o * h;
                if (1e-10 < Math.abs(u)) {
                    if (0 < u) {
                        if (f < 0 || u < f) return [];
                        if ((s = l * c - s * h) < 0 || u < s) return []
                    } else {
                        if (0 < f || f < u) return [];
                        if (0 < (s = l * c - s * h) || s < u) return []
                    }
                    return 0 == s ? !r || 0 != f && f != u ? [e] : [] : s == u ? !r || 0 != f && f != u ? [t] : [] : 0 == f ? [i] : f == u ? [n] : (r = s / u, [{
                        x: e.x + r * o,
                        y: e.y + r * a
                    }])
                }
                return 0 != f || l * c != s * h ? [] : (s = 0 == s && 0 == l, (a = 0 == o && 0 == a) && s ? e.x != i.x || e.y != i.y ? [] : [e] : a ? d(i, n, e) ? [e] : [] : s ? d(e, t, i) ? [i] : [] : (i = 0 != o ? (e = e.x < t.x ? (s = (o = e).x, (a = t).x) : (s = (o = t).x, (a = e).x), i.x < n.x ? (u = (t = i).x, (l = n).x) : (u = (t = n).x, (l = i).x)) : (e = e.y < t.y ? (s = (o = e).y, (a = t).y) : (s = (o = t).y, (a = e).y), i.y < n.y ? (u = (t = i).y, (l = n).y) : (u = (t = n).y, (l = i).y)), s <= u ? e < u ? [] : e == u ? r ? [] : [t] : e <= i ? [t, a] : [t, l] : i < s ? [] : s == i ? r ? [] : [o] : e <= i ? [o, a] : [o, l]))
            }

            function b(e, t, i, n) {
                var r = t.x - e.x,
                    o = t.y - e.y;
                t = i.x - e.x, i = i.y - e.y;
                var a = n.x - e.x;
                return n = n.y - e.y, e = r * i - o * t, r = r * n - o * a, 1e-10 < Math.abs(e) ? (t = a * i - n * t, 0 < e ? 0 <= r && 0 <= t : 0 <= r || 0 <= t) : 0 < r
            }
            var t, i, n, r, o, a = {};
            for (n = y.concat(), t = 0, i = e.length; t < i; t++) Array.prototype.push.apply(n, e[t]);
            for (t = 0, i = n.length; t < i; t++) void 0 !== a[o = n[t].x + ":" + n[t].y] && console.log("Duplicate point", o), a[o] = t;
            t = function (e, a) {
                function t(e, t) {
                    var i = p.length - 1,
                        n = e - 1;
                    n < 0 && (n = i);
                    var r = e + 1;
                    return i < r && (r = 0), !!(i = b(p[e], p[n], p[r], o[t])) && (i = o.length - 1, (n = t - 1) < 0 && (n = i), i < (r = t + 1) && (r = 0), !!(i = b(o[t], o[n], o[r], p[e])))
                }

                function i(e, t) {
                    var i, n;
                    for (i = 0; i < p.length; i++)
                        if (n = i + 1, n %= p.length, 0 < (n = T(e, t, p[i], p[n], !0)).length) return !0;
                    return !1
                }

                function n(e, t) {
                    var i, n, r, o;
                    for (i = 0; i < m.length; i++)
                        for (n = a[m[i]], r = 0; r < n.length; r++)
                            if (o = r + 1, o %= n.length, 0 < (o = T(e, t, n[r], n[o], !0)).length) return !0;
                    return !1
                }
                var o, r, s, l, c, h, u, f, d, p = y.concat(),
                    m = [],
                    g = [],
                    E = 0;
                for (r = a.length; E < r; E++) m.push(E);
                for (var v = 2 * m.length; 0 < m.length;) {
                    if (--v < 0) {
                        console.log("Infinite Loop! Holes left:" + m.length + ", Probably Hole outside Shape!");
                        break
                    }
                    for (s = 0; s < p.length; s++) {
                        for (l = p[s], r = -1, E = 0; E < m.length; E++)
                            if (c = m[E], void 0 === g[h = l.x + ":" + l.y + ":" + c]) {
                                for (o = a[c], u = 0; u < o.length; u++)
                                    if (c = o[u], t(s, u) && !i(l, c) && !n(l, c)) {
                                        r = u, m.splice(E, 1), c = p.slice(0, s + 1), u = p.slice(s), f = o.slice(r), d = o.slice(0, r + 1), p = c.concat(f).concat(d).concat(u);
                                        break
                                    } if (0 <= r) break;
                                g[h] = !0
                            } if (0 <= r) break
                    }
                }
                return p
            }(0, e);
            var s = THREE.FontUtils.Triangulate(t, !1);
            for (t = 0, i = s.length; t < i; t++)
                for (r = s[t], n = 0; n < 3; n++) void 0 !== (o = a[o = r[n].x + ":" + r[n].y]) && (r[n] = o);
            return s.concat()
        },
        isClockWise: function (e) {
            return THREE.FontUtils.Triangulate.area(e) < 0
        },
        b2p0: function (e, t) {
            var i = 1 - e;
            return i * i * t
        },
        b2p1: function (e, t) {
            return 2 * (1 - e) * e * t
        },
        b2p2: function (e, t) {
            return e * e * t
        },
        b2: function (e, t, i, n) {
            return this.b2p0(e, t) + this.b2p1(e, i) + this.b2p2(e, n)
        },
        b3p0: function (e, t) {
            var i = 1 - e;
            return i * i * i * t
        },
        b3p1: function (e, t) {
            var i = 1 - e;
            return 3 * i * i * e * t
        },
        b3p2: function (e, t) {
            return 3 * (1 - e) * e * e * t
        },
        b3p3: function (e, t) {
            return e * e * e * t
        },
        b3: function (e, t, i, n, r) {
            return this.b3p0(e, t) + this.b3p1(e, i) + this.b3p2(e, n) + this.b3p3(e, r)
        }
    }, THREE.LineCurve = function (e, t) {
        this.v1 = e, this.v2 = t
    }, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.getPoint = function (e) {
        var t = this.v2.clone().sub(this.v1);
        return t.multiplyScalar(e).add(this.v1), t
    }, THREE.LineCurve.prototype.getPointAt = function (e) {
        return this.getPoint(e)
    }, THREE.LineCurve.prototype.getTangent = function (e) {
        return this.v2.clone().sub(this.v1).normalize()
    }, THREE.QuadraticBezierCurve = function (e, t, i) {
        this.v0 = e, this.v1 = t, this.v2 = i
    }, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.QuadraticBezierCurve.prototype.getPoint = function (e) {
        var t;
        return t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), e = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), new THREE.Vector2(t, e)
    }, THREE.QuadraticBezierCurve.prototype.getTangent = function (e) {
        var t;
        return t = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.x, this.v1.x, this.v2.x), e = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.y, this.v1.y, this.v2.y), (t = new THREE.Vector2(t, e)).normalize(), t
    }, THREE.CubicBezierCurve = function (e, t, i, n) {
        this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n
    }, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.getPoint = function (e) {
        var t;
        return t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new THREE.Vector2(t, e)
    }, THREE.CubicBezierCurve.prototype.getTangent = function (e) {
        var t;
        return t = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), (t = new THREE.Vector2(t, e)).normalize(), t
    }, THREE.SplineCurve = function (e) {
        this.points = null == e ? [] : e
    }, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.getPoint = function (e) {
        var t, i = new THREE.Vector2,
            n = [],
            r = this.points;
        return t = (r.length - 1) * e, t -= e = Math.floor(t), n[0] = 0 == e ? e : e - 1, n[1] = e, n[2] = e > r.length - 2 ? r.length - 1 : e + 1, n[3] = e > r.length - 3 ? r.length - 1 : e + 2, i.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, t), i.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, t), i
    }, THREE.EllipseCurve = function (e, t, i, n, r, o, a) {
        this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a
    }, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.getPoint = function (e) {
        var t;
        return (t = this.aEndAngle - this.aStartAngle) < 0 && (t += 2 * Math.PI), t > 2 * Math.PI && (t -= 2 * Math.PI), t = !0 === this.aClockwise ? this.aEndAngle + (1 - e) * (2 * Math.PI - t) : this.aStartAngle + e * t, e = this.aX + this.xRadius * Math.cos(t), t = this.aY + this.yRadius * Math.sin(t), new THREE.Vector2(e, t)
    }, THREE.ArcCurve = function (e, t, i, n, r, o) {
        THREE.EllipseCurve.call(this, e, t, i, i, n, r, o)
    }, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.LineCurve3 = THREE.Curve.create(function (e, t) {
        this.v1 = e, this.v2 = t
    }, function (e) {
        var t = new THREE.Vector3;
        return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t
    }), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (e, t, i) {
        this.v0 = e, this.v1 = t, this.v2 = i
    }, function (e) {
        var t, i;
        return t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), i = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), e = THREE.Shape.Utils.b2(e, this.v0.z, this.v1.z, this.v2.z), new THREE.Vector3(t, i, e)
    }), THREE.CubicBezierCurve3 = THREE.Curve.create(function (e, t, i, n) {
        this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n
    }, function (e) {
        var t, i;
        return t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), i = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), e = THREE.Shape.Utils.b3(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z), new THREE.Vector3(t, i, e)
    }), THREE.SplineCurve3 = THREE.Curve.create(function (e) {
        this.points = null == e ? [] : e
    }, function (e) {
        var t, i = new THREE.Vector3,
            n = [],
            r = this.points;
        e *= r.length - 1, e -= t = Math.floor(e), n[0] = 0 == t ? t : t - 1, n[1] = t, n[2] = t > r.length - 2 ? r.length - 1 : t + 1, n[3] = t > r.length - 3 ? r.length - 1 : t + 2, t = r[n[0]];
        var o = r[n[1]],
            a = r[n[2]];
        n = r[n[3]];
        return i.x = THREE.Curve.Utils.interpolate(t.x, o.x, a.x, n.x, e), i.y = THREE.Curve.Utils.interpolate(t.y, o.y, a.y, n.y, e), i.z = THREE.Curve.Utils.interpolate(t.z, o.z, a.z, n.z, e), i
    }), THREE.ClosedSplineCurve3 = THREE.Curve.create(function (e) {
        this.points = null == e ? [] : e
    }, function (e) {
        var t, i = new THREE.Vector3,
            n = [],
            r = this.points;
        return t = (r.length - 0) * e, t -= e = Math.floor(t), e += 0 < e ? 0 : (Math.floor(Math.abs(e) / r.length) + 1) * r.length, n[0] = (e - 1) % r.length, n[1] = e % r.length, n[2] = (e + 1) % r.length, n[3] = (e + 2) % r.length, i.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, t), i.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, t), i.z = THREE.Curve.Utils.interpolate(r[n[0]].z, r[n[1]].z, r[n[2]].z, r[n[3]].z, t), i
    }), THREE.AnimationHandler = function () {
        var i = [],
            s = {},
            e = {
                update: function (e) {
                    for (var t = 0; t < i.length; t++) i[t].update(e)
                },
                addToUpdate: function (e) {
                    -1 === i.indexOf(e) && i.push(e)
                },
                removeFromUpdate: function (e) {
                    -1 !== (e = i.indexOf(e)) && i.splice(e, 1)
                },
                add: function (e) {
                    if (void 0 !== s[e.name] && console.log("THREE.AnimationHandler.add: Warning! " + e.name + " already exists in library. Overwriting."), !0 !== (s[e.name] = e).initialized) {
                        for (var t = 0; t < e.hierarchy.length; t++) {
                            for (var i = 0; i < e.hierarchy[t].keys.length; i++)
                                if (e.hierarchy[t].keys[i].time < 0 && (e.hierarchy[t].keys[i].time = 0), void 0 !== e.hierarchy[t].keys[i].rot && !(e.hierarchy[t].keys[i].rot instanceof THREE.Quaternion)) {
                                    var n = e.hierarchy[t].keys[i].rot;
                                    e.hierarchy[t].keys[i].rot = new THREE.Quaternion(n[0], n[1], n[2], n[3])
                                } if (e.hierarchy[t].keys.length && void 0 !== e.hierarchy[t].keys[0].morphTargets) {
                                for (n = {}, i = 0; i < e.hierarchy[t].keys.length; i++)
                                    for (var r = 0; r < e.hierarchy[t].keys[i].morphTargets.length; r++) {
                                        var o = e.hierarchy[t].keys[i].morphTargets[r];
                                        n[o] = -1
                                    }
                                for (e.hierarchy[t].usedMorphTargets = n, i = 0; i < e.hierarchy[t].keys.length; i++) {
                                    var a = {};
                                    for (o in n) {
                                        for (r = 0; r < e.hierarchy[t].keys[i].morphTargets.length; r++)
                                            if (e.hierarchy[t].keys[i].morphTargets[r] === o) {
                                                a[o] = e.hierarchy[t].keys[i].morphTargetsInfluences[r];
                                                break
                                            } r === e.hierarchy[t].keys[i].morphTargets.length && (a[o] = 0)
                                    }
                                    e.hierarchy[t].keys[i].morphTargetsInfluences = a
                                }
                            }
                            for (i = 1; i < e.hierarchy[t].keys.length; i++) e.hierarchy[t].keys[i].time === e.hierarchy[t].keys[i - 1].time && (e.hierarchy[t].keys.splice(i, 1), i--);
                            for (i = 0; i < e.hierarchy[t].keys.length; i++) e.hierarchy[t].keys[i].index = i
                        }
                        e.initialized = !0
                    }
                },
                get: function (e) {
                    if ("string" == typeof e) return s[e] ? s[e] : (console.log("THREE.AnimationHandler.get: Couldn't find animation " + e), null)
                },
                parse: function (e) {
                    var t = [];
                    if (e instanceof THREE.SkinnedMesh)
                        for (var i = 0; i < e.bones.length; i++) t.push(e.bones[i]);
                    else n(e, t);
                    return t
                }
            },
            n = function (e, t) {
                t.push(e);
                for (var i = 0; i < e.children.length; i++) n(e.children[i], t)
            };
        return e.LINEAR = 0, e.CATMULLROM = 1, e.CATMULLROM_FORWARD = 2, e
    }(), THREE.Animation = function (e, t) {
        this.root = e, this.data = THREE.AnimationHandler.get(t), this.hierarchy = THREE.AnimationHandler.parse(e), this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = this.isPaused = !0, this.interpolationType = THREE.AnimationHandler.LINEAR
    }, THREE.Animation.prototype.play = function (e) {
        this.currentTime = void 0 !== e ? e : 0, !1 === this.isPlaying && (this.isPlaying = !0, this.reset(), this.update(0)), this.isPaused = !1, THREE.AnimationHandler.addToUpdate(this)
    }, THREE.Animation.prototype.pause = function () {
        !0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this), this.isPaused = !this.isPaused
    }, THREE.Animation.prototype.stop = function () {
        this.isPaused = this.isPlaying = !1, THREE.AnimationHandler.removeFromUpdate(this)
    }, THREE.Animation.prototype.reset = function () {
        for (var e = 0, t = this.hierarchy.length; e < t; e++) {
            (n = this.hierarchy[e]).matrixAutoUpdate = !0, void 0 === n.animationCache && (n.animationCache = {}, n.animationCache.prevKey = {
                pos: 0,
                rot: 0,
                scl: 0
            }, n.animationCache.nextKey = {
                pos: 0,
                rot: 0,
                scl: 0
            }, n.animationCache.originalMatrix = n instanceof THREE.Bone ? n.skinMatrix : n.matrix);
            var i = n.animationCache.prevKey,
                n = n.animationCache.nextKey;
            i.pos = this.data.hierarchy[e].keys[0], i.rot = this.data.hierarchy[e].keys[0], i.scl = this.data.hierarchy[e].keys[0], n.pos = this.getNextKeyWith("pos", e, 1), n.rot = this.getNextKeyWith("rot", e, 1), n.scl = this.getNextKeyWith("scl", e, 1)
        }
    }, THREE.Animation.prototype.update = function () {
        var f = [],
            d = new THREE.Vector3,
            p = function (e, t) {
                var i, n, r, o, a, s, l = [],
                    c = [];
                return i = (e.length - 1) * t, i -= n = Math.floor(i), l[0] = 0 === n ? n : n - 1, l[1] = n, l[2] = n > e.length - 2 ? n : n + 1, l[3] = n > e.length - 3 ? n : n + 2, n = e[l[0]], o = e[l[1]], a = e[l[2]], s = e[l[3]], r = i * (l = i * i), c[0] = h(n[0], o[0], a[0], s[0], i, l, r), c[1] = h(n[1], o[1], a[1], s[1], i, l, r), c[2] = h(n[2], o[2], a[2], s[2], i, l, r), c
            },
            h = function (e, t, i, n, r, o, a) {
                return (2 * (t - i) + (e = .5 * (i - e)) + (n = .5 * (n - t))) * a + (-3 * (t - i) - 2 * e - n) * o + e * r + t
            };
        return function (e) {
            if (!1 !== this.isPlaying) {
                var t;
                this.currentTime += e * this.timeScale, e = ["pos", "rot", "scl"];
                var i = this.data.length;
                if (!0 === this.loop && this.currentTime > i) this.currentTime %= i, this.reset();
                else if (!1 === this.loop && this.currentTime > i) return void this.stop();
                this.currentTime = Math.min(this.currentTime, i);
                i = 0;
                for (var n = this.hierarchy.length; i < n; i++)
                    for (var r = this.hierarchy[i], o = r.animationCache, a = 0; a < 3; a++) {
                        t = e[a];
                        var s = o.prevKey[t],
                            l = o.nextKey[t];
                        if (l.time <= this.currentTime) {
                            for (s = this.data.hierarchy[i].keys[0], l = this.getNextKeyWith(t, i, 1); l.time < this.currentTime && l.index > s.index;) s = l, l = this.getNextKeyWith(t, i, l.index + 1);
                            o.prevKey[t] = s, o.nextKey[t] = l
                        }
                        r.matrixAutoUpdate = !0, r.matrixWorldNeedsUpdate = !0;
                        var c = (this.currentTime - s.time) / (l.time - s.time),
                            h = s[t],
                            u = l[t];
                        c < 0 && (c = 0), 1 < c && (c = 1), "pos" === t ? (t = r.position, this.interpolationType === THREE.AnimationHandler.LINEAR ? (t.x = h[0] + (u[0] - h[0]) * c, t.y = h[1] + (u[1] - h[1]) * c, t.z = h[2] + (u[2] - h[2]) * c) : this.interpolationType !== THREE.AnimationHandler.CATMULLROM && this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD || (f[0] = this.getPrevKeyWith("pos", i, s.index - 1).pos, f[1] = h, f[2] = u, f[3] = this.getNextKeyWith("pos", i, l.index + 1).pos, s = p(f, c = .33 * c + .33), t.x = s[0], t.y = s[1], t.z = s[2], this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (c = p(f, 1.01 * c), d.set(c[0], c[1], c[2]), d.sub(t), d.y = 0, d.normalize(), t = Math.atan2(d.x, d.z), r.rotation.set(0, t, 0)))) : "rot" === t ? THREE.Quaternion.slerp(h, u, r.quaternion, c) : "scl" === t && ((t = r.scale).x = h[0] + (u[0] - h[0]) * c, t.y = h[1] + (u[1] - h[1]) * c, t.z = h[2] + (u[2] - h[2]) * c)
                    }
            }
        }
    }(), THREE.Animation.prototype.getNextKeyWith = function (e, t, i) {
        var n = this.data.hierarchy[t].keys;
        for (i = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? i < n.length - 1 ? i : n.length - 1 : i % n.length; i < n.length; i++)
            if (void 0 !== n[i][e]) return n[i];
        return this.data.hierarchy[t].keys[0]
    }, THREE.Animation.prototype.getPrevKeyWith = function (e, t, i) {
        var n = this.data.hierarchy[t].keys;
        for (i = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < i ? i : 0 : 0 <= i ? i : i + n.length; 0 <= i; i--)
            if (void 0 !== n[i][e]) return n[i];
        return this.data.hierarchy[t].keys[n.length - 1]
    }, THREE.KeyFrameAnimation = function (e, t) {
        this.root = e, this.data = THREE.AnimationHandler.get(t), this.hierarchy = THREE.AnimationHandler.parse(e), this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.loop = this.isPaused = !0;
        for (var i = 0, n = this.hierarchy.length; i < n; i++) {
            var r = this.data.hierarchy[i].sids,
                o = this.hierarchy[i];
            if (this.data.hierarchy[i].keys.length && r) {
                for (var a = 0; a < r.length; a++) {
                    var s = r[a],
                        l = this.getNextKeyWith(s, i, 0);
                    l && l.apply(s)
                }
                o.matrixAutoUpdate = !1, this.data.hierarchy[i].node.updateMatrix(), o.matrixWorldNeedsUpdate = !0
            }
        }
    }, THREE.KeyFrameAnimation.prototype.play = function (e) {
        if (this.currentTime = void 0 !== e ? e : 0, !1 === this.isPlaying) {
            this.isPlaying = !0;
            var t, i, n = this.hierarchy.length;
            for (e = 0; e < n; e++) t = this.hierarchy[e], void 0 === (i = this.data.hierarchy[e]).animationCache && (i.animationCache = {}, i.animationCache.prevKey = null, i.animationCache.nextKey = null, i.animationCache.originalMatrix = t instanceof THREE.Bone ? t.skinMatrix : t.matrix), (t = this.data.hierarchy[e].keys).length && (i.animationCache.prevKey = t[0], i.animationCache.nextKey = t[1], this.startTime = Math.min(t[0].time, this.startTime), this.endTime = Math.max(t[t.length - 1].time, this.endTime));
            this.update(0)
        }
        this.isPaused = !1, THREE.AnimationHandler.addToUpdate(this)
    }, THREE.KeyFrameAnimation.prototype.pause = function () {
        this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this), this.isPaused = !this.isPaused
    }, THREE.KeyFrameAnimation.prototype.stop = function () {
        this.isPaused = this.isPlaying = !1, THREE.AnimationHandler.removeFromUpdate(this);
        for (var e = 0; e < this.data.hierarchy.length; e++) {
            var t = this.hierarchy[e],
                i = this.data.hierarchy[e];
            if (void 0 !== i.animationCache) {
                var n = i.animationCache.originalMatrix;
                t instanceof THREE.Bone ? (n.copy(t.skinMatrix), t.skinMatrix = n) : (n.copy(t.matrix), t.matrix = n), delete i.animationCache
            }
        }
    }, THREE.KeyFrameAnimation.prototype.update = function (e) {
        if (!1 !== this.isPlaying) {
            this.currentTime += e * this.timeScale, e = this.data.length, !0 === this.loop && this.currentTime > e && (this.currentTime %= e), this.currentTime = Math.min(this.currentTime, e), e = 0;
            for (var t = this.hierarchy.length; e < t; e++) {
                var i = this.hierarchy[e],
                    n = (r = this.data.hierarchy[e]).keys,
                    r = r.animationCache;
                if (n.length) {
                    var o = r.prevKey,
                        a = r.nextKey;
                    if (a.time <= this.currentTime) {
                        for (; a.time < this.currentTime && a.index > o.index;) a = n[(o = a).index + 1];
                        r.prevKey = o, r.nextKey = a
                    }
                    a.time >= this.currentTime ? o.interpolate(a, this.currentTime) : o.interpolate(a, a.time), this.data.hierarchy[e].node.updateMatrix(), i.matrixWorldNeedsUpdate = !0
                }
            }
        }
    }, THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (e, t, i) {
        for (i %= (t = this.data.hierarchy[t].keys).length; i < t.length; i++)
            if (t[i].hasTarget(e)) return t[i];
        return t[0]
    }, THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (e, t, i) {
        for (t = this.data.hierarchy[t].keys, i = 0 <= i ? i : i + t.length; 0 <= i; i--)
            if (t[i].hasTarget(e)) return t[i];
        return t[t.length - 1]
    }, THREE.MorphAnimation = function (e) {
        this.mesh = e, this.frames = e.morphTargetInfluences.length, this.currentTime = 0, this.duration = 1e3, this.loop = !0, this.isPlaying = !1
    }, THREE.MorphAnimation.prototype = {
        play: function () {
            this.isPlaying = !0
        },
        pause: function () {
            this.isPlaying = !1
        },
        update: function () {
            var i = 0,
                n = 0;
            return function (e) {
                if (!1 !== this.isPlaying) {
                    this.currentTime += e, !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration), this.currentTime = Math.min(this.currentTime, this.duration), e = this.duration / this.frames;
                    var t = Math.floor(this.currentTime / e);
                    t != n && (this.mesh.morphTargetInfluences[i] = 0, this.mesh.morphTargetInfluences[n] = 1, this.mesh.morphTargetInfluences[t] = 0, i = n, n = t), this.mesh.morphTargetInfluences[t] = this.currentTime % e / e, this.mesh.morphTargetInfluences[i] = 1 - this.mesh.morphTargetInfluences[t]
                }
            }
        }()
    }, THREE.CubeCamera = function (e, t, i) {
        THREE.Object3D.call(this);
        var r = new THREE.PerspectiveCamera(90, 1, e, t);
        r.up.set(0, -1, 0), r.lookAt(new THREE.Vector3(1, 0, 0)), this.add(r);
        var o = new THREE.PerspectiveCamera(90, 1, e, t);
        o.up.set(0, -1, 0), o.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(o);
        var a = new THREE.PerspectiveCamera(90, 1, e, t);
        a.up.set(0, 0, 1), a.lookAt(new THREE.Vector3(0, 1, 0)), this.add(a);
        var s = new THREE.PerspectiveCamera(90, 1, e, t);
        s.up.set(0, 0, -1), s.lookAt(new THREE.Vector3(0, -1, 0)), this.add(s);
        var l = new THREE.PerspectiveCamera(90, 1, e, t);
        l.up.set(0, -1, 0), l.lookAt(new THREE.Vector3(0, 0, 1)), this.add(l);
        var c = new THREE.PerspectiveCamera(90, 1, e, t);
        c.up.set(0, -1, 0), c.lookAt(new THREE.Vector3(0, 0, -1)), this.add(c), this.renderTarget = new THREE.WebGLRenderTargetCube(i, i, {
            format: THREE.RGBFormat,
            magFilter: THREE.LinearFilter,
            minFilter: THREE.LinearFilter
        }), this.updateCubeMap = function (e, t) {
            var i = this.renderTarget,
                n = i.generateMipmaps;
            i.generateMipmaps = !1, i.activeCubeFace = 0, e.render(t, r, i), i.activeCubeFace = 1, e.render(t, o, i), i.activeCubeFace = 2, e.render(t, a, i), i.activeCubeFace = 3, e.render(t, s, i), i.activeCubeFace = 4, e.render(t, l, i), i.generateMipmaps = n, i.activeCubeFace = 5, e.render(t, c, i)
        }
    }, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.CombinedCamera = function (e, t, i, n, r, o, a) {
        THREE.Camera.call(this), this.fov = i, this.left = -e / 2, this.right = e / 2, this.top = t / 2, this.bottom = -t / 2, this.cameraO = new THREE.OrthographicCamera(e / -2, e / 2, t / 2, t / -2, o, a), this.cameraP = new THREE.PerspectiveCamera(i, e / t, n, r), this.zoom = 1, this.toPerspective()
    }, THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype), THREE.CombinedCamera.prototype.toPerspective = function () {
        this.near = this.cameraP.near, this.far = this.cameraP.far, this.cameraP.fov = this.fov / this.zoom, this.cameraP.updateProjectionMatrix(), this.projectionMatrix = this.cameraP.projectionMatrix, this.inPerspectiveMode = !0, this.inOrthographicMode = !1
    }, THREE.CombinedCamera.prototype.toOrthographic = function () {
        var e = this.cameraP.aspect,
            t = (this.cameraP.near + this.cameraP.far) / 2;
        e = 2 * (t = Math.tan(this.fov / 2) * t) * e / 2, t /= this.zoom, e /= this.zoom;
        this.cameraO.left = -e, this.cameraO.right = e, this.cameraO.top = t, this.cameraO.bottom = -t, this.cameraO.updateProjectionMatrix(), this.near = this.cameraO.near, this.far = this.cameraO.far, this.projectionMatrix = this.cameraO.projectionMatrix, this.inPerspectiveMode = !1, this.inOrthographicMode = !0
    }, THREE.CombinedCamera.prototype.setSize = function (e, t) {
        this.cameraP.aspect = e / t, this.left = -e / 2, this.right = e / 2, this.top = t / 2, this.bottom = -t / 2
    }, THREE.CombinedCamera.prototype.setFov = function (e) {
        this.fov = e, this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
    }, THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
        this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic())
    }, THREE.CombinedCamera.prototype.setLens = function (e, t) {
        void 0 === t && (t = 24);
        var i = 2 * THREE.Math.radToDeg(Math.atan(t / (2 * e)));
        return this.setFov(i), i
    }, THREE.CombinedCamera.prototype.setZoom = function (e) {
        this.zoom = e, this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
    }, THREE.CombinedCamera.prototype.toFrontView = function () {
        this.rotation.x = 0, this.rotation.y = 0, this.rotation.z = 0, this.rotationAutoUpdate = !1
    }, THREE.CombinedCamera.prototype.toBackView = function () {
        this.rotation.x = 0, this.rotation.y = Math.PI, this.rotation.z = 0, this.rotationAutoUpdate = !1
    }, THREE.CombinedCamera.prototype.toLeftView = function () {
        this.rotation.x = 0, this.rotation.y = -Math.PI / 2, this.rotation.z = 0, this.rotationAutoUpdate = !1
    }, THREE.CombinedCamera.prototype.toRightView = function () {
        this.rotation.x = 0, this.rotation.y = Math.PI / 2, this.rotation.z = 0, this.rotationAutoUpdate = !1
    }, THREE.CombinedCamera.prototype.toTopView = function () {
        this.rotation.x = -Math.PI / 2, this.rotation.y = 0, this.rotation.z = 0, this.rotationAutoUpdate = !1
    }, THREE.CombinedCamera.prototype.toBottomView = function () {
        this.rotation.x = Math.PI / 2, this.rotation.y = 0, this.rotation.z = 0, this.rotationAutoUpdate = !1
    }, THREE.BoxGeometry = function (e, t, i, n, r, o) {
        function a(e, t, i, n, r, o, a, s) {
            var l, c = T.widthSegments,
                h = T.heightSegments,
                u = r / 2,
                f = o / 2,
                d = T.vertices.length;
            "x" === e && "y" === t || "y" === e && "x" === t ? l = "z" : "x" === e && "z" === t || "z" === e && "x" === t ? (l = "y", h = T.depthSegments) : ("z" === e && "y" === t || "y" === e && "z" === t) && (l = "x", c = T.depthSegments);
            var p = c + 1,
                m = h + 1,
                g = r / c,
                E = o / h,
                v = new THREE.Vector3;
            for (v[l] = 0 < a ? 1 : -1, r = 0; r < m; r++)
                for (o = 0; o < p; o++) {
                    var y = new THREE.Vector3;
                    y[e] = (o * g - u) * i, y[t] = (r * E - f) * n, y[l] = a, T.vertices.push(y)
                }
            for (r = 0; r < h; r++)
                for (o = 0; o < c; o++) f = o + p * r, e = o + p * (r + 1), t = o + 1 + p * (r + 1), i = o + 1 + p * r, n = new THREE.Vector2(o / c, 1 - r / h), a = new THREE.Vector2(o / c, 1 - (r + 1) / h), l = new THREE.Vector2((o + 1) / c, 1 - (r + 1) / h), u = new THREE.Vector2((o + 1) / c, 1 - r / h), (f = new THREE.Face3(f + d, e + d, i + d)).normal.copy(v), f.vertexNormals.push(v.clone(), v.clone(), v.clone()), f.materialIndex = s, T.faces.push(f), T.faceVertexUvs[0].push([n, a, u]), (f = new THREE.Face3(e + d, t + d, i + d)).normal.copy(v), f.vertexNormals.push(v.clone(), v.clone(), v.clone()), f.materialIndex = s, T.faces.push(f), T.faceVertexUvs[0].push([a.clone(), l, u.clone()])
        }
        THREE.Geometry.call(this);
        var T = this;
        this.width = e, this.height = t, this.depth = i, this.widthSegments = n || 1, this.heightSegments = r || 1, this.depthSegments = o || 1, e = this.width / 2, t = this.height / 2, i = this.depth / 2, a("z", "y", -1, -1, this.depth, this.height, e, 0), a("z", "y", 1, -1, this.depth, this.height, -e, 1), a("x", "z", 1, 1, this.width, this.depth, t, 2), a("x", "z", 1, -1, this.width, this.depth, -t, 3), a("x", "y", 1, -1, this.width, this.height, i, 4), a("x", "y", -1, -1, this.width, this.height, -i, 5), this.computeCentroids(), this.mergeVertices()
    }, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry = function (e, t, i, n) {
        THREE.Geometry.call(this), this.radius = e = e || 50, this.segments = t = void 0 !== t ? Math.max(3, t) : 8, this.thetaStart = i = void 0 !== i ? i : 0, this.thetaLength = n = void 0 !== n ? n : 2 * Math.PI;
        var r, o = [];
        r = new THREE.Vector3;
        var a = new THREE.Vector2(.5, .5);
        for (this.vertices.push(r), o.push(a), r = 0; r <= t; r++) {
            var s = new THREE.Vector3,
                l = i + r / t * n;
            s.x = e * Math.cos(l), s.y = e * Math.sin(l), this.vertices.push(s), o.push(new THREE.Vector2((s.x / e + 1) / 2, (s.y / e + 1) / 2))
        }
        for (i = new THREE.Vector3(0, 0, 1), r = 1; r <= t; r++) this.faces.push(new THREE.Face3(r, r + 1, 0, [i.clone(), i.clone(), i.clone()])), this.faceVertexUvs[0].push([o[r].clone(), o[r + 1].clone(), a.clone()]);
        this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
    }, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CubeGeometry = THREE.BoxGeometry, THREE.CylinderGeometry = function (e, t, i, n, r, o) {
        THREE.Geometry.call(this), this.radiusTop = e = void 0 !== e ? e : 20, this.radiusBottom = t = void 0 !== t ? t : 20, this.height = i = void 0 !== i ? i : 100, this.radialSegments = n = n || 8, this.heightSegments = r = r || 1, this.openEnded = o = void 0 !== o && o;
        var a, s, l = i / 2,
            c = [],
            h = [];
        for (s = 0; s <= r; s++) {
            var u = [],
                f = [],
                d = (m = s / r) * (t - e) + e;
            for (a = 0; a <= n; a++) {
                var p = a / n;
                (g = new THREE.Vector3).x = d * Math.sin(p * Math.PI * 2), g.y = -m * i + l, g.z = d * Math.cos(p * Math.PI * 2), this.vertices.push(g), u.push(this.vertices.length - 1), f.push(new THREE.Vector2(p, 1 - m))
            }
            c.push(u), h.push(f)
        }
        for (i = (t - e) / i, a = 0; a < n; a++)
            for (f = 0 !== e ? (u = this.vertices[c[0][a]].clone(), this.vertices[c[0][a + 1]].clone()) : (u = this.vertices[c[1][a]].clone(), this.vertices[c[1][a + 1]].clone()), u.setY(Math.sqrt(u.x * u.x + u.z * u.z) * i).normalize(), f.setY(Math.sqrt(f.x * f.x + f.z * f.z) * i).normalize(), s = 0; s < r; s++) {
                var m = c[s][a],
                    g = (d = c[s + 1][a], p = c[s + 1][a + 1], c[s][a + 1]),
                    E = u.clone(),
                    v = u.clone(),
                    y = f.clone(),
                    T = f.clone(),
                    b = h[s][a].clone(),
                    x = h[s + 1][a].clone(),
                    R = h[s + 1][a + 1].clone(),
                    w = h[s][a + 1].clone();
                this.faces.push(new THREE.Face3(m, d, g, [E, v, T])), this.faceVertexUvs[0].push([b, x, w]), this.faces.push(new THREE.Face3(d, p, g, [v.clone(), y, T.clone()])), this.faceVertexUvs[0].push([x.clone(), R, w.clone()])
            }
        if (!1 === o && 0 < e)
            for (this.vertices.push(new THREE.Vector3(0, l, 0)), a = 0; a < n; a++) m = c[0][a], d = c[0][a + 1], p = this.vertices.length - 1, E = new THREE.Vector3(0, 1, 0), v = new THREE.Vector3(0, 1, 0), y = new THREE.Vector3(0, 1, 0), b = h[0][a].clone(), x = h[0][a + 1].clone(), R = new THREE.Vector2(x.x, 0), this.faces.push(new THREE.Face3(m, d, p, [E, v, y])), this.faceVertexUvs[0].push([b, x, R]);
        if (!1 === o && 0 < t)
            for (this.vertices.push(new THREE.Vector3(0, -l, 0)), a = 0; a < n; a++) m = c[s][a + 1], d = c[s][a], p = this.vertices.length - 1, E = new THREE.Vector3(0, -1, 0), v = new THREE.Vector3(0, -1, 0), y = new THREE.Vector3(0, -1, 0), b = h[s][a + 1].clone(), x = h[s][a].clone(), R = new THREE.Vector2(x.x, 1), this.faces.push(new THREE.Face3(m, d, p, [E, v, y])), this.faceVertexUvs[0].push([b, x, R]);
        this.computeCentroids(), this.computeFaceNormals()
    }, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry = function (e, t) {
        void 0 !== e && (THREE.Geometry.call(this), e = e instanceof Array ? e : [e], this.shapebb = e[e.length - 1].getBoundingBox(), this.addShapeList(e, t), this.computeCentroids(), this.computeFaceNormals())
    }, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.addShapeList = function (e, t) {
        for (var i = e.length, n = 0; n < i; n++) this.addShape(e[n], t)
    }, THREE.ExtrudeGeometry.prototype.addShape = function (m, g) {
        function e(e, t, i) {
            return t || console.log("die"), t.clone().multiplyScalar(i).add(e)
        }

        function t(e, t, i) {
            var n = THREE.Math.sign,
                r = 1,
                o = (r = e.x - t.x, e.y - t.y),
                a = i.x - e.x,
                s = i.y - e.y,
                l = r * r + o * o;
            if (1e-10 < Math.abs(r * s - o * a)) {
                var c = Math.sqrt(l);
                n = Math.sqrt(a * a + s * s), l = t.x - o / c;
                if (t = t.y + r / c, (r = (i = l + r * (a = ((i.x - s / n - l) * s - (i.y + a / n - t) * a) / (r * s - o * a)) - e.x) * i + (e = t + o * a - e.y) * e) <= 2) return new THREE.Vector2(i, e);
                r = Math.sqrt(r / 2)
            } else e = !1, 1e-10 < r ? 1e-10 < a && (e = !0) : r < -1e-10 ? a < -1e-10 && (e = !0) : n(o) == n(s) && (e = !0), r = e ? (i = -o, e = r, Math.sqrt(l)) : (i = r, e = o, Math.sqrt(l / 2));
            return new THREE.Vector2(i / r, e / r)
        }

        function i(e, t) {
            var i, n;
            for (V = e.length; 0 <= --V;) {
                (n = (i = V) - 1) < 0 && (n = e.length - 1);
                var r = 0,
                    o = v + 2 * E;
                for (r = 0; r < o; r++) {
                    var a = e,
                        s = r,
                        l = o,
                        c = i,
                        h = n,
                        u = (u = t + i + (f = j * r)) + M,
                        f = (f = t + n + f) + M,
                        d = (d = t + n + (p = j * (r + 1))) + M,
                        p = (p = t + i + p) + M;
                    S.faces.push(new THREE.Face3(u, f, p, null, null, x)), S.faces.push(new THREE.Face3(f, d, p, null, null, x)), u = R.generateSideWallUV(S, m, a, g, u, f, d, p, s, l, c, h), S.faceVertexUvs[0].push([u[0], u[1], u[3]]), S.faceVertexUvs[0].push([u[1], u[2], u[3]])
                }
            }
        }

        function n(e, t, i) {
            S.vertices.push(new THREE.Vector3(e, t, i))
        }

        function r(e, t, i, n) {
            e += M, t += M, i += M, S.faces.push(new THREE.Face3(e, t, i, null, null, b)), e = n ? R.generateBottomUV(S, m, g, e, t, i) : R.generateTopUV(S, m, g, e, t, i), S.faceVertexUvs[0].push(e)
        }
        var o, a, s, l, c, h = void 0 !== g.amount ? g.amount : 100,
            u = void 0 !== g.bevelThickness ? g.bevelThickness : 6,
            f = void 0 !== g.bevelSize ? g.bevelSize : u - 2,
            E = void 0 !== g.bevelSegments ? g.bevelSegments : 3,
            d = void 0 === g.bevelEnabled || g.bevelEnabled,
            p = void 0 !== g.curveSegments ? g.curveSegments : 12,
            v = void 0 !== g.steps ? g.steps : 1,
            y = g.extrudePath,
            T = !1,
            b = g.material,
            x = g.extrudeMaterial,
            R = void 0 !== g.UVGenerator ? g.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
        y && (o = y.getSpacedPoints(v), d = !(T = !0), a = void 0 !== g.frames ? g.frames : new THREE.TubeGeometry.FrenetFrames(y, v, !1), s = new THREE.Vector3, l = new THREE.Vector3, c = new THREE.Vector3), d || (f = u = E = 0);
        var w, _, H, S = this,
            M = this.vertices.length,
            C = (p = (y = m.extractPoints(p)).shape, y.holes);
        if (y = !THREE.Shape.Utils.isClockWise(p)) {
            for (p = p.reverse(), _ = 0, H = C.length; _ < H; _++) w = C[_], THREE.Shape.Utils.isClockWise(w) && (C[_] = w.reverse());
            y = !1
        }
        var A = THREE.Shape.Utils.triangulateShape(p, C),
            P = p;
        for (_ = 0, H = C.length; _ < H; _++) w = C[_], p = p.concat(w);
        var L, D, z, k, O, F, j = p.length,
            U = A.length,
            V = (y = [], 0);
        for (L = (z = P.length) - 1, D = V + 1; V < z; V++, L++, D++) L === z && (L = 0), D === z && (D = 0), y[V] = t(P[V], P[L], P[D]);
        var N, B = [],
            I = y.concat();
        for (_ = 0, H = C.length; _ < H; _++) {
            for (w = C[_], N = [], V = 0, L = (z = w.length) - 1, D = V + 1; V < z; V++, L++, D++) L === z && (L = 0), D === z && (D = 0), N[V] = t(w[V], w[L], w[D]);
            B.push(N), I = I.concat(N)
        }
        for (L = 0; L < E; L++) {
            for (k = u * (1 - (z = L / E)), D = f * Math.sin(z * Math.PI / 2), V = 0, z = P.length; V < z; V++) n((O = e(P[V], y[V], D)).x, O.y, -k);
            for (_ = 0, H = C.length; _ < H; _++)
                for (w = C[_], N = B[_], V = 0, z = w.length; V < z; V++) n((O = e(w[V], N[V], D)).x, O.y, -k)
        }
        for (D = f, V = 0; V < j; V++) O = d ? e(p[V], I[V], D) : p[V], T ? (l.copy(a.normals[0]).multiplyScalar(O.x), s.copy(a.binormals[0]).multiplyScalar(O.y), c.copy(o[0]).add(l).add(s), n(c.x, c.y, c.z)) : n(O.x, O.y, 0);
        for (z = 1; z <= v; z++)
            for (V = 0; V < j; V++) O = d ? e(p[V], I[V], D) : p[V], T ? (l.copy(a.normals[z]).multiplyScalar(O.x), s.copy(a.binormals[z]).multiplyScalar(O.y), c.copy(o[z]).add(l).add(s), n(c.x, c.y, c.z)) : n(O.x, O.y, h / v * z);
        for (L = E - 1; 0 <= L; L--) {
            for (k = u * (1 - (z = L / E)), D = f * Math.sin(z * Math.PI / 2), V = 0, z = P.length; V < z; V++) n((O = e(P[V], y[V], D)).x, O.y, h + k);
            for (_ = 0, H = C.length; _ < H; _++)
                for (w = C[_], N = B[_], V = 0, z = w.length; V < z; V++) O = e(w[V], N[V], D), T ? n(O.x, O.y + o[v - 1].y, o[v - 1].x + k) : n(O.x, O.y, h + k)
        }! function () {
            if (d) {
                var e;
                for (e = 0 * j, V = 0; V < U; V++) r((F = A[V])[2] + e, F[1] + e, F[0] + e, !0);
                for (e = v + 2 * E, e *= j, V = 0; V < U; V++) r((F = A[V])[0] + e, F[1] + e, F[2] + e, !1)
            } else {
                for (V = 0; V < U; V++) r((F = A[V])[2], F[1], F[0], !0);
                for (V = 0; V < U; V++) r((F = A[V])[0] + j * v, F[1] + j * v, F[2] + j * v, !1)
            }
        }(),
        function () {
            var e = 0;
            for (i(P, e), e += P.length, _ = 0, H = C.length; _ < H; _++) i(w = C[_], e), e += w.length
        }()
    }, THREE.ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function (e, t, i, n, r, o) {
            return t = e.vertices[r].x, r = e.vertices[r].y, i = e.vertices[o].x, o = e.vertices[o].y, [new THREE.Vector2(e.vertices[n].x, e.vertices[n].y), new THREE.Vector2(t, r), new THREE.Vector2(i, o)]
        },
        generateBottomUV: function (e, t, i, n, r, o) {
            return this.generateTopUV(e, t, i, n, r, o)
        },
        generateSideWallUV: function (e, t, i, n, r, o, a, s, l, c, h, u) {
            t = e.vertices[r].x, i = e.vertices[r].y, r = e.vertices[r].z, n = e.vertices[o].x, l = e.vertices[o].y, o = e.vertices[o].z, c = e.vertices[a].x, h = e.vertices[a].y, a = e.vertices[a].z, u = e.vertices[s].x;
            var f = e.vertices[s].y;
            return e = e.vertices[s].z, Math.abs(i - l) < .01 ? [new THREE.Vector2(t, 1 - r), new THREE.Vector2(n, 1 - o), new THREE.Vector2(c, 1 - a), new THREE.Vector2(u, 1 - e)] : [new THREE.Vector2(i, 1 - r), new THREE.Vector2(l, 1 - o), new THREE.Vector2(h, 1 - a), new THREE.Vector2(f, 1 - e)]
        }
    }, THREE.ExtrudeGeometry.__v1 = new THREE.Vector2, THREE.ExtrudeGeometry.__v2 = new THREE.Vector2, THREE.ExtrudeGeometry.__v3 = new THREE.Vector2, THREE.ExtrudeGeometry.__v4 = new THREE.Vector2, THREE.ExtrudeGeometry.__v5 = new THREE.Vector2, THREE.ExtrudeGeometry.__v6 = new THREE.Vector2, THREE.ShapeGeometry = function (e, t) {
        THREE.Geometry.call(this), !1 == e instanceof Array && (e = [e]), this.shapebb = e[e.length - 1].getBoundingBox(), this.addShapeList(e, t), this.computeCentroids(), this.computeFaceNormals()
    }, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.addShapeList = function (e, t) {
        for (var i = 0, n = e.length; i < n; i++) this.addShape(e[i], t);
        return this
    }, THREE.ShapeGeometry.prototype.addShape = function (e, t) {
        void 0 === t && (t = {});
        var i, n, r, o = t.material,
            a = void 0 === t.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : t.UVGenerator,
            s = this.vertices.length,
            l = (i = e.extractPoints(void 0 !== t.curveSegments ? t.curveSegments : 12)).shape,
            c = i.holes;
        if (!THREE.Shape.Utils.isClockWise(l))
            for (l = l.reverse(), i = 0, n = c.length; i < n; i++) r = c[i], THREE.Shape.Utils.isClockWise(r) && (c[i] = r.reverse());
        var h = THREE.Shape.Utils.triangulateShape(l, c);
        for (i = 0, n = c.length; i < n; i++) r = c[i], l = l.concat(r);
        for (c = l.length, n = h.length, i = 0; i < c; i++) r = l[i], this.vertices.push(new THREE.Vector3(r.x, r.y, 0));
        for (i = 0; i < n; i++) l = (c = h[i])[0] + s, r = c[1] + s, c = c[2] + s, this.faces.push(new THREE.Face3(l, r, c, null, null, o)), this.faceVertexUvs[0].push(a.generateBottomUV(this, e, t, l, r, c))
    }, THREE.LatheGeometry = function (e, t, i, n) {
        THREE.Geometry.call(this), t = t || 12, i = i || 0, n = n || 2 * Math.PI;
        for (var r = 1 / (e.length - 1), o = 1 / t, a = 0, s = t; a <= s; a++)
            for (var l = i + a * o * n, c = Math.cos(l), h = Math.sin(l), u = (l = 0, e.length); l < u; l++) {
                var f = e[l];
                (d = new THREE.Vector3).x = c * f.x - h * f.y, d.y = h * f.x + c * f.y, d.z = f.z, this.vertices.push(d)
            }
        for (i = e.length, a = 0, s = t; a < s; a++)
            for (l = 0, u = e.length - 1; l < u; l++) {
                t = h = l + i * a, n = h + i;
                c = h + 1 + i, h = h + 1;
                var d, p = (f = a * o) + o,
                    m = (d = l * r) + r;
                this.faces.push(new THREE.Face3(t, n, h)), this.faceVertexUvs[0].push([new THREE.Vector2(f, d), new THREE.Vector2(p, d), new THREE.Vector2(f, m)]), this.faces.push(new THREE.Face3(n, c, h)), this.faceVertexUvs[0].push([new THREE.Vector2(p, d), new THREE.Vector2(p, m), new THREE.Vector2(f, m)])
            }
        this.mergeVertices(), this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry = function (e, t, i, n) {
        THREE.Geometry.call(this), this.width = e, this.height = t, this.widthSegments = i || 1, this.heightSegments = n || 1;
        var r = e / 2,
            o = t / 2,
            a = (i = this.widthSegments) + 1,
            s = (n = this.heightSegments) + 1,
            l = this.width / i,
            c = this.height / n,
            h = new THREE.Vector3(0, 0, 1);
        for (e = 0; e < s; e++)
            for (t = 0; t < a; t++) this.vertices.push(new THREE.Vector3(t * l - r, -(e * c - o), 0));
        for (e = 0; e < n; e++)
            for (t = 0; t < i; t++) {
                var u = t + a * e,
                    f = (r = t + a * (e + 1), o = t + 1 + a * (e + 1), s = t + 1 + a * e, l = new THREE.Vector2(t / i, 1 - e / n), c = new THREE.Vector2(t / i, 1 - (e + 1) / n), new THREE.Vector2((t + 1) / i, 1 - (e + 1) / n)),
                    d = new THREE.Vector2((t + 1) / i, 1 - e / n);
                (u = new THREE.Face3(u, r, s)).normal.copy(h), u.vertexNormals.push(h.clone(), h.clone(), h.clone()), this.faces.push(u), this.faceVertexUvs[0].push([l, c, d]), (u = new THREE.Face3(r, o, s)).normal.copy(h), u.vertexNormals.push(h.clone(), h.clone(), h.clone()), this.faces.push(u), this.faceVertexUvs[0].push([c.clone(), f, d.clone()])
            }
        this.computeCentroids()
    }, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry = function (e, t, i, n, r, o) {
        THREE.Geometry.call(this), e = e || 0, t = t || 50, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
        var a, s = [],
            l = e,
            c = (t - e) / (n = void 0 !== n ? Math.max(3, n) : 8);
        for (e = 0; e <= n; e++) {
            for (a = 0; a <= i; a++) {
                var h = new THREE.Vector3,
                    u = r + a / i * o;
                h.x = l * Math.cos(u), h.y = l * Math.sin(u), this.vertices.push(h), s.push(new THREE.Vector2((h.x / t + 1) / 2, (h.y / t + 1) / 2))
            }
            l += c
        }
        for (t = new THREE.Vector3(0, 0, 1), e = 0; e < n; e++)
            for (r = e * i, a = 0; a <= i; a++) o = (u = a + r) + e, c = u + i + e, h = u + i + 1 + e, this.faces.push(new THREE.Face3(o, c, h, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([s[o].clone(), s[c].clone(), s[h].clone()]), o = u + e, c = u + i + 1 + e, h = u + 1 + e, this.faces.push(new THREE.Face3(o, c, h, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([s[o].clone(), s[c].clone(), s[h].clone()]);
        this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, l)
    }, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry = function (e, t, i, n, r, o, a) {
        THREE.Geometry.call(this), this.radius = e = e || 50, this.widthSegments = t = Math.max(3, Math.floor(t) || 8), this.heightSegments = i = Math.max(2, Math.floor(i) || 6), this.phiStart = n = void 0 !== n ? n : 0, this.phiLength = r = void 0 !== r ? r : 2 * Math.PI, this.thetaStart = o = void 0 !== o ? o : 0, this.thetaLength = a = void 0 !== a ? a : Math.PI;
        var s, l, c = [],
            h = [];
        for (l = 0; l <= i; l++) {
            var u = [],
                f = [];
            for (s = 0; s <= t; s++) {
                var d = s / t,
                    p = l / i;
                (m = new THREE.Vector3).x = -e * Math.cos(n + d * r) * Math.sin(o + p * a), m.y = e * Math.cos(o + p * a), m.z = e * Math.sin(n + d * r) * Math.sin(o + p * a), this.vertices.push(m), u.push(this.vertices.length - 1), f.push(new THREE.Vector2(d, 1 - p))
            }
            c.push(u), h.push(f)
        }
        for (l = 0; l < this.heightSegments; l++)
            for (s = 0; s < this.widthSegments; s++) {
                t = c[l][s + 1], i = c[l][s], n = c[l + 1][s], r = c[l + 1][s + 1], o = this.vertices[t].clone().normalize(), a = this.vertices[i].clone().normalize();
                u = this.vertices[n].clone().normalize(), f = this.vertices[r].clone().normalize(), d = h[l][s + 1].clone(), p = h[l][s].clone();
                var m = h[l + 1][s].clone(),
                    g = h[l + 1][s + 1].clone();
                Math.abs(this.vertices[t].y) === this.radius ? (d.x = (d.x + p.x) / 2, this.faces.push(new THREE.Face3(t, n, r, [o, u, f])), this.faceVertexUvs[0].push([d, m, g])) : Math.abs(this.vertices[n].y) === this.radius ? (m.x = (m.x + g.x) / 2, this.faces.push(new THREE.Face3(t, i, n, [o, a, u])), this.faceVertexUvs[0].push([d, p, m])) : (this.faces.push(new THREE.Face3(t, i, r, [o, a, f])), this.faceVertexUvs[0].push([d, p, g]), this.faces.push(new THREE.Face3(i, n, r, [a.clone(), u, f.clone()])), this.faceVertexUvs[0].push([p.clone(), m, g.clone()]))
            }
        this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
    }, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TextGeometry = function (e, t) {
        t = t || {};
        var i = THREE.FontUtils.generateShapes(e, t);
        t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), THREE.ExtrudeGeometry.call(this, i, t)
    }, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), THREE.TorusGeometry = function (e, t, i, n, r) {
        for (THREE.Geometry.call(this), this.radius = e || 100, this.tube = t || 40, this.radialSegments = i || 8, this.tubularSegments = n || 6, this.arc = r || 2 * Math.PI, r = new THREE.Vector3, e = [], t = [], i = 0; i <= this.radialSegments; i++)
            for (n = 0; n <= this.tubularSegments; n++) {
                var o = n / this.tubularSegments * this.arc,
                    a = i / this.radialSegments * Math.PI * 2;
                r.x = this.radius * Math.cos(o), r.y = this.radius * Math.sin(o), (s = new THREE.Vector3).x = (this.radius + this.tube * Math.cos(a)) * Math.cos(o), s.y = (this.radius + this.tube * Math.cos(a)) * Math.sin(o), s.z = this.tube * Math.sin(a), this.vertices.push(s), e.push(new THREE.Vector2(n / this.tubularSegments, i / this.radialSegments)), t.push(s.clone().sub(r).normalize())
            }
        for (i = 1; i <= this.radialSegments; i++)
            for (n = 1; n <= this.tubularSegments; n++) {
                r = (this.tubularSegments + 1) * i + n - 1;
                o = (this.tubularSegments + 1) * (i - 1) + n - 1, a = (this.tubularSegments + 1) * (i - 1) + n;
                var s = (this.tubularSegments + 1) * i + n,
                    l = new THREE.Face3(r, o, s, [t[r].clone(), t[o].clone(), t[s].clone()]);
                this.faces.push(l), this.faceVertexUvs[0].push([e[r].clone(), e[o].clone(), e[s].clone()]), l = new THREE.Face3(o, a, s, [t[o].clone(), t[a].clone(), t[s].clone()]), this.faces.push(l), this.faceVertexUvs[0].push([e[o].clone(), e[a].clone(), e[s].clone()])
            }
        this.computeCentroids(), this.computeFaceNormals()
    }, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusKnotGeometry = function (e, t, i, n, r, o, a) {
        function s(e, t, i, n, r) {
            var o = Math.cos(e),
                a = Math.sin(e);
            return e *= t / i, o *= n * (2 + (t = Math.cos(e))) * .5, a = n * (2 + t) * a * .5, n = r * n * Math.sin(e) * .5, new THREE.Vector3(o, a, n)
        }
        for (THREE.Geometry.call(this), this.radius = e || 100, this.tube = t || 40, this.radialSegments = i || 64, this.tubularSegments = n || 8, this.p = r || 2, this.q = o || 3, this.heightScale = a || 1, this.grid = Array(this.radialSegments), i = new THREE.Vector3, n = new THREE.Vector3, r = new THREE.Vector3, e = 0; e < this.radialSegments; ++e)
            for (this.grid[e] = Array(this.tubularSegments), o = s(t = e / this.radialSegments * 2 * this.p * Math.PI, this.q, this.p, this.radius, this.heightScale), t = s(t + .01, this.q, this.p, this.radius, this.heightScale), i.subVectors(t, o), n.addVectors(t, o), r.crossVectors(i, n), n.crossVectors(r, i), r.normalize(), n.normalize(), t = 0; t < this.tubularSegments; ++t) {
                var l = t / this.tubularSegments * 2 * Math.PI;
                a = -this.tube * Math.cos(l);
                l = this.tube * Math.sin(l);
                (c = new THREE.Vector3).x = o.x + a * n.x + l * r.x, c.y = o.y + a * n.y + l * r.y, c.z = o.z + a * n.z + l * r.z, this.grid[e][t] = this.vertices.push(c) - 1
            }
        for (e = 0; e < this.radialSegments; ++e)
            for (t = 0; t < this.tubularSegments; ++t) {
                r = (e + 1) % this.radialSegments, o = (t + 1) % this.tubularSegments, i = this.grid[e][t], n = this.grid[r][t], r = this.grid[r][o], o = this.grid[e][o], a = new THREE.Vector2(e / this.radialSegments, t / this.tubularSegments);
                l = new THREE.Vector2((e + 1) / this.radialSegments, t / this.tubularSegments);
                var c = new THREE.Vector2((e + 1) / this.radialSegments, (t + 1) / this.tubularSegments),
                    h = new THREE.Vector2(e / this.radialSegments, (t + 1) / this.tubularSegments);
                this.faces.push(new THREE.Face3(i, n, o)), this.faceVertexUvs[0].push([a, l, h]), this.faces.push(new THREE.Face3(n, r, o)), this.faceVertexUvs[0].push([l.clone(), c, h.clone()])
            }
        this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry = function (e, t, i, n, r) {
        var o, a, s, l, c, h, u;
        for (THREE.Geometry.call(this), this.path = e, this.segments = t || 64, this.radius = i || 1, this.radialSegments = n || 8, this.closed = r || !1, this.grid = [], n = this.segments + 1, r = new THREE.Vector3, h = (t = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed)).normals, u = t.binormals, this.tangents = t.tangents, this.normals = h, this.binormals = u, t = 0; t < n; t++)
            for (this.grid[t] = [], i = t / (n - 1), c = e.getPointAt(i), o = h[t], a = u[t], i = 0; i < this.radialSegments; i++) s = i / this.radialSegments * 2 * Math.PI, l = -this.radius * Math.cos(s), s = this.radius * Math.sin(s), r.copy(c), r.x += l * o.x + s * a.x, r.y += l * o.y + s * a.y, r.z += l * o.z + s * a.z, this.grid[t][i] = this.vertices.push(new THREE.Vector3(r.x, r.y, r.z)) - 1;
        for (t = 0; t < this.segments; t++)
            for (i = 0; i < this.radialSegments; i++) r = this.closed ? (t + 1) % this.segments : t + 1, h = (i + 1) % this.radialSegments, e = this.grid[t][i], n = this.grid[r][i], r = this.grid[r][h], h = this.grid[t][h], u = new THREE.Vector2(t / this.segments, i / this.radialSegments), o = new THREE.Vector2((t + 1) / this.segments, i / this.radialSegments), a = new THREE.Vector2((t + 1) / this.segments, (i + 1) / this.radialSegments), l = new THREE.Vector2(t / this.segments, (i + 1) / this.radialSegments), this.faces.push(new THREE.Face3(e, n, h)), this.faceVertexUvs[0].push([u, o, l]), this.faces.push(new THREE.Face3(n, r, h)), this.faceVertexUvs[0].push([o.clone(), a, l.clone()]);
        this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.FrenetFrames = function (e, t, i) {
        new THREE.Vector3;
        var n = new THREE.Vector3;
        new THREE.Vector3;
        var r, o, a, s = [],
            l = [],
            c = [],
            h = new THREE.Vector3,
            u = new THREE.Matrix4;
        for (t += 1, this.tangents = s, this.normals = l, this.binormals = c, r = 0; r < t; r++) o = r / (t - 1), s[r] = e.getTangentAt(o), s[r].normalize();
        for (l[0] = new THREE.Vector3, c[0] = new THREE.Vector3, e = Number.MAX_VALUE, r = Math.abs(s[0].x), o = Math.abs(s[0].y), a = Math.abs(s[0].z), r <= e && (e = r, n.set(1, 0, 0)), o <= e && (e = o, n.set(0, 1, 0)), a <= e && n.set(0, 0, 1), h.crossVectors(s[0], n).normalize(), l[0].crossVectors(s[0], h), c[0].crossVectors(s[0], l[0]), r = 1; r < t; r++) l[r] = l[r - 1].clone(), c[r] = c[r - 1].clone(), h.crossVectors(s[r - 1], s[r]), 1e-4 < h.length() && (h.normalize(), n = Math.acos(THREE.Math.clamp(s[r - 1].dot(s[r]), -1, 1)), l[r].applyMatrix4(u.makeRotationAxis(h, n))), c[r].crossVectors(s[r], l[r]);
        if (i)
            for (n = Math.acos(THREE.Math.clamp(l[0].dot(l[t - 1]), -1, 1)), n /= t - 1, 0 < s[0].dot(h.crossVectors(l[0], l[t - 1])) && (n = -n), r = 1; r < t; r++) l[r].applyMatrix4(u.makeRotationAxis(s[r], n * r)), c[r].crossVectors(s[r], l[r])
    }, THREE.PolyhedronGeometry = function (e, t, i, n) {
        function f(e) {
            var t = e.normalize().clone();
            t.index = p.vertices.push(t) - 1;
            var i = Math.atan2(e.z, -e.x) / 2 / Math.PI + .5;
            return e = Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5, t.uv = new THREE.Vector2(i, 1 - e), t
        }

        function d(e, t, i) {
            var n = new THREE.Face3(e.index, t.index, i.index, [e.clone(), t.clone(), i.clone()]);
            n.centroid.add(e).add(t).add(i).divideScalar(3), p.faces.push(n), n = n.centroid, n = Math.atan2(n.z, -n.x), p.faceVertexUvs[0].push([o(e.uv, e, n), o(t.uv, t, n), o(i.uv, i, n)])
        }

        function r(e, t) {
            var i = Math.pow(2, t);
            Math.pow(4, t);
            for (var n = f(p.vertices[e.a]), r = f(p.vertices[e.b]), o = f(p.vertices[e.c]), a = [], s = 0; s <= i; s++) {
                a[s] = [];
                for (var l = f(n.clone().lerp(o, s / i)), c = f(r.clone().lerp(o, s / i)), h = i - s, u = 0; u <= h; u++) a[s][u] = 0 == u && s == i ? l : f(l.clone().lerp(c, u / h))
            }
            for (s = 0; s < i; s++)
                for (u = 0; u < 2 * (i - s) - 1; u++) n = Math.floor(u / 2), 0 == u % 2 ? d(a[s][n + 1], a[s + 1][n], a[s][n]) : d(a[s][n + 1], a[s + 1][n + 1], a[s + 1][n])
        }

        function o(e, t, i) {
            return i < 0 && 1 === e.x && (e = new THREE.Vector2(e.x - 1, e.y)), 0 === t.x && 0 === t.z && (e = new THREE.Vector2(i / 2 / Math.PI + .5, e.y)), e.clone()
        }
        THREE.Geometry.call(this), i = i || 1, n = n || 0;
        for (var p = this, a = 0, s = e.length; a < s; a++) f(new THREE.Vector3(e[a][0], e[a][1], e[a][2]));
        e = this.vertices;
        var l = [];
        for (a = 0, s = t.length; a < s; a++) {
            var c = e[t[a][0]],
                h = e[t[a][1]],
                u = e[t[a][2]];
            l[a] = new THREE.Face3(c.index, h.index, u.index, [c.clone(), h.clone(), u.clone()])
        }
        for (a = 0, s = l.length; a < s; a++) r(l[a], n);
        for (a = 0, s = this.faceVertexUvs[0].length; a < s; a++) n = (t = this.faceVertexUvs[0][a])[0].x, e = t[1].x, l = t[2].x, c = Math.max(n, Math.max(e, l)), h = Math.min(n, Math.min(e, l)), .9 < c && h < .1 && (n < .2 && (t[0].x += 1), e < .2 && (t[1].x += 1), l < .2 && (t[2].x += 1));
        for (a = 0, s = this.vertices.length; a < s; a++) this.vertices[a].multiplyScalar(i);
        this.mergeVertices(), this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, i)
    }, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.IcosahedronGeometry = function (e, t) {
        this.radius = e, this.detail = t;
        var i = (1 + Math.sqrt(5)) / 2;
        THREE.PolyhedronGeometry.call(this, [
            [-1, i, 0],
            [1, i, 0],
            [-1, -i, 0],
            [1, -i, 0],
            [0, -1, i],
            [0, 1, i],
            [0, -1, -i],
            [0, 1, -i],
            [i, 0, -1],
            [i, 0, 1],
            [-i, 0, -1],
            [-i, 0, 1]
        ], [
            [0, 11, 5],
            [0, 5, 1],
            [0, 1, 7],
            [0, 7, 10],
            [0, 10, 11],
            [1, 5, 9],
            [5, 11, 4],
            [11, 10, 2],
            [10, 7, 6],
            [7, 1, 8],
            [3, 9, 4],
            [3, 4, 2],
            [3, 2, 6],
            [3, 6, 8],
            [3, 8, 9],
            [4, 9, 5],
            [2, 4, 11],
            [6, 2, 10],
            [8, 6, 7],
            [9, 8, 1]
        ], e, t)
    }, THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.OctahedronGeometry = function (e, t) {
        THREE.PolyhedronGeometry.call(this, [
            [1, 0, 0],
            [-1, 0, 0],
            [0, 1, 0],
            [0, -1, 0],
            [0, 0, 1],
            [0, 0, -1]
        ], [
            [0, 2, 4],
            [0, 4, 3],
            [0, 3, 5],
            [0, 5, 2],
            [1, 2, 5],
            [1, 5, 3],
            [1, 3, 4],
            [1, 4, 2]
        ], e, t)
    }, THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TetrahedronGeometry = function (e, t) {
        THREE.PolyhedronGeometry.call(this, [
            [1, 1, 1],
            [-1, -1, 1],
            [-1, 1, -1],
            [1, -1, -1]
        ], [
            [2, 1, 0],
            [0, 3, 2],
            [1, 3, 0],
            [2, 3, 1]
        ], e, t)
    }, THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ParametricGeometry = function (e, t, i) {
        THREE.Geometry.call(this);
        var n, r, o, a, s, l, c, h, u = this.vertices,
            f = this.faces,
            d = this.faceVertexUvs[0],
            p = t + 1;
        for (n = 0; n <= i; n++)
            for (a = n / i, r = 0; r <= t; r++) o = e(o = r / t, a), u.push(o);
        for (n = 0; n < i; n++)
            for (r = 0; r < t; r++) u = (e = n * p + r) + 1, a = (n + 1) * p + r + 1, o = (n + 1) * p + r, s = new THREE.Vector2(r / t, n / i), l = new THREE.Vector2((r + 1) / t, n / i), c = new THREE.Vector2((r + 1) / t, (n + 1) / i), h = new THREE.Vector2(r / t, (n + 1) / i), f.push(new THREE.Face3(e, u, o)), d.push([s, l, h]), f.push(new THREE.Face3(u, a, o)), d.push([l.clone(), c, h.clone()]);
        this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.AxisHelper = function (e) {
        e = e || 1;
        var t = new THREE.Geometry;
        t.vertices.push(new THREE.Vector3, new THREE.Vector3(e, 0, 0), new THREE.Vector3, new THREE.Vector3(0, e, 0), new THREE.Vector3, new THREE.Vector3(0, 0, e)), t.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775)), e = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors
        }), THREE.Line.call(this, t, e, THREE.LinePieces)
    }, THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype), THREE.ArrowHelper = function (e, t, i, n, r, o) {
        THREE.Object3D.call(this), void 0 === n && (n = 16776960), void 0 === i && (i = 1), void 0 === r && (r = .2 * i), void 0 === o && (o = .2 * r), this.position = t, (t = new THREE.Geometry).vertices.push(new THREE.Vector3(0, 0, 0)), t.vertices.push(new THREE.Vector3(0, 1, 0)), this.line = new THREE.Line(t, new THREE.LineBasicMaterial({
            color: n
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), (t = new THREE.CylinderGeometry(0, .5, 1, 5, 1)).applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)), this.cone = new THREE.Mesh(t, new THREE.MeshBasicMaterial({
            color: n
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, o)
    }, THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.setDirection = function () {
        var t, i = new THREE.Vector3;
        return function (e) {
            .99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (i.set(e.z, 0, -e.x).normalize(), t = Math.acos(e.y), this.quaternion.setFromAxisAngle(i, t))
        }
    }(), THREE.ArrowHelper.prototype.setLength = function (e, t, i) {
        void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, e, 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
    }, THREE.ArrowHelper.prototype.setColor = function (e) {
        this.line.material.color.setHex(e), this.cone.material.color.setHex(e)
    }, THREE.BoxHelper = function (e) {
        var t = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, 1, 1), new THREE.Vector3(-1, -1, 1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, 1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, -1, -1)];
        this.vertices = t;
        var i = new THREE.Geometry;
        i.vertices.push(t[0], t[1], t[1], t[2], t[2], t[3], t[3], t[0], t[4], t[5], t[5], t[6], t[6], t[7], t[7], t[4], t[0], t[4], t[1], t[5], t[2], t[6], t[3], t[7]), THREE.Line.call(this, i, new THREE.LineBasicMaterial({
            color: 16776960
        }), THREE.LinePieces), void 0 !== e && this.update(e)
    }, THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype), THREE.BoxHelper.prototype.update = function (e) {
        null === (i = e.geometry).boundingBox && i.computeBoundingBox();
        var t = i.boundingBox.min,
            i = i.boundingBox.max,
            n = this.vertices;
        n[0].set(i.x, i.y, i.z), n[1].set(t.x, i.y, i.z), n[2].set(t.x, t.y, i.z), n[3].set(i.x, t.y, i.z), n[4].set(i.x, i.y, t.z), n[5].set(t.x, i.y, t.z), n[6].set(t.x, t.y, t.z), n[7].set(i.x, t.y, t.z), this.geometry.computeBoundingSphere(), this.geometry.verticesNeedUpdate = !0, this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
    }, THREE.BoundingBoxHelper = function (e, t) {
        var i = void 0 !== t ? t : 8947848;
        this.object = e, this.box = new THREE.Box3, THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
            color: i,
            wireframe: !0
        }))
    }, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.update = function () {
        this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
    }, THREE.CameraHelper = function (e) {
        function t(e, t, i) {
            n(e, i), n(t, i)
        }

        function n(e, t) {
            i.vertices.push(new THREE.Vector3), i.colors.push(new THREE.Color(t)), void 0 === o[e] && (o[e] = []), o[e].push(i.vertices.length - 1)
        }
        var i = new THREE.Geometry,
            r = new THREE.LineBasicMaterial({
                color: 16777215,
                vertexColors: THREE.FaceColors
            }),
            o = {};
        t("n1", "n2", 16755200), t("n2", "n4", 16755200), t("n4", "n3", 16755200), t("n3", "n1", 16755200), t("f1", "f2", 16755200), t("f2", "f4", 16755200), t("f4", "f3", 16755200), t("f3", "f1", 16755200), t("n1", "f1", 16755200), t("n2", "f2", 16755200), t("n3", "f3", 16755200), t("n4", "f4", 16755200), t("p", "n1", 16711680), t("p", "n2", 16711680), t("p", "n3", 16711680), t("p", "n4", 16711680), t("u1", "u2", 43775), t("u2", "u3", 43775), t("u3", "u1", 43775), t("c", "t", 16777215), t("p", "c", 3355443), t("cn1", "cn2", 3355443), t("cn3", "cn4", 3355443), t("cf1", "cf2", 3355443), t("cf3", "cf4", 3355443), THREE.Line.call(this, i, r, THREE.LinePieces), this.camera = e, this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }, THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype), THREE.CameraHelper.prototype.update = function () {
        var o = new THREE.Vector3,
            a = new THREE.Camera,
            s = new THREE.Projector;
        return function () {
            function e(e, t, i, n) {
                if (o.set(t, i, n), s.unprojectVector(o, a), void 0 !== (e = r.pointMap[e]))
                    for (t = 0, i = e.length; t < i; t++) r.geometry.vertices[e[t]].copy(o)
            }
            var r = this;
            a.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), this.geometry.verticesNeedUpdate = !0
        }
    }(), THREE.DirectionalLightHelper = function (e, t) {
        THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, t = t || 1;
        var i = new THREE.PlaneGeometry(t, t),
            n = new THREE.MeshBasicMaterial({
                wireframe: !0,
                fog: !1
            });
        n.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Mesh(i, n), this.add(this.lightPlane), (i = new THREE.Geometry).vertices.push(new THREE.Vector3), i.vertices.push(new THREE.Vector3), (n = new THREE.LineBasicMaterial({
            fog: !1
        })).color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(i, n), this.add(this.targetLine), this.update()
    }, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.DirectionalLightHelper.prototype.dispose = function () {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, THREE.DirectionalLightHelper.prototype.update = function () {
        var e = new THREE.Vector3,
            t = new THREE.Vector3,
            i = new THREE.Vector3;
        return function () {
            e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e), this.lightPlane.lookAt(i), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(i), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
        }
    }(), THREE.EdgesHelper = function (e, t) {
        var i = void 0 !== t ? t : 16777215,
            n = [0, 0],
            r = {},
            o = function (e, t) {
                return e - t
            },
            a = ["a", "b", "c"],
            s = new THREE.BufferGeometry;
        (l = e.geometry.clone()).mergeVertices(), l.computeFaceNormals();
        for (var l, c = l.vertices, h = 0, u = 0, f = (l = l.faces).length; u < f; u++)
            for (var d = l[u], p = 0; p < 3; p++) {
                n[0] = d[a[p]], n[1] = d[a[(p + 1) % 3]], n.sort(o);
                var m = n.toString();
                void 0 === r[m] ? (r[m] = {
                    vert1: n[0],
                    vert2: n[1],
                    face1: u,
                    face2: void 0
                }, h++) : r[m].face2 = u
            }
        for (m in s.addAttribute("position", Float32Array, 2 * h, 3), n = s.attributes.position.array, o = 0, r)(void 0 === (a = r[m]).face2 || l[a.face1].normal.dot(l[a.face2].normal) < .9999) && (h = c[a.vert1], n[o++] = h.x, n[o++] = h.y, n[o++] = h.z, h = c[a.vert2], n[o++] = h.x, n[o++] = h.y, n[o++] = h.z);
        THREE.Line.call(this, s, new THREE.LineBasicMaterial({
            color: i
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
    }, THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper = function (e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, t = new THREE.Geometry, i = 0;
        for (var r = this.object.geometry.faces.length; i < r; i++) t.vertices.push(new THREE.Vector3), t.vertices.push(new THREE.Vector3);
        THREE.Line.call(this, t, new THREE.LineBasicMaterial({
            color: e,
            linewidth: n
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
    }, THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper.prototype.update = function (e) {
        var s = new THREE.Vector3;
        return function (e) {
            this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld), e = this.geometry.vertices;
            for (var t = this.object.geometry.faces, i = this.object.matrixWorld, n = 0, r = t.length; n < r; n++) {
                var o = t[n];
                s.copy(o.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
                var a = 2 * n;
                e[a].copy(o.centroid).applyMatrix4(i), e[a + 1].addVectors(e[a], s)
            }
            return this.geometry.verticesNeedUpdate = !0, this
        }
    }(), THREE.GridHelper = function (e, t) {
        var i = new THREE.Geometry,
            n = new THREE.LineBasicMaterial({
                vertexColors: THREE.VertexColors
            });
        this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
        for (var r = -e; r <= e; r += t) {
            i.vertices.push(new THREE.Vector3(-e, 0, r), new THREE.Vector3(e, 0, r), new THREE.Vector3(r, 0, -e), new THREE.Vector3(r, 0, e));
            var o = 0 === r ? this.color1 : this.color2;
            i.colors.push(o, o, o, o)
        }
        THREE.Line.call(this, i, n, THREE.LinePieces)
    }, THREE.GridHelper.prototype = Object.create(THREE.Line.prototype), THREE.GridHelper.prototype.setColors = function (e, t) {
        this.color1.set(e), this.color2.set(t), this.geometry.colorsNeedUpdate = !0
    }, THREE.HemisphereLightHelper = function (e, t, i, n) {
        for (THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new THREE.Color, new THREE.Color], (e = new THREE.SphereGeometry(t, 4, 2)).applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2)), t = 0; t < 8; t++) e.faces[t].color = this.colors[t < 4 ? 0 : 1];
        t = new THREE.MeshBasicMaterial({
            vertexColors: THREE.FaceColors,
            wireframe: !0
        }), this.lightSphere = new THREE.Mesh(e, t), this.add(this.lightSphere), this.update()
    }, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.HemisphereLightHelper.prototype.dispose = function () {
        this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
    }, THREE.HemisphereLightHelper.prototype.update = function () {
        var e = new THREE.Vector3;
        return function () {
            this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
        }
    }(), THREE.PointLightHelper = function (e, t) {
        this.light = e, this.light.updateMatrixWorld();
        var i = new THREE.SphereGeometry(t, 4, 2),
            n = new THREE.MeshBasicMaterial({
                wireframe: !0,
                fog: !1
            });
        n.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, i, n), this.matrixWorld = this.light.matrixWorld, this.matrixAutoUpdate = !1
    }, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose()
    }, THREE.PointLightHelper.prototype.update = function () {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    }, THREE.SpotLightHelper = function (e) {
        THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, (e = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0)).applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
        var t = new THREE.MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
        this.cone = new THREE.Mesh(e, t), this.add(this.cone), this.update()
    }, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, THREE.SpotLightHelper.prototype.update = function () {
        var i = new THREE.Vector3,
            n = new THREE.Vector3;
        return function () {
            var e = this.light.distance ? this.light.distance : 1e4,
                t = e * Math.tan(this.light.angle);
            this.cone.scale.set(t, t, e), i.setFromMatrixPosition(this.light.matrixWorld), n.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(n.sub(i)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }
    }(), THREE.VertexNormalsHelper = function (e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, i = new THREE.Geometry;
        for (var r = 0, o = (e = e.geometry.faces).length; r < o; r++)
            for (var a = 0, s = e[r].vertexNormals.length; a < s; a++) i.vertices.push(new THREE.Vector3), i.vertices.push(new THREE.Vector3);
        THREE.Line.call(this, i, new THREE.LineBasicMaterial({
            color: t,
            linewidth: n
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
    }, THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexNormalsHelper.prototype.update = function (e) {
        var f = new THREE.Vector3;
        return function (e) {
            e = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
            for (var t = this.geometry.vertices, i = this.object.geometry.vertices, n = this.object.geometry.faces, r = this.object.matrixWorld, o = 0, a = 0, s = n.length; a < s; a++)
                for (var l = n[a], c = 0, h = l.vertexNormals.length; c < h; c++) {
                    var u = l.vertexNormals[c];
                    t[o].copy(i[l[e[c]]]).applyMatrix4(r), f.copy(u).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), f.add(t[o]), t[o += 1].copy(f), o += 1
                }
            return this.geometry.verticesNeedUpdate = !0, this
        }
    }(), THREE.VertexTangentsHelper = function (e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== i ? i : 255, n = void 0 !== n ? n : 1, i = new THREE.Geometry;
        for (var r = 0, o = (e = e.geometry.faces).length; r < o; r++)
            for (var a = 0, s = e[r].vertexTangents.length; a < s; a++) i.vertices.push(new THREE.Vector3), i.vertices.push(new THREE.Vector3);
        THREE.Line.call(this, i, new THREE.LineBasicMaterial({
            color: t,
            linewidth: n
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.update()
    }, THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexTangentsHelper.prototype.update = function (e) {
        var f = new THREE.Vector3;
        return function (e) {
            e = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0);
            for (var t = this.geometry.vertices, i = this.object.geometry.vertices, n = this.object.geometry.faces, r = this.object.matrixWorld, o = 0, a = 0, s = n.length; a < s; a++)
                for (var l = n[a], c = 0, h = l.vertexTangents.length; c < h; c++) {
                    var u = l.vertexTangents[c];
                    t[o].copy(i[l[e[c]]]).applyMatrix4(r), f.copy(u).transformDirection(r).multiplyScalar(this.size), f.add(t[o]), t[o += 1].copy(f), o += 1
                }
            return this.geometry.verticesNeedUpdate = !0, this
        }
    }(), THREE.WireframeHelper = function (e, t) {
        var i = void 0 !== t ? t : 16777215,
            n = [0, 0],
            r = {},
            o = function (e, t) {
                return e - t
            },
            a = ["a", "b", "c"],
            s = new THREE.BufferGeometry;
        if (e.geometry instanceof THREE.Geometry) {
            for (var l = e.geometry.vertices, c = e.geometry.faces, h = 0, u = new Uint32Array(6 * c.length), f = 0, d = c.length; f < d; f++)
                for (var p = c[f], m = 0; m < 3; m++) {
                    n[0] = p[a[m]], n[1] = p[a[(m + 1) % 3]], n.sort(o), void 0 === r[E = n.toString()] && (u[2 * h] = n[0], u[2 * h + 1] = n[1], r[E] = !0, h++)
                }
            for (s.addAttribute("position", Float32Array, 2 * h, 3), n = s.attributes.position.array, f = 0, d = h; f < d; f++)
                for (m = 0; m < 2; m++) h = l[u[2 * f + m]], n[(a = 6 * f + 3 * m) + 0] = h.x, n[a + 1] = h.y, n[a + 2] = h.z
        } else if (e.geometry instanceof THREE.BufferGeometry && void 0 !== e.geometry.attributes.index) {
            l = e.geometry.attributes.position.array, d = e.geometry.attributes.index.array, c = e.geometry.offsets, h = 0, u = new Uint32Array(2 * d.length), p = 0;
            for (var g = c.length; p < g; ++p) {
                m = c[p].start;
                for (var E = c[p].count, v = (a = c[p].index, f = m, m + E); f < v; f += 3)
                    for (m = 0; m < 3; m++) n[0] = a + d[f + m], n[1] = a + d[f + (m + 1) % 3], n.sort(o), void 0 === r[E = n.toString()] && (u[2 * h] = n[0], u[2 * h + 1] = n[1], r[E] = !0, h++)
            }
            for (s.addAttribute("position", Float32Array, 2 * h, 3), n = s.attributes.position.array, f = 0, d = h; f < d; f++)
                for (m = 0; m < 2; m++) a = 6 * f + 3 * m, h = 3 * u[2 * f + m], n[a + 0] = l[h], n[a + 1] = l[h + 1], n[a + 2] = l[h + 2]
        } else if (e.geometry instanceof THREE.BufferGeometry)
            for (u = (h = (l = e.geometry.attributes.position.array).length / 3) / 3, s.addAttribute("position", Float32Array, 2 * h, 3), n = s.attributes.position.array, f = 0, d = u; f < d; f++)
                for (m = 0; m < 3; m++) u = 9 * f + 3 * m, n[(a = 18 * f + 6 * m) + 0] = l[u], n[a + 1] = l[u + 1], n[a + 2] = l[u + 2], h = 9 * f + (m + 1) % 3 * 3, n[a + 3] = l[h], n[a + 4] = l[h + 1], n[a + 5] = l[h + 2];
        THREE.Line.call(this, s, new THREE.LineBasicMaterial({
            color: i
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
    }, THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype), THREE.ImmediateRenderObject = function () {
        THREE.Object3D.call(this), this.render = function (e) {}
    }, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare = function (e, t, i, n, r) {
        THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3, (this.customUpdateCallback = void 0) !== e && this.add(e, t, i, n, r)
    }, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.add = function (e, t, i, n, r, o) {
        void 0 === t && (t = -1), void 0 === i && (i = 0), void 0 === o && (o = 1), void 0 === r && (r = new THREE.Color(16777215)), void 0 === n && (n = THREE.NormalBlending), i = Math.min(i, Math.max(0, i)), this.lensFlares.push({
            texture: e,
            size: t,
            distance: i,
            x: 0,
            y: 0,
            z: 0,
            scale: 1,
            rotation: 1,
            opacity: o,
            color: r,
            blending: n
        })
    }, THREE.LensFlare.prototype.updateLensFlares = function () {
        var e, t, i = this.lensFlares.length,
            n = 2 * -this.positionScreen.x,
            r = 2 * -this.positionScreen.y;
        for (e = 0; e < i; e++)(t = this.lensFlares[e]).x = this.positionScreen.x + n * t.distance, t.y = this.positionScreen.y + r * t.distance, t.wantedRotation = t.x * Math.PI * .25, t.rotation += .25 * (t.wantedRotation - t.rotation)
    }, THREE.MorphBlendMesh = function (e, t) {
        THREE.Mesh.call(this, e, t), this.animationsMap = {}, this.animationsList = [];
        var i = this.geometry.morphTargets.length;
        this.createAnimation("__default", 0, i - 1, i / 1), this.setAnimationWeight("__default", 1)
    }, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.createAnimation = function (e, t, i, n) {
        t = {
            startFrame: t,
            endFrame: i,
            length: i - t + 1,
            fps: n,
            duration: (i - t) / n,
            lastFrame: 0,
            currentFrame: 0,
            active: !1,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: !1,
            mirroredLoop: !1
        }, this.animationsMap[e] = t, this.animationsList.push(t)
    }, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (e) {
        for (var t, i = /([a-z]+)(\d+)/, n = {}, r = this.geometry, o = 0, a = r.morphTargets.length; o < a; o++) {
            var s = r.morphTargets[o].name.match(i);
            if (s && 1 < s.length) {
                var l = s[1];
                n[l] || (n[l] = {
                    start: 1 / 0,
                    end: -1 / 0
                }), o < (s = n[l]).start && (s.start = o), o > s.end && (s.end = o), t || (t = l)
            }
        }
        for (l in n) s = n[l], this.createAnimation(l, s.start, s.end, e);
        this.firstAnimation = t
    }, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (e) {
        (e = this.animationsMap[e]) && (e.direction = 1, e.directionBackwards = !1)
    }, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (e) {
        (e = this.animationsMap[e]) && (e.direction = -1, e.directionBackwards = !0)
    }, THREE.MorphBlendMesh.prototype.setAnimationFPS = function (e, t) {
        var i = this.animationsMap[e];
        i && (i.fps = t, i.duration = (i.end - i.start) / i.fps)
    }, THREE.MorphBlendMesh.prototype.setAnimationDuration = function (e, t) {
        var i = this.animationsMap[e];
        i && (i.duration = t, i.fps = (i.end - i.start) / i.duration)
    }, THREE.MorphBlendMesh.prototype.setAnimationWeight = function (e, t) {
        var i = this.animationsMap[e];
        i && (i.weight = t)
    }, THREE.MorphBlendMesh.prototype.setAnimationTime = function (e, t) {
        var i = this.animationsMap[e];
        i && (i.time = t)
    }, THREE.MorphBlendMesh.prototype.getAnimationTime = function (e) {
        var t = 0;
        return (e = this.animationsMap[e]) && (t = e.time), t
    }, THREE.MorphBlendMesh.prototype.getAnimationDuration = function (e) {
        var t = -1;
        return (e = this.animationsMap[e]) && (t = e.duration), t
    }, THREE.MorphBlendMesh.prototype.playAnimation = function (e) {
        var t = this.animationsMap[e];
        t ? (t.time = 0, t.active = !0) : console.warn("animation[" + e + "] undefined")
    }, THREE.MorphBlendMesh.prototype.stopAnimation = function (e) {
        (e = this.animationsMap[e]) && (e.active = !1)
    }, THREE.MorphBlendMesh.prototype.update = function (e) {
        for (var t = 0, i = this.animationsList.length; t < i; t++) {
            var n = this.animationsList[t];
            if (n.active) {
                var r = n.duration / n.length;
                n.time += n.direction * e, n.mirroredLoop ? (n.time > n.duration || n.time < 0) && (n.direction *= -1, n.time > n.duration && (n.time = n.duration, n.directionBackwards = !0), n.time < 0 && (n.time = 0, n.directionBackwards = !1)) : (n.time %= n.duration, n.time < 0 && (n.time += n.duration));
                var o = n.startFrame + THREE.Math.clamp(Math.floor(n.time / r), 0, n.length - 1),
                    a = n.weight;
                o !== n.currentFrame && (this.morphTargetInfluences[n.lastFrame] = 0, this.morphTargetInfluences[n.currentFrame] = 1 * a, this.morphTargetInfluences[o] = 0, n.lastFrame = n.currentFrame, n.currentFrame = o), r = n.time % r / r, n.directionBackwards && (r = 1 - r), this.morphTargetInfluences[n.currentFrame] = r * a, this.morphTargetInfluences[n.lastFrame] = (1 - r) * a
            }
        }
    }, THREE.LensFlarePlugin = function () {
        function t(e, t) {
            var i = y.createProgram(),
                n = y.createShader(y.FRAGMENT_SHADER),
                r = y.createShader(y.VERTEX_SHADER),
                o = "precision " + t + " float;\n";
            return y.shaderSource(n, o + e.fragmentShader), y.shaderSource(r, o + e.vertexShader), y.compileShader(n), y.compileShader(r), y.attachShader(i, n), y.attachShader(i, r), y.linkProgram(i), i
        }
        var y, T, i, n, r, b, x, R, w, _, H, S, M;
        this.init = function (e) {
            y = e.context, i = (T = e).getPrecision(), n = new Float32Array(16), r = new Uint16Array(6), e = 0, n[e++] = -1, n[e++] = -1, n[e++] = 0, n[e++] = 0, n[e++] = 1, n[e++] = -1, n[e++] = 1, n[e++] = 0, n[e++] = 1, n[e++] = 1, n[e++] = 1, n[e++] = 1, n[e++] = -1, n[e++] = 1, n[e++] = 0, n[e++] = 1, e = 0, r[e++] = 0, r[e++] = 1, r[e++] = 2, r[e++] = 0, r[e++] = 2, r[e++] = 3, b = y.createBuffer(), x = y.createBuffer(), y.bindBuffer(y.ARRAY_BUFFER, b), y.bufferData(y.ARRAY_BUFFER, n, y.STATIC_DRAW), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, x), y.bufferData(y.ELEMENT_ARRAY_BUFFER, r, y.STATIC_DRAW), R = y.createTexture(), w = y.createTexture(), y.bindTexture(y.TEXTURE_2D, R), y.texImage2D(y.TEXTURE_2D, 0, y.RGB, 16, 16, 0, y.RGB, y.UNSIGNED_BYTE, null), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.NEAREST), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.NEAREST), y.bindTexture(y.TEXTURE_2D, w), y.texImage2D(y.TEXTURE_2D, 0, y.RGBA, 16, 16, 0, y.RGBA, y.UNSIGNED_BYTE, null), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.NEAREST), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.NEAREST), H = y.getParameter(y.MAX_VERTEX_TEXTURE_IMAGE_UNITS) <= 0 ? (_ = !1, t(THREE.ShaderFlares.lensFlare, i)) : (_ = !0, t(THREE.ShaderFlares.lensFlareVertexTexture, i)), M = {}, (S = {}).vertex = y.getAttribLocation(H, "position"), S.uv = y.getAttribLocation(H, "uv"), M.renderType = y.getUniformLocation(H, "renderType"), M.map = y.getUniformLocation(H, "map"), M.occlusionMap = y.getUniformLocation(H, "occlusionMap"), M.opacity = y.getUniformLocation(H, "opacity"), M.color = y.getUniformLocation(H, "color"), M.scale = y.getUniformLocation(H, "scale"), M.rotation = y.getUniformLocation(H, "rotation"), M.screenPosition = y.getUniformLocation(H, "screenPosition")
        }, this.render = function (e, t, i, n) {
            var r = (e = e.__webglFlares).length;
            if (r) {
                var o, a, s, l, c, h = new THREE.Vector3,
                    u = n / i,
                    f = .5 * i,
                    d = .5 * n,
                    p = 16 / n,
                    m = new THREE.Vector2(p * u, p),
                    g = new THREE.Vector3(1, 1, 0),
                    E = new THREE.Vector2(1, 1),
                    v = M;
                p = S;
                for (y.useProgram(H), y.enableVertexAttribArray(S.vertex), y.enableVertexAttribArray(S.uv), y.uniform1i(v.occlusionMap, 0), y.uniform1i(v.map, 1), y.bindBuffer(y.ARRAY_BUFFER, b), y.vertexAttribPointer(p.vertex, 2, y.FLOAT, !1, 16, 0), y.vertexAttribPointer(p.uv, 2, y.FLOAT, !1, 16, 8), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, x), y.disable(y.CULL_FACE), y.depthMask(!1), o = 0; o < r; o++)
                    if (p = 16 / n, m.set(p * u, p), l = e[o], h.set(l.matrixWorld.elements[12], l.matrixWorld.elements[13], l.matrixWorld.elements[14]), h.applyMatrix4(t.matrixWorldInverse), h.applyProjection(t.projectionMatrix), g.copy(h), E.x = g.x * f + f, E.y = g.y * d + d, _ || 0 < E.x && E.x < i && 0 < E.y && E.y < n)
                        for (y.activeTexture(y.TEXTURE1), y.bindTexture(y.TEXTURE_2D, R), y.copyTexImage2D(y.TEXTURE_2D, 0, y.RGB, E.x - 8, E.y - 8, 16, 16, 0), y.uniform1i(v.renderType, 0), y.uniform2f(v.scale, m.x, m.y), y.uniform3f(v.screenPosition, g.x, g.y, g.z), y.disable(y.BLEND), y.enable(y.DEPTH_TEST), y.drawElements(y.TRIANGLES, 6, y.UNSIGNED_SHORT, 0), y.activeTexture(y.TEXTURE0), y.bindTexture(y.TEXTURE_2D, w), y.copyTexImage2D(y.TEXTURE_2D, 0, y.RGBA, E.x - 8, E.y - 8, 16, 16, 0), y.uniform1i(v.renderType, 1), y.disable(y.DEPTH_TEST), y.activeTexture(y.TEXTURE1), y.bindTexture(y.TEXTURE_2D, R), y.drawElements(y.TRIANGLES, 6, y.UNSIGNED_SHORT, 0), l.positionScreen.copy(g), l.customUpdateCallback ? l.customUpdateCallback(l) : l.updateLensFlares(), y.uniform1i(v.renderType, 2), y.enable(y.BLEND), a = 0, s = l.lensFlares.length; a < s; a++) .001 < (c = l.lensFlares[a]).opacity && .001 < c.scale && (g.x = c.x, g.y = c.y, g.z = c.z, p = c.size * c.scale / n, m.x = p * u, m.y = p, y.uniform3f(v.screenPosition, g.x, g.y, g.z), y.uniform2f(v.scale, m.x, m.y), y.uniform1f(v.rotation, c.rotation), y.uniform1f(v.opacity, c.opacity), y.uniform3f(v.color, c.color.r, c.color.g, c.color.b), T.setBlending(c.blending, c.blendEquation, c.blendSrc, c.blendDst), T.setTexture(c.texture, 1), y.drawElements(y.TRIANGLES, 6, y.UNSIGNED_SHORT, 0));
                y.enable(y.CULL_FACE), y.enable(y.DEPTH_TEST), y.depthMask(!0)
            }
        }
    }, THREE.ShadowMapPlugin = function () {
        var p, m, g, E, v, y, T = new THREE.Frustum,
            b = new THREE.Matrix4,
            x = new THREE.Vector3,
            R = new THREE.Vector3,
            w = new THREE.Vector3;
        this.init = function (e) {
            p = e.context, m = e, e = THREE.ShaderLib.depthRGBA;
            var t = THREE.UniformsUtils.clone(e.uniforms);
            g = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: t
            }), E = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: t,
                morphTargets: !0
            }), v = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: t,
                skinning: !0
            }), y = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: t,
                morphTargets: !0,
                skinning: !0
            }), g._shadowPass = !0, E._shadowPass = !0, v._shadowPass = !0, y._shadowPass = !0
        }, this.render = function (e, t) {
            m.shadowMapEnabled && m.shadowMapAutoUpdate && this.update(e, t)
        }, this.update = function (e, t) {
            var i, n, r, o, a, s, l, c, h, u = [];
            for (o = 0, p.clearColor(1, 1, 1, 1), p.disable(p.BLEND), p.enable(p.CULL_FACE), p.frontFace(p.CCW), m.shadowMapCullFace === THREE.CullFaceFront ? p.cullFace(p.FRONT) : p.cullFace(p.BACK), m.setDepthTest(!0), i = 0, n = e.__lights.length; i < n; i++)
                if ((r = e.__lights[i]).castShadow)
                    if (r instanceof THREE.DirectionalLight && r.shadowCascade)
                        for (a = 0; a < r.shadowCascadeCount; a++) {
                            var f;
                            if (r.shadowCascadeArray[a]) f = r.shadowCascadeArray[a];
                            else {
                                h = r, l = a, (f = new THREE.DirectionalLight).isVirtual = !0, f.onlyShadow = !0, f.castShadow = !0, f.shadowCameraNear = h.shadowCameraNear, f.shadowCameraFar = h.shadowCameraFar, f.shadowCameraLeft = h.shadowCameraLeft, f.shadowCameraRight = h.shadowCameraRight, f.shadowCameraBottom = h.shadowCameraBottom, f.shadowCameraTop = h.shadowCameraTop, f.shadowCameraVisible = h.shadowCameraVisible, f.shadowDarkness = h.shadowDarkness, f.shadowBias = h.shadowCascadeBias[l], f.shadowMapWidth = h.shadowCascadeWidth[l], f.shadowMapHeight = h.shadowCascadeHeight[l], f.pointsWorld = [], f.pointsFrustum = [], c = f.pointsWorld, s = f.pointsFrustum;
                                for (var d = 0; d < 8; d++) c[d] = new THREE.Vector3, s[d] = new THREE.Vector3;
                                c = h.shadowCascadeNearZ[l], h = h.shadowCascadeFarZ[l], s[0].set(-1, -1, c), s[1].set(1, -1, c), s[2].set(-1, 1, c), s[3].set(1, 1, c), s[4].set(-1, -1, h), s[5].set(1, -1, h), s[6].set(-1, 1, h), s[7].set(1, 1, h), f.originalCamera = t, (s = new THREE.Gyroscope).position = r.shadowCascadeOffset, s.add(f), s.add(f.target), t.add(s), r.shadowCascadeArray[a] = f, console.log("Created virtualLight", f)
                            }
                            c = a, (h = (l = r).shadowCascadeArray[c]).position.copy(l.position), h.target.position.copy(l.target.position), h.lookAt(h.target), h.shadowCameraVisible = l.shadowCameraVisible, h.shadowDarkness = l.shadowDarkness, h.shadowBias = l.shadowCascadeBias[c], s = l.shadowCascadeNearZ[c], l = l.shadowCascadeFarZ[c], (h = h.pointsFrustum)[0].z = s, h[1].z = s, h[2].z = s, h[3].z = s, h[4].z = l, h[5].z = l, h[6].z = l, h[7].z = l, u[o] = f, o++
                        } else u[o] = r, o++;
            for (i = 0, n = u.length; i < n; i++) {
                if ((r = u[i]).shadowMap || (a = THREE.LinearFilter, m.shadowMapType === THREE.PCFSoftShadowMap && (a = THREE.NearestFilter), r.shadowMap = new THREE.WebGLRenderTarget(r.shadowMapWidth, r.shadowMapHeight, {
                        minFilter: a,
                        magFilter: a,
                        format: THREE.RGBAFormat
                    }), r.shadowMapSize = new THREE.Vector2(r.shadowMapWidth, r.shadowMapHeight), r.shadowMatrix = new THREE.Matrix4), !r.shadowCamera) {
                    if (r instanceof THREE.SpotLight) r.shadowCamera = new THREE.PerspectiveCamera(r.shadowCameraFov, r.shadowMapWidth / r.shadowMapHeight, r.shadowCameraNear, r.shadowCameraFar);
                    else {
                        if (!(r instanceof THREE.DirectionalLight)) {
                            console.error("Unsupported light type for shadow");
                            continue
                        }
                        r.shadowCamera = new THREE.OrthographicCamera(r.shadowCameraLeft, r.shadowCameraRight, r.shadowCameraTop, r.shadowCameraBottom, r.shadowCameraNear, r.shadowCameraFar)
                    }
                    e.add(r.shadowCamera), !0 === e.autoUpdate && e.updateMatrixWorld()
                }
                if (r.shadowCameraVisible && !r.cameraHelper && (r.cameraHelper = new THREE.CameraHelper(r.shadowCamera), r.shadowCamera.add(r.cameraHelper)), r.isVirtual && f.originalCamera == t) {
                    for (a = t, o = r.shadowCamera, s = r.pointsFrustum, h = r.pointsWorld, x.set(1 / 0, 1 / 0, 1 / 0), R.set(-1 / 0, -1 / 0, -1 / 0), l = 0; l < 8; l++)(c = h[l]).copy(s[l]), THREE.ShadowMapPlugin.__projector.unprojectVector(c, a), c.applyMatrix4(o.matrixWorldInverse), c.x < x.x && (x.x = c.x), c.x > R.x && (R.x = c.x), c.y < x.y && (x.y = c.y), c.y > R.y && (R.y = c.y), c.z < x.z && (x.z = c.z), c.z > R.z && (R.z = c.z);
                    o.left = x.x, o.right = R.x, o.top = R.y, o.bottom = x.y, o.updateProjectionMatrix()
                }
                for (o = r.shadowMap, s = r.shadowMatrix, (a = r.shadowCamera).position.setFromMatrixPosition(r.matrixWorld), w.setFromMatrixPosition(r.target.matrixWorld), a.lookAt(w), a.updateMatrixWorld(), a.matrixWorldInverse.getInverse(a.matrixWorld), r.cameraHelper && (r.cameraHelper.visible = r.shadowCameraVisible), r.shadowCameraVisible && r.cameraHelper.update(), s.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), s.multiply(a.projectionMatrix), s.multiply(a.matrixWorldInverse), b.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), T.setFromMatrix(b), m.setRenderTarget(o), m.clear(), r = 0, o = (h = e.__webglObjects).length; r < o; r++) s = (l = h[r]).object, l.render = !1, !s.visible || !s.castShadow || (s instanceof THREE.Mesh || s instanceof THREE.ParticleSystem) && s.frustumCulled && !T.intersectsObject(s) || (s._modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, s.matrixWorld), l.render = !0);
                for (r = 0, o = h.length; r < o; r++)(l = h[r]).render && (s = l.object, l = l.buffer, d = s.material instanceof THREE.MeshFaceMaterial ? s.material.materials[0] : s.material, c = void 0 !== s.geometry.morphTargets && 0 < s.geometry.morphTargets.length && d.morphTargets, d = s instanceof THREE.SkinnedMesh && d.skinning, c = s.customDepthMaterial ? s.customDepthMaterial : d ? c ? y : v : c ? E : g, l instanceof THREE.BufferGeometry ? m.renderBufferDirect(a, e.__lights, null, c, l, s) : m.renderBuffer(a, e.__lights, null, c, l, s));
                for (r = 0, o = (h = e.__webglObjectsImmediate).length; r < o; r++)(s = (l = h[r]).object).visible && s.castShadow && (s._modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, s.matrixWorld), m.renderImmediateObject(a, e.__lights, null, g, s))
            }
            i = m.getClearColor(), n = m.getClearAlpha(), p.clearColor(i.r, i.g, i.b, n), p.enable(p.BLEND), m.shadowMapCullFace === THREE.CullFaceFront && p.cullFace(p.BACK)
        }
    }, THREE.ShadowMapPlugin.__projector = new THREE.Projector, THREE.SpritePlugin = function () {
        var c, h, u, f, d, p, m, g, E, v, y, T, b, x, R, w, _, H, S, M, n, r, C, A, P;

        function L(e, t) {
            return e.z !== t.z ? t.z - e.z : t.id - e.id
        }
        this.init = function (e) {
            H = e.context, S = e, n = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), r = new Uint16Array([0, 1, 2, 0, 2, 3]), C = H.createBuffer(), A = H.createBuffer(), H.bindBuffer(H.ARRAY_BUFFER, C), H.bufferData(H.ARRAY_BUFFER, n, H.STATIC_DRAW), H.bindBuffer(H.ELEMENT_ARRAY_BUFFER, A), H.bufferData(H.ELEMENT_ARRAY_BUFFER, r, H.STATIC_DRAW), e = H.createProgram();
            var t = H.createShader(H.VERTEX_SHADER),
                i = H.createShader(H.FRAGMENT_SHADER);
            H.shaderSource(t, ["precision " + S.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), H.shaderSource(i, ["precision " + S.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), H.compileShader(t), H.compileShader(i), H.attachShader(e, t), H.attachShader(e, i), H.linkProgram(e), P = e, w = H.getAttribLocation(P, "position"), _ = H.getAttribLocation(P, "uv"), c = H.getUniformLocation(P, "uvOffset"), h = H.getUniformLocation(P, "uvScale"), u = H.getUniformLocation(P, "rotation"), f = H.getUniformLocation(P, "scale"), d = H.getUniformLocation(P, "color"), p = H.getUniformLocation(P, "map"), m = H.getUniformLocation(P, "opacity"), g = H.getUniformLocation(P, "modelViewMatrix"), E = H.getUniformLocation(P, "projectionMatrix"), v = H.getUniformLocation(P, "fogType"), y = H.getUniformLocation(P, "fogDensity"), T = H.getUniformLocation(P, "fogNear"), b = H.getUniformLocation(P, "fogFar"), x = H.getUniformLocation(P, "fogColor"), R = H.getUniformLocation(P, "alphaTest"), (e = document.createElement("canvas")).width = 8, e.height = 8, (t = e.getContext("2d")).fillStyle = "#ffffff", t.fillRect(0, 0, e.width, e.height), (M = new THREE.Texture(e)).needsUpdate = !0
        }, this.render = function (e, t, i, n) {
            if (n = (i = e.__webglSprites).length) {
                H.useProgram(P), H.enableVertexAttribArray(w), H.enableVertexAttribArray(_), H.disable(H.CULL_FACE), H.enable(H.BLEND), H.bindBuffer(H.ARRAY_BUFFER, C), H.vertexAttribPointer(w, 2, H.FLOAT, !1, 16, 0), H.vertexAttribPointer(_, 2, H.FLOAT, !1, 16, 8), H.bindBuffer(H.ELEMENT_ARRAY_BUFFER, A), H.uniformMatrix4fv(E, !1, t.projectionMatrix.elements), H.activeTexture(H.TEXTURE0), H.uniform1i(p, 0);
                var r = 0,
                    o = 0;
                (l = e.fog) ? (H.uniform3f(x, l.color.r, l.color.g, l.color.b), l instanceof THREE.Fog ? (H.uniform1f(T, l.near), H.uniform1f(b, l.far), H.uniform1i(v, 1), o = r = 1) : l instanceof THREE.FogExp2 && (H.uniform1f(y, l.density), H.uniform1i(v, 2), o = r = 2)) : (H.uniform1i(v, 0), o = r = 0);
                for (var a, s = [], l = 0; l < n; l++) !1 !== (a = i[l]).visible && (a._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, a.matrixWorld), a.z = -a._modelViewMatrix.elements[14]);
                for (i.sort(L), l = 0; l < n; l++) !1 !== (a = i[l]).visible && (t = a.material, H.uniform1f(R, t.alphaTest), H.uniformMatrix4fv(g, !1, a._modelViewMatrix.elements), s[0] = a.scale.x, s[1] = a.scale.y, r !== (a = e.fog && t.fog ? o : 0) && (H.uniform1i(v, a), r = a), null !== t.map ? (H.uniform2f(c, t.map.offset.x, t.map.offset.y), H.uniform2f(h, t.map.repeat.x, t.map.repeat.y)) : (H.uniform2f(c, 0, 0), H.uniform2f(h, 1, 1)), H.uniform1f(m, t.opacity), H.uniform3f(d, t.color.r, t.color.g, t.color.b), H.uniform1f(u, t.rotation), H.uniform2fv(f, s), S.setBlending(t.blending, t.blendEquation, t.blendSrc, t.blendDst), S.setDepthTest(t.depthTest), S.setDepthWrite(t.depthWrite), t.map && t.map.image && t.map.image.width ? S.setTexture(t.map, 0) : S.setTexture(M, 0), H.drawElements(H.TRIANGLES, 6, H.UNSIGNED_SHORT, 0));
                H.enable(H.CULL_FACE)
            }
        }
    }, THREE.DepthPassPlugin = function () {
        this.enabled = !1, this.renderTarget = null;
        var c, h, u, f, d, p, m = new THREE.Frustum,
            g = new THREE.Matrix4;
        this.init = function (e) {
            c = e.context, h = e, e = THREE.ShaderLib.depthRGBA;
            var t = THREE.UniformsUtils.clone(e.uniforms);
            u = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: t
            }), f = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: t,
                morphTargets: !0
            }), d = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: t,
                skinning: !0
            }), p = new THREE.ShaderMaterial({
                fragmentShader: e.fragmentShader,
                vertexShader: e.vertexShader,
                uniforms: t,
                morphTargets: !0,
                skinning: !0
            }), u._shadowPass = !0, f._shadowPass = !0, d._shadowPass = !0, p._shadowPass = !0
        }, this.render = function (e, t) {
            this.enabled && this.update(e, t)
        }, this.update = function (e, t) {
            var i, n, r, o, a, s, l;
            for (c.clearColor(1, 1, 1, 1), c.disable(c.BLEND), h.setDepthTest(!0), !0 === e.autoUpdate && e.updateMatrixWorld(), t.matrixWorldInverse.getInverse(t.matrixWorld), g.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), m.setFromMatrix(g), h.setRenderTarget(this.renderTarget), h.clear(), i = 0, n = (s = e.__webglObjects).length; i < n; i++) a = (r = s[i]).object, r.render = !1, !a.visible || (a instanceof THREE.Mesh || a instanceof THREE.ParticleSystem) && a.frustumCulled && !m.intersectsObject(a) || (a._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, a.matrixWorld), r.render = !0);
            for (i = 0, n = s.length; i < n; i++)(r = s[i]).render && (a = r.object, r = r.buffer, a instanceof THREE.ParticleSystem && !a.customDepthMaterial || ((l = a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[0] : a.material) && h.setMaterialFaces(a.material), o = 0 < a.geometry.morphTargets.length && l.morphTargets, l = a instanceof THREE.SkinnedMesh && l.skinning, o = a.customDepthMaterial ? a.customDepthMaterial : l ? o ? p : d : o ? f : u, r instanceof THREE.BufferGeometry ? h.renderBufferDirect(t, e.__lights, null, o, r, a) : h.renderBuffer(t, e.__lights, null, o, r, a)));
            for (i = 0, n = (s = e.__webglObjectsImmediate).length; i < n; i++)(a = (r = s[i]).object).visible && (a._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, a.matrixWorld), h.renderImmediateObject(t, e.__lights, null, u, a));
            i = h.getClearColor(), n = h.getClearAlpha(), c.clearColor(i.r, i.g, i.b, n), c.enable(c.BLEND)
        }
    }, THREE.ShaderFlares = {
        lensFlareVertexTexture: {
            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
            fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
        },
        lensFlare: {
            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
            fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
        }
    },
    function () {
        var s = [].slice;
        null == this.ParticleSaga && (this.ParticleSaga = {}), ParticleSaga.Utils = function () {
            function e() {}
            return e.extend = function () {
                var e, t, i, n, r, o, a;
                for (n = arguments[0], o = 0, a = (i = 2 <= arguments.length ? s.call(arguments, 1) : []).length; o < a; o++)
                    for (e in t = i[o]) r = t[e], n[e] = r
            }, e
        }()
    }.call(this),
    function () {
        null == this.ParticleSaga && (this.ParticleSaga = {}), ParticleSaga.VertexSort = {
            topToBottom: function (e, t) {
                return e.y < t.y ? 1 : e.y > t.y ? -1 : 0
            },
            bottomToTop: function (e, t) {
                return e.y < t.y ? -1 : e.y > t.y ? 1 : 0
            },
            leftToRight: function (e, t) {
                return e.x < t.x ? -1 : e.x > t.x ? 1 : 0
            },
            rightToLeft: function (e, t) {
                return e.x < t.x ? 1 : e.x > t.x ? -1 : 0
            },
            backToFront: function (e, t) {
                return e.z < t.z ? -1 : e.z > t.z ? 1 : 0
            },
            frontToBack: function (e, t) {
                return e.z < t.z ? 1 : e.z > t.z ? -1 : 0
            },
            randomish: function (e, t) {
                var i;
                return (i = Math.random()) < .33 ? 1 : i < .66 ? -1 : 0
            }
        }
    }.call(this),
    function () {
        var t = function (e, t) {
            return function () {
                return e.apply(t, arguments)
            }
        };
        null == this.ParticleSaga && (this.ParticleSaga = {}), ParticleSaga.ParticlePool = function () {
            function e(e) {
                this.setRotationY = t(this.setRotationY, this), this.getRotationY = t(this.getRotationY, this), this.morph = t(this.morph, this), this.nextIndexForPool = t(this.nextIndexForPool, this), this.makeRandomVertex = t(this.makeRandomVertex, this), this.getParticles = t(this.getParticles, this), this.createParticles = t(this.createParticles, this), this.resize = t(this.resize, this), this.setTarget = t(this.setTarget, this), this.destroy = t(this.destroy, this), this.particles, this.respondingToMouse = !1, this.morphing = !1, this.morphStartTime, this.currentTargetIndex, this.targets = [], this.halfW = 0, this.halfH = 0, this.halfZ = 0, this.opts = {
                    numFloatingParticles: 40,
                    numParticles: 1e4,
                    particleRevertDelay: .008,
                    revertDuration: 500,
                    sizeAttenuation: !0
                }, ParticleSaga.Utils.extend(this.opts, e)
            }
            return e.prototype.init = function () {
                return this.createParticles()
            }, e.prototype.destroy = function () {
                return this.particles.geometry.dispose(), this.particles.material.dispose(), this.particles = null, this.opts = null
            }, e.prototype.setTarget = function (e, t) {
                var i, n, r, o, a, s, l, c, h, u;
                for (null == t && (t = !0), e = e.clone(), this.particles.material.size = e.material.size, r = c = 0, h = (u = this.particles.geometry.vertices).length; c < h; r = ++c) l = u[r], n = t ? this.opts.revertDuration : 0, l.userData.morph.duration = n, l.userData.morph.delay = r * this.opts.particleRevertDelay, l.userData.prevV = l.clone(), l.userData.prevC = this.particles.geometry.colors[r].clone(), a = this.nextIndexForPool(r, e), o = e.geometry.vertices[a], l.userData.nextV = o.clone(), l.userData.alwaysFloating && (s = this.makeRandomVertex(), l.userData.nextV.set(s.x, s.y, s.z)), (i = o.userData.color) || (i.r = i.b = i.g = 0), l.userData.nextC.setRGB(i.r, i.g, i.b);
                return this.morphStartTime = new Date, this.morphing = !0
            }, e.prototype.resize = function (e, t, i) {
                this.halfW = e, this.halfH = t, this.halfZ = i
            }, e.prototype.createParticles = function () {
                var e, t, i, n, r, o, a;
                for (t = new THREE.Geometry, 0 < this.opts.numFloatingParticles && (e = Math.floor(this.opts.numParticles / this.opts.numFloatingParticles)), i = o = 0, a = this.opts.numParticles; o < a; i = o += 1) t.vertices.push(new THREE.Vector3(0, 0, 0)), null != e && (n = i % e == 0), t.vertices[i].userData = {
                    alwaysFloating: n,
                    prevV: t.vertices[i].clone(),
                    nextV: t.vertices[i].clone(),
                    prevC: new THREE.Color(.066, .066, .066),
                    nextC: new THREE.Color(.066, .066, .066),
                    morph: {
                        delay: 0,
                        duration: 0
                    }
                }, t.colors.push(new THREE.Color(.066, .066, .066));
                return r = new THREE.ParticleSystemMaterial({
                    vertexColors: !0,
                    transparent: !0,
                    depthTest: !1,
                    sizeAttenuation: this.opts.sizeAttenuation
                }), this.particles = new THREE.ParticleSystem(t, r), this.particles.sortParticles = !1
            }, e.prototype.getParticles = function () {
                return this.particles
            }, e.prototype.makeRandomVertex = function () {
                var e;
                return (e = new THREE.Vector3(0, 0, 0)).x = 2 * Math.random() * this.halfW - this.halfW, e.y = 2 * Math.random() * this.halfH - this.halfH, e.z = 2 * Math.random() * this.halfZ / 3 - this.halfZ / 3, e
            }, e.prototype.nextIndexForPool = function (e, t) {
                var i;
                return i = t.geometry.vertices.length / this.opts.numParticles, Math.floor(e * i)
            }, e.prototype.morph = function () {
                var e, t, i, n, r, o, a, s, l, c, h, u, f, d;
                for (i = new Date - this.morphStartTime, t = !0, r = u = 0, f = (d = this.particles.geometry.vertices).length; u < f; r = ++u) o = 1, 0 < (s = d[r]).userData.morph.duration && (o = Math.max(0, i - s.userData.morph.delay), o = Math.min(1, o / s.userData.morph.duration), o = 1 - --o * o * o * o), a = s.userData.prevC.r + o * (s.userData.nextC.r - s.userData.prevC.r), n = s.userData.prevC.g + o * (s.userData.nextC.g - s.userData.prevC.g), e = s.userData.prevC.b + o * (s.userData.nextC.b - s.userData.prevC.b), this.particles.geometry.colors[r].setRGB(a, n, e), l = s.userData.prevV.x + o * (s.userData.nextV.x - s.userData.prevV.x), c = s.userData.prevV.y + o * (s.userData.nextV.y - s.userData.prevV.y), h = s.userData.prevV.z + o * (s.userData.nextV.z - s.userData.prevV.z), s.set(l, c, h), o < 1 && (t = !1);
                return t && (this.morphing = !1), this.particles.geometry.verticesNeedUpdate = !0, this.particles.geometry.colorsNeedUpdate = !0
            }, e.prototype.getRotationY = function () {
                return this.particles.rotation.y
            }, e.prototype.setRotationY = function (e) {
                return this.particles.rotation.y = e
            }, e
        }()
    }.call(this),
    function () {
        var n = function (e, t) {
            return function () {
                return e.apply(t, arguments)
            }
        };
        null == this.ParticleSaga && (this.ParticleSaga = {}), ParticleSaga.Scene = function () {
            function e(e, t, i) {
                this.context = null != e ? e : document.body, this.targetData = null != t ? t : [], this.setSceneMouseRotation = n(this.setSceneMouseRotation, this), this.onMouseMove = n(this.onMouseMove, this), this.render = n(this.render, this), this.setupPool = n(this.setupPool, this), this.onTargetsReady = n(this.onTargetsReady, this), this.onTargetLoad = n(this.onTargetLoad, this), this.loadTarget = n(this.loadTarget, this), this.load = n(this.load, this), this.setupScene = n(this.setupScene, this), this.animate = n(this.animate, this), this.stop = n(this.stop, this), this.resize = n(this.resize, this), this.stopSlideshow = n(this.stopSlideshow, this), this.startSlideshow = n(this.startSlideshow, this), this.resetSlideshow = n(this.resetSlideshow, this), this.prevTarget = n(this.prevTarget, this), this.nextTarget = n(this.nextTarget, this), this.setTarget = n(this.setTarget, this), this.destroy = n(this.destroy, this), this.camera, this.scene, this.renderer, this.raf, this.pool, this.respondingToMouse = !1, this.sceneReady = !1, this.numTargetsLoaded = 0, this.currentTargetIndex, this.targets = [], this.halfW = this.context.offsetWidth / 2, this.halfH = this.context.offsetHeight / 2, this.mouseX = 0, this.destinationSceneRotationY = 0, this.dirty = !0, this.slideshowInterval = null, this.onAssetsLoad = null, this.opts = {
                    fov: 45,
                    maxMouseRotation: Math.PI / 6,
                    mouseRotationFriction: .2,
                    numFloatingParticles: 1e3,
                    numParticles: 1e4,
                    particleRevertDelay: .01,
                    revertDuration: 1500,
                    sizeAttenuation: !0,
                    slideshowDuration: 5e3,
                    sort: null
                }, ParticleSaga.Utils.extend(this.opts, i), this.setupScene()
            }
            return e.prototype.destroy = function () {
                var e, t, i, n, r;
                for (this.stop(), window.removeEventListener("resize", this.resize), document.removeEventListener("mousemove", this.onMouseMove), e = t = this.scene.children.length - 1; 0 <= t; e = t += -1) this.scene.children[e].geometry.dispose(), this.scene.children[e].material.dispose(), this.scene.remove(this.scene.children[e]);
                for (i = 0, n = (r = this.targets).length; i < n; i++) r[i].destroy();
                return this.renderer = null, this.scene = null, this.camera = null, this.pool.destroy(), this.pool = null, this.targets = null, this.opts = null
            }, e.prototype.setTarget = function (e, t) {
                var i;
                if (null == t && (t = !0), this.currentTargetIndex = e, this.sceneReady && void 0 !== this.currentTargetIndex) return this.targets[this.currentTargetIndex].opts.respondsToMouse ? (this.respondingToMouse = !0, this.setSceneMouseRotation(this.mouseX)) : (this.respondingToMouse = !1, this.setSceneMouseRotation(this.halfW)), i = this.targets[e].getParticles(), this.pool.setTarget(i, t)
            }, e.prototype.nextTarget = function (e) {
                var t;
                return null == e && (e = !0), this.resetSlideshow(), t = this.currentTargetIndex, ++t >= this.targets.length && (t = 0), this.setTarget(t, e)
            }, e.prototype.prevTarget = function (e) {
                var t;
                return null == e && (e = !0), this.resetSlideshow(), t = this.currentTargetIndex, --t < 0 && (t = this.targets.length - 1), this.setTarget(t, e)
            }, e.prototype.resetSlideshow = function () {
                if (null != this.slideshowInterval) return this.startSlideshow()
            }, e.prototype.startSlideshow = function () {
                return clearInterval(this.slideshowInterval), this.slideshowInterval = setInterval(this.nextTarget, this.opts.slideshowDuration)
            }, e.prototype.stopSlideshow = function () {
                return clearInterval(this.slideshowInterval), this.slideshowInterval = null
            }, e.prototype.resize = function () {
                var e, t, i, n;
                for (this.dirty = !0, this.halfW = this.context.offsetWidth / 2, this.halfH = this.context.offsetHeight / 2, this.camera.aspect = 2 * this.halfW / (2 * this.halfH), this.camera.updateProjectionMatrix(), this.camera.position.z = 2 * this.halfH / (2 * Math.tan(this.opts.fov / 2 * (Math.PI / 180))), this.renderer.setSize(2 * this.halfW, 2 * this.halfH), this.pool.resize(this.halfW, this.halfH, this.camera.position.z), e = t = 0, i = (n = this.targets).length; t < i; e = ++t) n[e].resize();
                return this.setTarget(this.currentTargetIndex, !1)
            }, e.prototype.stop = function () {
                return cancelAnimationFrame(this.raf)
            }, e.prototype.animate = function () {
                if (this.sceneReady) return this.raf = requestAnimationFrame(this.animate), this.render()
            }, e.prototype.setupScene = function () {
                return this.camera = new THREE.PerspectiveCamera(this.opts.fov, this.halfW / this.halfH, 1, 2e3), this.camera.position.z = 2 * this.halfH / (2 * Math.tan(this.opts.fov / 2 * (Math.PI / 180))), this.scene = new THREE.Scene, this.renderer = new THREE.WebGLRenderer({
                    antialias: !0,
                    alpha: !0
                }), this.renderer.setClearColor(0, 0), this.renderer.setSize(2 * this.halfW, 2 * this.halfH), this.context.appendChild(this.renderer.domElement)
            }, e.prototype.load = function (e) {
                var t, i, n, r, o;
                for (this.onAssetsLoad = e, o = [], i = 0, n = (r = this.targetData).length; i < n; i++) t = r[i], o.push(this.loadTarget(t, this.onTargetLoad));
                return o
            }, e.prototype.loadTarget = function (e, t) {
                var i;
                return null == e.container && (e.container = this.context), null == e.options && (e.options = {}), e.type !== ParticleSaga.ModelTarget && (e.options.numParticles = this.opts.numParticles), e.options.sort = this.opts.sort, i = new e.type(e, e.options), this.targets.push(i), i.init(), i.load(t), this.resetSlideshow()
            }, e.prototype.onTargetLoad = function () {
                if (this.numTargetsLoaded++, 0 < this.numTargetsLoaded && this.numTargetsLoaded === this.targetData.length) return this.onTargetsReady()
            }, e.prototype.onTargetsReady = function () {
                if (this.setupPool(), window.addEventListener("resize", this.resize), this.animate(), "function" == typeof this.onAssetsLoad) return this.onAssetsLoad()
            }, e.prototype.setupPool = function () {
                if (this.pool = new ParticleSaga.ParticlePool(this.opts), this.pool.resize(this.halfW, this.halfH, this.camera.position.z), this.pool.init(), this.scene.add(this.pool.getParticles()), this.sceneReady = !0, null != this.currentTargetIndex) return this.setTarget(this.currentTargetIndex)
            }, e.prototype.render = function () {
                var e;
                if (e = this.pool.getRotationY(), this.pool.setRotationY(this.pool.getRotationY() + .002), (e !== this.pool.getRotationY() || this.pool.morphing) && (this.dirty = !0), this.pool.morphing && this.pool.morph(), this.dirty) return this.dirty = !1, this.renderer.render(this.scene, this.camera)
            }, e.prototype.onMouseMove = function (e) {}, e.prototype.setSceneMouseRotation = function (e) {}, e
        }()
    }.call(this),
    function () {
        var i = function (e, t) {
            return function () {
                return e.apply(t, arguments)
            }
        };
        null == this.ParticleSaga && (this.ParticleSaga = {}), ParticleSaga.AbstractTarget = function () {
            function e(e, t) {
                this.targetData = e, this.getParticles = i(this.getParticles, this), this.resize = i(this.resize, this), this.destroy = i(this.destroy, this), this.onLoad = i(this.onLoad, this), this.load = i(this.load, this), this.init = i(this.init, this), this.onLoadCallback
            }
            return e.prototype.init = function () {}, e.prototype.load = function (e) {
                return this.onLoadCallback = e
            }, e.prototype.onLoad = function () {
                if (null != this.onLoadCallback) return this.onLoadCallback()
            }, e.prototype.destroy = function () {
                if (null != this.particles) return this.particles.geometry.dispose(), this.particles.material.dispose(), this.particles = null
            }, e.prototype.resize = function () {}, e.prototype.getParticles = function () {
                return null
            }, e
        }()
    }.call(this),
    function () {
        var n = function (e, t) {
                return function () {
                    return e.apply(t, arguments)
                }
            },
            r = {}.hasOwnProperty;
        null == this.ParticleSaga && (this.ParticleSaga = {}), ParticleSaga.ImageTarget = function (e) {
            function i(e, t) {
                this.targetData = e, this.getParticles = n(this.getParticles, this), this.scalevertex = n(this.scalevertex, this), this.centerVertex = n(this.centerVertex, this), this.getVertexForPixelDataOffset = n(this.getVertexForPixelDataOffset, this), this.randomVertexInImage = n(this.randomVertexInImage, this), this.getImageDataFromImg = n(this.getImageDataFromImg, this), this.processImage = n(this.processImage, this), this.onLoad = n(this.onLoad, this), this.load = n(this.load, this), this.updateParticlePositions = n(this.updateParticlePositions, this), this.updatePositionAdjustments = n(this.updatePositionAdjustments, this), this.resize = n(this.resize, this), this.init = n(this.init, this), i.__super__.constructor.call(this, this.targetData, t), this.particles, this.container = this.targetData.container, this.validPixelArrayOffsets = [], this.maxW = 0, this.maxH = 0, this.offsetX = 0, this.offsetY = 0, this.imageData, this.aspectFillImageScaleX = 1, this.aspectFillImageScaleY = 1, this.opts = {
                    numParticles: 1e4,
                    respondsToMouse: !1,
                    size: 1,
                    sort: null
                }, ParticleSaga.Utils.extend(this.opts, t)
            }
            return function (e, t) {
                for (var i in t) r.call(t, i) && (e[i] = t[i]);

                function n() {
                    this.constructor = e
                }
                n.prototype = t.prototype, e.prototype = new n, e.__super__ = t.prototype
            }(i, ParticleSaga.AbstractTarget), i.prototype.init = function () {
                return this.resize()
            }, i.prototype.resize = function () {
                if (this.maxW = this.container.offsetWidth, this.maxH = this.container.offsetHeight, this.imageData && (this.updatePositionAdjustments(), this.particles)) return this.updateParticlePositions()
            }, i.prototype.updatePositionAdjustments = function () {
                var e, t, i, n;
                return n = this.maxW, e = this.maxH, i = this.maxW / this.maxH, (t = this.imageData.width / this.imageData.height) < i ? e = (n = this.maxW) / t : n = (e = this.maxH) * t, this.aspectFillImageScaleX = n / this.imageData.width, this.aspectFillImageScaleY = e / this.imageData.height, this.offsetX = (this.maxW - this.imageData.width) / 2, this.offsetY = -(this.maxH - this.imageData.height) / 2
            }, i.prototype.updateParticlePositions = function () {
                var e, t, i, n, r, o;
                for (o = [], i = 0, n = (r = this.particles.geometry.vertices).length; i < n; i++) t = r[i], e = this.getVertexForPixelDataOffset(t.userData.pixelOffset), t.x = e.x, t.y = e.y, o.push(t.z = e.z);
                return o
            }, i.prototype.load = function (e) {
                return i.__super__.load.call(this, e), (new THREE.ImageLoader).load(this.targetData.url, this.onLoad)
            }, i.prototype.onLoad = function (e) {
                return this.processImage(e), i.__super__.onLoad.call(this)
            }, i.prototype.processImage = function (e) {
                var t, i, n, r, o, a, s, l;
                for (this.imageData = this.getImageDataFromImg(e), this.updatePositionAdjustments(), i = o = 3, s = this.imageData.data.length; o < s; i = o += 4) 0 < this.imageData.data[i] && this.validPixelArrayOffsets.push(i - 3);
                for (t = new THREE.Geometry, i = a = 0, l = this.opts.numParticles; a < l; i = a += 1) r = this.randomVertexInImage(), t.vertices.push(r);
                return null != this.opts.sort && t.vertices.sort(this.opts.sort), n = new THREE.ParticleSystemMaterial({
                    size: this.opts.size
                }), this.particles = new THREE.ParticleSystem(t, n)
            }, i.prototype.getImageDataFromImg = function (e) {
                var t, i;
                return (t = document.createElement("canvas")).width = e.width, t.height = e.height, (i = t.getContext("2d")).drawImage(e, 0, 0), i.getImageData(0, 0, e.width, e.height)
            }, i.prototype.randomVertexInImage = function () {
                var e, t;
                return t = Math.floor(Math.random() * this.validPixelArrayOffsets.length), e = this.validPixelArrayOffsets[t], this.getVertexForPixelDataOffset(e)
            }, i.prototype.getVertexForPixelDataOffset = function (e) {
                var t, i, n, r, o, a, s;
                return r = this.imageData.data[e], n = this.imageData.data[e + 1], t = this.imageData.data[e + 2], i = 4 * this.imageData.width, a = Math.ceil(e % i / 4), s = Math.ceil(e / i), (o = new THREE.Vector3(a, s, 0)).userData = {
                    color: {
                        r: r / 255,
                        g: n / 255,
                        b: t / 255
                    },
                    pixelOffset: e
                }, this.centerVertex(o), this.scalevertex(o), o
            }, i.prototype.centerVertex = function (e) {
                return e.x -= this.maxW / 2, e.y = -e.y + this.maxH / 2, e.x += this.offsetX, e.y += this.offsetY
            }, i.prototype.scalevertex = function (e) {
                return e.x *= this.aspectFillImageScaleX, e.y *= this.aspectFillImageScaleY
            }, i.prototype.getParticles = function () {
                return this.particles
            }, i
        }()
    }.call(this),
    function () {
        var i = function (e, t) {
                return function () {
                    return e.apply(t, arguments)
                }
            },
            r = {}.hasOwnProperty;
        null == this.ParticleSaga && (this.ParticleSaga = {}), ParticleSaga.ModelTarget = function (e) {
            function a(e, t) {
                this.targetData = e, this.getParticles = i(this.getParticles, this), this.processGeometry = i(this.processGeometry, this), this.onLoad = i(this.onLoad, this), this.load = i(this.load, this), a.__super__.constructor.call(this, this.targetData, t), this.particles, this.container = this.targetData.container, this.opts = {
                    color: {
                        r: 1,
                        g: 1,
                        b: 1
                    },
                    initialMatrices: [],
                    respondsToMouse: !1,
                    scale: 1,
                    size: 1,
                    sort: null
                }, ParticleSaga.Utils.extend(this.opts, t)
            }
            return function (e, t) {
                for (var i in t) r.call(t, i) && (e[i] = t[i]);

                function n() {
                    this.constructor = e
                }
                n.prototype = t.prototype, e.prototype = new n, e.__super__ = t.prototype
            }(a, ParticleSaga.AbstractTarget), a.prototype.load = function (e) {
                var t, i, n, r, o;
                if (a.__super__.load.call(this, e), null == this.targetData.preloadedVertices) return (new THREE.JSONLoader).load(this.targetData.url, this.onLoad);
                for (t = new THREE.Geometry, i = r = 0, o = (n = this.targetData.preloadedVertices).length; r < o; i = r += 3) t.vertices.push(new THREE.Vector3(n[i], n[i + 1], n[i + 2]));
                return this.onLoad(t)
            }, a.prototype.onLoad = function (e) {
                return this.processGeometry(e), a.__super__.onLoad.call(this)
            }, a.prototype.processGeometry = function (e) {
                var t, i, n, r, o, a, s, l;
                for (e.mergeVertices(), n = 0, o = (s = e.vertices).length; n < o; n++) s[n].userData = {
                    color: this.opts.color
                };
                for (r = 0, a = (l = this.opts.initialMatrices).length; r < a; r++) i = l[r], e.applyMatrix(i);
                return e.applyMatrix((new THREE.Matrix4).makeScale(this.opts.scale, this.opts.scale, this.opts.scale)), null != this.opts.sort && e.vertices.sort(this.opts.sort), t = new THREE.ParticleSystemMaterial({
                    size: this.opts.size
                }), this.particles = new THREE.ParticleSystem(e, t)
            }, a.prototype.getParticles = function () {
                return this.particles
            }, a
        }()
    }.call(this),
    function () {
        var i = function (e, t) {
                return function () {
                    return e.apply(t, arguments)
                }
            },
            r = {}.hasOwnProperty;
        null == this.ParticleSaga && (this.ParticleSaga = {}), ParticleSaga.MultiTarget = function (e) {
            function l(e, t) {
                this.targetData = e, this.getParticles = i(this.getParticles, this), this.resize = i(this.resize, this), this.getTargetOffsets = i(this.getTargetOffsets, this), this.prepareParticles = i(this.prepareParticles, this), this.onTargetLoad = i(this.onTargetLoad, this), this.load = i(this.load, this), l.__super__.constructor.call(this, this.targetData, t), this.targets = [], this.particles, this.container = this.targetData.container, this.numTargetsLoaded = 0, this.opts = {
                    color: {
                        r: 1,
                        g: 1,
                        b: 1
                    },
                    respondsToMouse: !1,
                    size: 1,
                    sort: null
                }, ParticleSaga.Utils.extend(this.opts, t)
            }
            return function (e, t) {
                for (var i in t) r.call(t, i) && (e[i] = t[i]);

                function n() {
                    this.constructor = e
                }
                n.prototype = t.prototype, e.prototype = new n, e.__super__ = t.prototype
            }(l, ParticleSaga.AbstractTarget), l.prototype.load = function (e) {
                var t, i, n, r, o, a, s;
                for (l.__super__.load.call(this, e), s = [], t = r = 0, o = (a = this.targetData.targets).length; r < o; t = ++r) null == (n = a[t]).container && (n.container = this.container), null == n.options && (n.options = n.options || {}), n.type !== ParticleSaga.ModelTarget && (n.options.numParticles = this.opts.numParticles), i = {}, ParticleSaga.Utils.extend(i, this.opts), ParticleSaga.Utils.extend(i, n.options), this.targets.push(new n.type(n, i)), this.targets[t].init(), s.push(this.targets[t].load(this.onTargetLoad));
                return s
            }, l.prototype.onTargetLoad = function () {
                if (this.numTargetsLoaded++, 0 < this.numTargetsLoaded && this.numTargetsLoaded === this.targetData.targets.length) return this.resize(), this.onLoad()
            }, l.prototype.prepareParticles = function () {
                var e, t, i, n, r, o, a, s, l, c, h, u, f, d;
                for (e = new THREE.Geometry, t = l = 0, h = (f = this.targets).length; l < h; t = ++l)
                    for (n = f[t], r = this.targetData.targets[t], o = this.getTargetOffsets(r), c = 0, u = (d = n.getParticles().geometry.vertices).length; c < u; c++)(s = d[c]).userData, (a = s.clone()).userData = s.userData, a.x += o.x, a.y += o.y, e.vertices.push(a);
                return null != this.opts.sort && e.vertices.sort(this.opts.sort), i = new THREE.ParticleSystemMaterial({
                    size: this.opts.size
                }), this.particles = new THREE.ParticleSystem(e, i)
            }, l.prototype.getTargetOffsets = function (e) {
                var t, i, n;
                return 0, n = this.container.offsetWidth / 2, i = this.container.offsetHeight / 2, {
                    x: (t = e.container).offsetLeft + .5 * t.offsetWidth - n,
                    y: i - (t.offsetTop + 0 + .5 * t.offsetHeight)
                }
            }, l.prototype.resize = function () {
                return this.prepareParticles()
            }, l.prototype.getParticles = function () {
                return this.particles
            }, l
        }()
    }.call(this);
var CanvasAnim = {
    init: function () {
        $(".feature").length && CanvasAnim.animation()
    },
    animation: function () {
        var e = [{
                type: ParticleSaga.ModelTarget,
                url: "./models/robot.json",
                options: {
                    color: {
                        r: 1,
                        g: 0,
                        b: 0
                    },
                    scale: 1,
                    size: 3,
                    respondsToMouse: !1,
                    initialMatrices: [(new THREE.Matrix4).makeRotationY(2), (new THREE.Matrix4).makeTranslation(0, 50, -10)]
                }
            }, {
                type: ParticleSaga.ModelTarget,
                url: "./models/drone.json",
                options: {
                    color: {
                        r: 0,
                        g: .73,
                        b: .83
                    },
                    scale: 80,
                    size: 3,
                    respondsToMouse: !1,
                    initialMatrices: [(new THREE.Matrix4).makeRotationX(-.5)]
                }
            }, {
                type: ParticleSaga.ModelTarget,
                url: "./models/glasses.json",
                options: {
                    color: {
                        r: 1,
                        g: .75,
                        b: 0
                    },
                    size: 3,
                    scale: 1.75,
                    respondsToMouse: !1,
                    initialMatrices: [(new THREE.Matrix4).makeTranslation(0, -50, 0), (new THREE.Matrix4).makeRotationX(-.25), (new THREE.Matrix4).makeRotationZ(.25)]
                }
            }, {
                type: ParticleSaga.ModelTarget,
                url: "./models/car.json",
                options: {
                    color: {
                        r: .7,
                        g: .7,
                        b: .7
                    },
                    size: 3,
                    scale: 50,
                    respondsToMouse: !1,
                    initialMatrices: [(new THREE.Matrix4).makeTranslation(0, -2, 0), (new THREE.Matrix4).makeRotationX(-.25)]
                }
            }, {
                type: ParticleSaga.ModelTarget,
                url: "./models/product.json",
                options: {
                    color: {
                        r: .5,
                        g: .05,
                        b: 1
                    },
                    size: 3,
                    scale: 200,
                    respondsToMouse: !1,
                    initialMatrices: [(new THREE.Matrix4).makeTranslation(0, 0, -1), (new THREE.Matrix4).makeRotationX(-Math.PI / 2)]
                }
            }, {
                type: ParticleSaga.ModelTarget,
                url: "./models/blank.json",
                options: {
                    color: {
                        r: .7,
                        g: .7,
                        b: .7
                    },
                    size: 3,
                    scale: 1.5,
                    respondsToMouse: !1,
                    initialMatrices: [(new THREE.Matrix4).makeTranslation(0, -2, 0), (new THREE.Matrix4).makeRotationX(.25)]
                }
            }],
            t = document.getElementById("pointcloud"),
            r = new ParticleSaga.Scene(t, e, {
                numParticles: 3e4,
                sort: ParticleSaga.VertexSort.randomish
            });
        r.load(function () {
            r.setTarget(0)
        }), 
		$(".feature h2").on("inview", function (e, t) {
            var i = $(this).parents(".feature"),
                n = i.index(".feature");
            t ? (i.addClass("in-viewport"), r.setTarget(n)) : i.removeClass("in-viewport")
        })
		
    }
};
$(document).ready(function () {
    CanvasAnim.init()
});